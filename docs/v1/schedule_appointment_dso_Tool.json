{
  "name": "schedule_appointment_ortho",
  "description": "Appointment scheduling operations. Use action 'slots' to get available times, 'grouped_slots' for siblings, 'book_child' to book, 'cancel' to cancel. Dates in MM/DD/YYYY format. Past dates are auto-corrected to tomorrow.\n\nACTION 'slots': Get available appointment times for ONE patient. Returns startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes.\n\nACTION 'grouped_slots': **REQUIRED** when booking for 2+ children (siblings). Provide startDate, endDate, and numberOfPatients (must be 2 or more). Returns grouped consecutive slots that fit all children. ALWAYS use this instead of 'slots' when scheduling multiple patients.\n\nACTION 'book_child': MUST call AFTER caller confirms appointment time. REQUIRES: patientGUID, startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes. All values come from the slots/grouped_slots response. Call ONCE PER CHILD using their specific slot.\n\nACTION 'cancel': Call to cancel an existing appointment. Requires appointmentGUID.\n\nCRITICAL: (1) Never transfer without first calling this tool with action 'slots' or 'grouped_slots'. (2) For 2+ children, you MUST use 'grouped_slots' with numberOfPatients parameter. (3) After successful slot retrieval, offer times to caller - do NOT transfer.\n",
  "color": "linear-gradient(rgb(119,46,188), rgb(11,231,3))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"The scheduling operation: slots, grouped_slots, book_child, cancel\",\"required\":true},{\"id\":1,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"Start date MM/DD/YYYY\",\"required\":false},{\"id\":2,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"End date MM/DD/YYYY\",\"required\":false},{\"id\":3,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"Schedule view GUIDs\",\"required\":false},{\"id\":4,\"property\":\"numberOfPatients\",\"type\":\"integer\",\"description\":\"Number of patients for grouped_slots\",\"required\":false},{\"id\":5,\"property\":\"timeWindowMinutes\",\"type\":\"integer\",\"description\":\"Time window in minutes\",\"required\":false},{\"id\":6,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"Patient GUID for booking\",\"required\":false},{\"id\":7,\"property\":\"startTime\",\"type\":\"string\",\"description\":\"Appointment time MM/DD/YYYY HH:MM AM\",\"required\":false},{\"id\":8,\"property\":\"scheduleViewGUID\",\"type\":\"string\",\"description\":\"Schedule view GUID\",\"required\":false},{\"id\":9,\"property\":\"scheduleColumnGUID\",\"type\":\"string\",\"description\":\"Schedule column GUID\",\"required\":false},{\"id\":10,\"property\":\"appointmentTypeGUID\",\"type\":\"string\",\"description\":\"Appointment type GUID\",\"required\":false},{\"id\":11,\"property\":\"minutes\",\"type\":\"integer\",\"description\":\"Duration in minutes\",\"required\":false},{\"id\":12,\"property\":\"providerGUID\",\"type\":\"string\",\"description\":\"Provider GUID\",\"required\":false},{\"id\":13,\"property\":\"locationGUID\",\"type\":\"string\",\"description\":\"Location GUID\",\"required\":false},{\"id\":14,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"Appointment GUID for cancel\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING DSO - Appointment Scheduling Tool (Node Red Version)\n * Version: v44 | Updated: 2026-01-04\n * ============================================================================\n * Actions: slots, grouped_slots, book_child, cancel\n *\n * v44 FIX: Fixed fetch body consumption bug AND removed DEFAULT_SCHEDULE_VIEW_GUID\n *          - Body stream can only be read once, now reads text first then parses JSON\n *          - Removed DEFAULT_SCHEDULE_VIEW_GUID which pointed to schedule with no slots\n * v42 FIX: Default numberOfPatients=2 for grouped_slots (LLM often omits it)\n * v41 FIX: Added _debug_error and _debug_dates for API failure diagnosis\n * CRITICAL FIX: SANDBOX_MIN_DATE ensures slot searches start from Jan 13, 2026\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\nconst TOOL_VERSION = 'v44';\nconst MAX_SLOTS_RETURNED = 10;\nconst BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord';\n\n// SANDBOX MINIMUM DATE: Cloud9 sandbox has no slots before this date\nconst SANDBOX_MIN_DATE = new Date(2026, 0, 13); // January 13, 2026\n\nconst ACTIONS = {\n    slots: {\n        endpoint: `${BASE_URL}/ortho/getApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            const body = {\n                uui: uui,\n                startDate: params.startDate,\n                endDate: params.endDate\n            };\n            // v44: Only include scheduleViewGUIDs if explicitly provided (removed broken default)\n            if (params.scheduleViewGUIDs) {\n                body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            }\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.count || (data.slots ? data.slots.length : 0) || 0} available slots`\n    },\n    grouped_slots: {\n        endpoint: `${BASE_URL}/ortho/getGroupedApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            const body = {\n                uui: uui,\n                startDate: params.startDate,\n                endDate: params.endDate,\n                numberOfPatients: params.numberOfPatients || 2,\n                timeWindowMinutes: params.timeWindowMinutes || 30\n            };\n            // v44: Only include scheduleViewGUIDs if explicitly provided (removed broken default)\n            if (params.scheduleViewGUIDs) {\n                body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            }\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.totalGroups || (data.groups ? data.groups.length : 0) || 0} grouped slot options`\n    },\n    book_child: {\n        endpoint: `${BASE_URL}/ortho/createAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            patientGUID: params.patientGUID,\n            startTime: params.startTime,\n            scheduleViewGUID: params.scheduleViewGUID,\n            scheduleColumnGUID: params.scheduleColumnGUID,\n            appointmentTypeGUID: params.appointmentTypeGUID || '8fc9d063-ae46-4975-a5ae-734c6efe341a',\n            minutes: params.minutes || 45,\n            childName: params.childName\n        }),\n        validate: (params) => {\n            const missing = [];\n            if (!params.patientGUID) missing.push('patientGUID');\n            if (!params.startTime) missing.push('startTime');\n            if (!params.scheduleViewGUID) missing.push('scheduleViewGUID');\n            if (!params.scheduleColumnGUID) missing.push('scheduleColumnGUID');\n            if (missing.length > 0) {\n                throw new Error('BOOKING FAILED - Missing required fields: ' + missing.join(', '));\n            }\n        },\n        successLog: () => 'Appointment booked successfully'\n    },\n    cancel: {\n        endpoint: `${BASE_URL}/ortho/cancelAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            appointmentGUID: params.appointmentGUID\n        }),\n        validate: (params) => {\n            if (!params.appointmentGUID) {\n                throw new Error(\"appointmentGUID is required for 'cancel' action\");\n            }\n        },\n        successLog: () => 'Appointment cancelled successfully'\n    }\n};\n\nfunction getAuthHeader() {\n    try {\n        const username = \"workflowapi\";\n        const password = \"e^@V95&6sAJReTsb5!iq39mIC4HYIV\";\n        const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n        return `Basic ${credentials}`;\n    } catch (e) {\n        return null;\n    }\n}\n\nfunction checkForError(data) {\n    if (!data || typeof data !== 'object') return null;\n    if (data.success === false && !data.llm_guidance) return data.error || 'Operation failed';\n    if (data.code === false) return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    if (data.error && !data.slots && !data.groups && !data.appointmentGUID && !data.llm_guidance) {\n        return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    }\n    return null;\n}\n\nfunction formatDate(date) {\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nfunction parseDate(dateStr) {\n    if (!dateStr) return null;\n    const parts = dateStr.split('/');\n    if (parts.length !== 3) return null;\n    return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n}\n\nfunction correctDate(dateStr) {\n    if (!dateStr) return dateStr;\n    const inputDate = parseDate(dateStr);\n    if (!inputDate) return dateStr;\n\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const tomorrow = new Date(today);\n    tomorrow.setDate(tomorrow.getDate() + 1);\n\n    let targetDate = inputDate;\n    if (inputDate < today) {\n        targetDate = tomorrow;\n    }\n    if (targetDate < SANDBOX_MIN_DATE) {\n        targetDate = new Date(SANDBOX_MIN_DATE);\n    }\n    if (targetDate.getTime() !== inputDate.getTime()) {\n        return formatDate(targetDate);\n    }\n    return dateStr;\n}\n\nfunction correctDateRange(startDate, endDate) {\n    let correctedStart = correctDate(startDate);\n    let correctedEnd = correctDate(endDate);\n\n    if (!correctedStart) {\n        correctedStart = formatDate(new Date(SANDBOX_MIN_DATE));\n    }\n\n    const start = parseDate(correctedStart);\n    const end = parseDate(correctedEnd);\n\n    if (!end || end <= start) {\n        const newEnd = new Date(start);\n        newEnd.setDate(newEnd.getDate() + 14);\n        correctedEnd = formatDate(newEnd);\n    } else {\n        const daysDiff = Math.floor((end - start) / (1000 * 60 * 60 * 24));\n        if (daysDiff < 7) {\n            const newEnd = new Date(start);\n            newEnd.setDate(newEnd.getDate() + 14);\n            correctedEnd = formatDate(newEnd);\n        }\n    }\n    return { startDate: correctedStart, endDate: correctedEnd };\n}\n\nfunction cleanParams(params) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(params)) {\n        if (value !== null && value !== undefined && value !== '' &&\n            value !== 'NULL' && value !== 'null' && value !== 'None' &&\n            value !== 'none' && value !== 'N/A' && value !== 'n/a') {\n            cleaned[key] = value;\n        }\n    }\n    return cleaned;\n}\n\nasync function executeRequest() {\n    const toolName = 'schedule_appointment_ortho';\n    const action = $action;\n\n    console.log('[' + toolName + '] ' + TOOL_VERSION + ' - 2026-01-04 - Removed DEFAULT_SCHEDULE_VIEW_GUID + fetch fix');\n    console.log('[' + toolName + '] Action: ' + action);\n\n    if (!action || !ACTIONS[action]) {\n        throw new Error('Invalid action. Valid: ' + Object.keys(ACTIONS).join(', '));\n    }\n\n    const config = ACTIONS[action];\n\n    let uui;\n    if (!$vars || !$vars.c1mg_uui || $vars.c1mg_uui === 'c1mg_uui' || (typeof $vars.c1mg_uui === 'string' && $vars.c1mg_uui.trim() === '')) {\n        uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';\n    } else {\n        uui = $vars.c1mg_uui;\n    }\n\n    const rawParams = {\n        startDate: typeof $startDate !== 'undefined' ? $startDate : null,\n        endDate: typeof $endDate !== 'undefined' ? $endDate : null,\n        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,\n        startTime: typeof $startTime !== 'undefined' ? $startTime : null,\n        scheduleViewGUID: typeof $scheduleViewGUID !== 'undefined' ? $scheduleViewGUID : null,\n        scheduleColumnGUID: typeof $scheduleColumnGUID !== 'undefined' ? $scheduleColumnGUID : null,\n        appointmentTypeGUID: typeof $appointmentTypeGUID !== 'undefined' ? $appointmentTypeGUID : null,\n        minutes: typeof $minutes !== 'undefined' ? $minutes : null,\n        providerGUID: typeof $providerGUID !== 'undefined' ? $providerGUID : null,\n        locationGUID: typeof $locationGUID !== 'undefined' ? $locationGUID : null,\n        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null,\n        childName: typeof $childName !== 'undefined' ? $childName : null\n    };\n    const params = cleanParams(rawParams);\n\n    const originalDates = { startDate: params.startDate, endDate: params.endDate };\n\n    if (action === 'slots' || action === 'grouped_slots') {\n        const corrected = correctDateRange(params.startDate, params.endDate);\n        if (corrected.startDate) params.startDate = corrected.startDate;\n        if (corrected.endDate) params.endDate = corrected.endDate;\n    }\n\n    const correctedDates = { startDate: params.startDate, endDate: params.endDate };\n\n    try {\n        config.validate(params);\n        const body = config.buildBody(params, uui);\n        console.log('[' + toolName + '] Request:', JSON.stringify(body));\n\n        const headers = { 'Content-Type': 'application/json' };\n        const authHeader = getAuthHeader();\n        if (authHeader) headers['Authorization'] = authHeader;\n\n        const response = await fetch(config.endpoint, {\n            method: config.method,\n            headers: headers,\n            body: JSON.stringify(body)\n        });\n\n        // v44 FIX: Read body as text first, then parse JSON safely\n        const responseText = await response.text();\n        let data;\n        try {\n            data = JSON.parse(responseText);\n        } catch (parseError) {\n            data = responseText;\n        }\n\n        if (!response.ok) {\n            throw new Error('HTTP ' + response.status + ': ' + response.statusText);\n        }\n\n        const errorMessage = checkForError(data);\n        if (errorMessage) throw new Error(errorMessage);\n\n        console.log('[' + toolName + '] ' + config.successLog(data));\n\n        if (data && data.slots && data.slots.length > MAX_SLOTS_RETURNED) {\n            data.slots = data.slots.slice(0, MAX_SLOTS_RETURNED);\n            data.count = MAX_SLOTS_RETURNED;\n            data._truncated = true;\n        }\n        if (data && data.groups && data.groups.length > MAX_SLOTS_RETURNED) {\n            data.groups = data.groups.slice(0, MAX_SLOTS_RETURNED);\n            data.totalGroups = MAX_SLOTS_RETURNED;\n            data._truncated = true;\n        }\n\n        if (typeof data === 'object') {\n            data._toolVersion = TOOL_VERSION;\n        }\n\n        var result = JSON.stringify(data);\n        console.log('[' + toolName + '] Response size: ' + result.length + ' bytes');\n        return result;\n\n    } catch (error) {\n        console.error('[' + toolName + '] Error:', error.message);\n\n        const isMissingSlotFields = error.message.includes('BOOKING FAILED');\n        if (isMissingSlotFields) {\n            return JSON.stringify({\n                success: false,\n                _toolVersion: TOOL_VERSION,\n                llm_guidance: {\n                    error_type: 'missing_slot_data',\n                    voice_response: 'Let me verify that time for you.',\n                    action_required: 'refetch_slots_and_retry',\n                    CRITICAL: 'Do NOT transfer. Re-fetch slots then retry booking.'\n                }\n            });\n        }\n\n        return JSON.stringify({\n            success: false,\n            _toolVersion: TOOL_VERSION,\n            _debug_error: error.message,\n            _debug_dates: {\n                original: originalDates,\n                corrected: correctedDates,\n                action: action\n            },\n            llm_guidance: {\n                error_type: 'api_error',\n                voice_response: 'I want to connect you with a specialist. One moment while I transfer your call.',\n                action_required: 'transfer_to_agent',\n                CRITICAL: 'Do NOT mention error to caller. Transfer gracefully.'\n            }\n        });\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}