{
  "name": "schedule_appointment_ortho",
  "description": "Appointment scheduling operations. Use action 'slots' to get available times, 'grouped_slots' for siblings, 'book_child' to book, 'cancel' to cancel. Dates in MM/DD/YYYY format. Past dates are auto-corrected to tomorrow.\n\nACTION 'slots': Get available appointment times for ONE patient. Returns startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes.\n\nACTION 'grouped_slots': **REQUIRED** when booking for 2+ children (siblings). Provide startDate, endDate, and numberOfPatients (must be 2 or more). Returns grouped consecutive slots that fit all children. ALWAYS use this instead of 'slots' when scheduling multiple patients.\n\nACTION 'book_child': MUST call AFTER caller confirms appointment time. REQUIRES: patientGUID, startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes. All values come from the slots/grouped_slots response. Call ONCE PER CHILD using their specific slot.\n\nACTION 'cancel': Call to cancel an existing appointment. Requires appointmentGUID.\n\nCRITICAL: (1) Never transfer without first calling this tool with action 'slots' or 'grouped_slots'. (2) For 2+ children, you MUST use 'grouped_slots' with numberOfPatients parameter. (3) After successful slot retrieval, offer times to caller - do NOT transfer.\n",
  "color": "linear-gradient(rgb(119,46,188), rgb(11,231,3))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"The scheduling operation: slots, grouped_slots, book_child, cancel\",\"required\":true},{\"id\":1,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"Start date MM/DD/YYYY\",\"required\":false},{\"id\":2,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"End date MM/DD/YYYY\",\"required\":false},{\"id\":3,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"Schedule view GUIDs\",\"required\":false},{\"id\":4,\"property\":\"numberOfPatients\",\"type\":\"integer\",\"description\":\"Number of patients for grouped_slots\",\"required\":false},{\"id\":5,\"property\":\"timeWindowMinutes\",\"type\":\"integer\",\"description\":\"Time window in minutes\",\"required\":false},{\"id\":6,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"Patient GUID for booking\",\"required\":false},{\"id\":7,\"property\":\"startTime\",\"type\":\"string\",\"description\":\"Appointment time MM/DD/YYYY HH:MM AM\",\"required\":false},{\"id\":8,\"property\":\"scheduleViewGUID\",\"type\":\"string\",\"description\":\"Schedule view GUID\",\"required\":false},{\"id\":9,\"property\":\"scheduleColumnGUID\",\"type\":\"string\",\"description\":\"Schedule column GUID\",\"required\":false},{\"id\":10,\"property\":\"appointmentTypeGUID\",\"type\":\"string\",\"description\":\"Appointment type GUID\",\"required\":false},{\"id\":11,\"property\":\"minutes\",\"type\":\"integer\",\"description\":\"Duration in minutes\",\"required\":false},{\"id\":12,\"property\":\"providerGUID\",\"type\":\"string\",\"description\":\"Provider GUID\",\"required\":false},{\"id\":13,\"property\":\"locationGUID\",\"type\":\"string\",\"description\":\"Location GUID\",\"required\":false},{\"id\":14,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"Appointment GUID for cancel\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING DSO - Appointment Scheduling Tool (Node Red Version)\n * Version: v19 | Updated: 2026-01-01\n * ============================================================================\n * Actions: slots, grouped_slots, book_child, cancel\n * \n * This version calls Node Red endpoints instead of Cloud9 directly.\n * All Cloud9 XML/SOAP logic, stepwise search, and LLM guidance is handled by Node Red.\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\n// ============================================================================\n// üìù ACTION CONFIGURATIONS\n// ============================================================================\n\nconst BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord';\n\nconst ACTIONS = {\n    slots: {\n        endpoint: `${BASE_URL}/ortho/getApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            startDate: params.startDate,\n            endDate: params.endDate,\n            scheduleViewGUIDs: params.scheduleViewGUIDs\n        }),\n        validate: () => {},\n        successLog: (data) => `Found ${data.count || (data.slots ? data.slots.length : 0) || 0} available slots`\n    },\n    grouped_slots: {\n        endpoint: `${BASE_URL}/ortho/getGroupedApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            startDate: params.startDate,\n            endDate: params.endDate,\n            numberOfPatients: params.numberOfPatients,\n            timeWindowMinutes: params.timeWindowMinutes,\n            scheduleViewGUIDs: params.scheduleViewGUIDs\n        }),\n        validate: (params) => {\n            if (!params.numberOfPatients) {\n                throw new Error(\"numberOfPatients is required for 'grouped_slots' action\");\n            }\n        },\n        successLog: (data) => `Found ${data.totalGroups || (data.groups ? data.groups.length : 0) || 0} grouped slot options`\n    },\n    book_child: {\n        endpoint: `${BASE_URL}/ortho/createAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            patientGUID: params.patientGUID,\n            startTime: params.startTime,\n            scheduleViewGUID: params.scheduleViewGUID,\n            scheduleColumnGUID: params.scheduleColumnGUID,\n            appointmentTypeGUID: params.appointmentTypeGUID || '8fc9d063-ae46-4975-a5ae-734c6efe341a',\n            minutes: params.minutes || 45,\n            childName: params.childName\n        }),\n        validate: (params) => {\n            // CRITICAL: All slot fields are REQUIRED for booking to succeed\n            // These must be extracted EXACTLY from the slots/grouped_slots response\n            const missing = [];\n            if (!params.patientGUID) missing.push('patientGUID');\n            if (!params.startTime) missing.push('startTime');\n            if (!params.scheduleViewGUID) missing.push('scheduleViewGUID');\n            if (!params.scheduleColumnGUID) missing.push('scheduleColumnGUID');\n\n            if (missing.length > 0) {\n                throw new Error(\n                    'BOOKING FAILED - Missing required fields: ' + missing.join(', ') + '. ' +\n                    'You MUST extract these from the slots response. Each slot contains: ' +\n                    'StartTime, ScheduleViewGUID, ScheduleColumnGUID, AppointmentTypeGUID, Minutes. ' +\n                    'Copy these EXACTLY when calling book_child.'\n                );\n            }\n        },\n        successLog: () => 'Appointment booked successfully'\n    },\n    cancel: {\n        endpoint: `${BASE_URL}/ortho/cancelAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            appointmentGUID: params.appointmentGUID\n        }),\n        validate: (params) => {\n            if (!params.appointmentGUID) {\n                throw new Error(\"appointmentGUID is required for 'cancel' action\");\n            }\n        },\n        successLog: () => 'Appointment cancelled successfully'\n    }\n};\n\n// ============================================================================\n// üîê AUTHENTICATION\n// ============================================================================\n\nfunction getAuthHeader() {\n    try {\n        const username = \"workflowapi\";\n        const password = \"e^@V95&6sAJReTsb5!iq39mIC4HYIV\";\n        if (username && password) {\n            const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n            return `Basic ${credentials}`;\n        }\n    } catch (e) {\n        return null;\n    }\n    return null;\n}\n\n// ============================================================================\n// üîç ERROR DETECTION HELPER\n// ============================================================================\n\nfunction checkForError(data) {\n    if (!data || typeof data !== 'object') return null;\n    \n    // Pattern 1: { success: false, error: \"...\" }\n    if (data.success === false && !data.llm_guidance) {\n        return data.error || data.message || 'Operation failed';\n    }\n    \n    // Pattern 2: { code: false, error: [...] }\n    if (data.code === false) {\n        if (Array.isArray(data.error)) {\n            return data.error.join(', ');\n        }\n        return data.error || data.message || 'API returned error';\n    }\n    \n    // Pattern 3: { error: \"...\" } without success/code/slots/groups field\n    if (data.error && !data.slots && !data.groups && !data.appointmentGUID && !data.llm_guidance) {\n        if (Array.isArray(data.error)) {\n            return data.error.join(', ');\n        }\n        return data.error;\n    }\n    \n    return null;\n}\n\n// ============================================================================\n// üìÖ DATE CORRECTION - Auto-correct past dates to future\n// ============================================================================\n\nfunction correctDate(dateStr) {\n    if (!dateStr) return dateStr;\n    \n    // Parse MM/DD/YYYY format\n    const parts = dateStr.split('/');\n    if (parts.length !== 3) return dateStr;\n    \n    const month = parseInt(parts[0], 10);\n    const day = parseInt(parts[1], 10);\n    const year = parseInt(parts[2], 10);\n    \n    const inputDate = new Date(year, month - 1, day);\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    // If date is in the past, set to tomorrow\n    if (inputDate < today) {\n        const tomorrow = new Date(today);\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        const mm = String(tomorrow.getMonth() + 1).padStart(2, '0');\n        const dd = String(tomorrow.getDate()).padStart(2, '0');\n        const yyyy = tomorrow.getFullYear();\n        console.log(`[DATE CORRECTION] ${dateStr} is in the past, correcting to ${mm}/${dd}/${yyyy}`);\n        return `${mm}/${dd}/${yyyy}`;\n    }\n    \n    return dateStr;\n}\n\nfunction correctDateRange(startDate, endDate) {\n    const correctedStart = correctDate(startDate);\n    let correctedEnd = correctDate(endDate);\n    \n    // Ensure end date is after start date\n    if (correctedStart && correctedEnd) {\n        const startParts = correctedStart.split('/');\n        const endParts = correctedEnd.split('/');\n        const start = new Date(parseInt(startParts[2]), parseInt(startParts[0]) - 1, parseInt(startParts[1]));\n        const end = new Date(parseInt(endParts[2]), parseInt(endParts[0]) - 1, parseInt(endParts[1]));\n        \n        if (end <= start) {\n            // Set end date to start + 4 days\n            const newEnd = new Date(start);\n            newEnd.setDate(newEnd.getDate() + 4);\n            const mm = String(newEnd.getMonth() + 1).padStart(2, '0');\n            const dd = String(newEnd.getDate()).padStart(2, '0');\n            const yyyy = newEnd.getFullYear();\n            correctedEnd = `${mm}/${dd}/${yyyy}`;\n            console.log(`[DATE CORRECTION] End date adjusted to ${correctedEnd}`);\n        }\n    }\n    \n    return { startDate: correctedStart, endDate: correctedEnd };\n}\n\n// ============================================================================\n// üîß PARAMETER CLEANER\n// ============================================================================\n\nfunction cleanParams(params) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(params)) {\n        if (value !== null && value !== undefined && value !== '' && \n            value !== 'NULL' && value !== 'null' && value !== 'None' && \n            value !== 'none' && value !== 'N/A' && value !== 'n/a') {\n            cleaned[key] = value;\n        }\n    }\n    return cleaned;\n}\n\n// ============================================================================\n// üöÄ HTTP REQUEST ENGINE\n// ============================================================================\n\nasync function executeRequest() {\n    const toolName = 'schedule_appointment_ortho';\n    const action = $action;\n    const timeout = 60000; // Longer timeout for slot searches with retries\n    \n    console.log(`[${toolName}] v19 - 2026-01-01 - added comprehensive book_child slot field validation`);\n    console.log(`[${toolName}] Action: ${action}`);\n    \n    // Validate action\n    if (!action || !ACTIONS[action]) {\n        const validActions = Object.keys(ACTIONS).join(', ');\n        throw new Error(`Invalid action '${action}'. Valid actions: ${validActions}`);\n    }\n    \n    const config = ACTIONS[action];\n    \n    // Get UUI with fallback\n    let uui;\n    if (!$vars || !$vars.c1mg_uui || $vars.c1mg_uui === 'c1mg_uui' || (typeof $vars.c1mg_uui === 'string' && $vars.c1mg_uui.trim() === '')) {\n        uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';\n    } else {\n        uui = $vars.c1mg_uui;\n    }\n    \n    // Build params object from Flowise variables\n    const rawParams = {\n        startDate: typeof $startDate !== 'undefined' ? $startDate : null,\n        endDate: typeof $endDate !== 'undefined' ? $endDate : null,\n        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,\n        startTime: typeof $startTime !== 'undefined' ? $startTime : null,\n        scheduleViewGUID: typeof $scheduleViewGUID !== 'undefined' ? $scheduleViewGUID : null,\n        scheduleColumnGUID: typeof $scheduleColumnGUID !== 'undefined' ? $scheduleColumnGUID : null,\n        appointmentTypeGUID: typeof $appointmentTypeGUID !== 'undefined' ? $appointmentTypeGUID : null,\n        minutes: typeof $minutes !== 'undefined' ? $minutes : null,\n        providerGUID: typeof $providerGUID !== 'undefined' ? $providerGUID : null,\n        locationGUID: typeof $locationGUID !== 'undefined' ? $locationGUID : null,\n        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null,\n        childName: typeof $childName !== 'undefined' ? $childName : null\n    };\n    const params = cleanParams(rawParams);\n    \n    // Apply date correction for slot-related actions (past dates -> tomorrow)\n    if (action === 'slots' || action === 'grouped_slots') {\n        const corrected = correctDateRange(params.startDate, params.endDate);\n        if (corrected.startDate) params.startDate = corrected.startDate;\n        if (corrected.endDate) params.endDate = corrected.endDate;\n    }\n    \n    try {\n        // Validate required params for this action\n        config.validate(params);\n        \n        const body = config.buildBody(params, uui);\n        console.log(`[${toolName}] Endpoint: ${config.method} ${config.endpoint}`);\n        console.log(`[${toolName}] Request Body:`, JSON.stringify(body, null, 2));\n        \n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        \n        const authHeader = getAuthHeader();\n        if (authHeader) {\n            headers['Authorization'] = authHeader;\n        }\n        \n        const options = {\n            method: config.method,\n            headers: headers,\n            body: JSON.stringify(body)\n        };\n        \n        // Add timeout\n        let timeoutId;\n        if (typeof AbortController !== 'undefined') {\n            const controller = new AbortController();\n            timeoutId = setTimeout(() => controller.abort(), timeout);\n            options.signal = controller.signal;\n        }\n        \n        console.log(`[${toolName}] Making request to Node Red...`);\n        const response = await fetch(config.endpoint, options);\n        \n        if (timeoutId) clearTimeout(timeoutId);\n        \n        console.log(`[${toolName}] Response Status: ${response.status} ${response.statusText}`);\n        \n        let data;\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            data = await response.json();\n        } else {\n            data = await response.text();\n        }\n        \n        // Check HTTP status\n        if (!response.ok) {\n            console.error(`[${toolName}] HTTP Error ${response.status}:`, data);\n            let errorMsg = `HTTP ${response.status}: ${response.statusText}`;\n            if (data) {\n                const bodyError = checkForError(typeof data === 'string' ? (() => { try { return JSON.parse(data); } catch(e) { return data; } })() : data);\n                if (bodyError) errorMsg = bodyError;\n            }\n            throw new Error(errorMsg);\n        }\n        \n        // Parse response if string\n        let responseData = data;\n        if (typeof data === 'string') {\n            try { responseData = JSON.parse(data); } catch (e) { responseData = data; }\n        }\n        \n        // Check for error patterns in successful HTTP response\n        const errorMessage = checkForError(responseData);\n        if (errorMessage) {\n            console.error(`[${toolName}] API Error:`, responseData);\n            throw new Error(errorMessage);\n        }\n        \n        const successMsg = typeof config.successLog === 'function' ? config.successLog(responseData) : config.successLog;\n        console.log(`[${toolName}] ${successMsg}`);\n        \n        return JSON.stringify(responseData);\n        \n    } catch (error) {\n        console.error(`[${toolName}] Error:`, error.message);\n        \n        if (error.name === 'AbortError') {\n            error.message = `Request timeout after ${timeout}ms`;\n        }\n        \n        // Check if this is a timeout or network error\n        const isTimeout = ['timeout', 'aborted', 'ETIMEDOUT', 'ECONNRESET'].some(e =>\n            error.message.toLowerCase().includes(e.toLowerCase()));\n        \n        // Return graceful error response with LLM guidance\n        const errorResponse = {\n            success: false,\n            llm_guidance: {\n                timestamp: new Date().toISOString(),\n                error_type: isTimeout ? 'timeout' : 'api_error',\n                voice_response: \"I want to connect you with a specialist who can assist you. One moment while I transfer your call.\",\n                action_required: \"transfer_to_agent\",\n                transfer_reason: isTimeout ? \"scheduling_timeout\" : \"api_failure\",\n                CRITICAL: \"Do NOT mention error, timeout, or system problems to caller. Transfer gracefully.\",\n                prohibited_responses: [\n                    \"error\", \"timeout\", \"problem\", \"issue\", \"failed\",\n                    \"system is down\", \"technical difficulties\", \"something went wrong\"\n                ]\n            }\n        };\n        \n        return JSON.stringify(errorResponse);\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}