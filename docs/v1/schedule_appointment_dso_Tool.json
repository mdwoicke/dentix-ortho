{
  "name": "schedule_appointment_ortho",
  "description": "Appointment scheduling (v91 ATOMIC model). Actions: slots, grouped_slots, book_child, cancel.\n\nslots: Get available times for 1 child. Returns slots with displayTime.\n\ngrouped_slots: For siblings (2+ children). MUST pass numberOfPatients matching the number of children (e.g. '2' for 2 siblings). Returns grouped consecutive slots.\n\nbook_child: Book appointment. REQUIRES parentFirstName, parentLastName, parentPhone, and children array with slot details. Node-RED creates all patients and books all appointments in one atomic call. Do NOT create patients separately.\n\ncancel: Cancel using appointmentGUID.",
  "color": "linear-gradient(rgb(119,46,188), rgb(11,231,3))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"The action: slots, grouped_slots, book_child, cancel\",\"required\":true},{\"id\":1,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"Start date MM/DD/YYYY (for slots)\",\"required\":false},{\"id\":2,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"End date MM/DD/YYYY (for slots)\",\"required\":false},{\"id\":3,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"Filter by schedule views (for slots)\",\"required\":false},{\"id\":4,\"property\":\"numberOfPatients\",\"type\":\"string\",\"description\":\"REQUIRED for grouped_slots: number of children to book (e.g. '2' for siblings). Must match actual child count. Pass as string.\",\"required\":false},{\"id\":5,\"property\":\"timeWindowMinutes\",\"type\":\"string\",\"description\":\"Time window in minutes for grouped_slots (default 40). Pass as string.\",\"required\":false},{\"id\":6,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"Legacy mode only: CHILD's own patientGUID from chord_ortho_patient create. Not needed for atomic mode (when parentFirstName is provided).\",\"required\":false},{\"id\":7,\"property\":\"startTime\",\"type\":\"string\",\"description\":\"Appointment start time MM/DD/YYYY HH:MM:SS AM/PM (for book_child single legacy mode)\",\"required\":false},{\"id\":8,\"property\":\"scheduleViewGUID\",\"type\":\"string\",\"description\":\"Schedule view GUID (for book_child single legacy mode)\",\"required\":false},{\"id\":9,\"property\":\"scheduleColumnGUID\",\"type\":\"string\",\"description\":\"Schedule column GUID (for book_child)\",\"required\":false},{\"id\":10,\"property\":\"appointmentTypeGUID\",\"type\":\"string\",\"description\":\"Appointment type GUID (for book_child)\",\"required\":false},{\"id\":11,\"property\":\"minutes\",\"type\":\"string\",\"description\":\"Appointment duration in minutes (for book_child, default 40). Pass as string.\",\"required\":false},{\"id\":12,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"Appointment GUID (for cancel)\",\"required\":false},{\"id\":13,\"property\":\"childName\",\"type\":\"string\",\"description\":\"Child full name - legacy mode only (for book_child)\",\"required\":false},{\"id\":14,\"property\":\"childDOB\",\"type\":\"string\",\"description\":\"Child date of birth MM/DD/YYYY - legacy mode only (for book_child)\",\"required\":false},{\"id\":15,\"property\":\"insuranceProvider\",\"type\":\"string\",\"description\":\"Insurance provider name (for book_child)\",\"required\":false},{\"id\":16,\"property\":\"groupID\",\"type\":\"string\",\"description\":\"Insurance group ID (for book_child)\",\"required\":false},{\"id\":17,\"property\":\"memberID\",\"type\":\"string\",\"description\":\"Insurance member ID (for book_child)\",\"required\":false},{\"id\":18,\"property\":\"bookingAuthToken\",\"type\":\"string\",\"description\":\"Legacy mode only: Authorization token from chord_ortho_patient create. Not needed for atomic mode.\",\"required\":false},{\"id\":19,\"property\":\"children\",\"type\":\"string\",\"description\":\"REQUIRED for book_child. Pass as a JSON STRING (use JSON.stringify). ATOMIC MODE (with parentFirstName): each child object has firstName, lastName, dob, startTime, scheduleViewGUID, scheduleColumnGUID. Example: '[{\\\"firstName\\\":\\\"Emma\\\",\\\"dob\\\":\\\"05/15/2018\\\",\\\"startTime\\\":\\\"3/18/2026 2:00:00 PM\\\",\\\"scheduleViewGUID\\\":\\\"abc-123\\\",\\\"scheduleColumnGUID\\\":\\\"def-456\\\"}]'\",\"required\":false},{\"id\":20,\"property\":\"parentFirstName\",\"type\":\"string\",\"description\":\"Parent first name. TRIGGERS ATOMIC MODE: Node-RED creates parent + children + books all appointments in one call. No separate create calls needed.\",\"required\":false},{\"id\":21,\"property\":\"parentLastName\",\"type\":\"string\",\"description\":\"Parent last name (for atomic book_child)\",\"required\":false},{\"id\":22,\"property\":\"parentPhone\",\"type\":\"string\",\"description\":\"Parent phone number (for atomic book_child)\",\"required\":false},{\"id\":23,\"property\":\"parentEmail\",\"type\":\"string\",\"description\":\"Parent email address (optional, for atomic book_child)\",\"required\":false},{\"id\":24,\"property\":\"parentDOB\",\"type\":\"string\",\"description\":\"Parent date of birth MM/DD/YYYY (optional, for atomic book_child)\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING DSO - Appointment Scheduling Tool (Node Red Version)\n * Version: v92 | Updated: 2026-02-25\n * ============================================================================\n * Actions: slots, grouped_slots, book_child, cancel\n *\n * v92: BOOKING RESPONSE VALIDATION - Validate book_child returns real Cloud9 GUIDs\n *      - After bookConsultation returns, verify each child has a real appointmentGUID (8-4-4-4-12 hex)\n *      - If any child is missing a real GUID, override success=false with llm_guidance.CRITICAL\n *      - Add _booking_verified flag so downstream consumers can trust the response\n *      - Prevents LLM from confirming a booking when the API did not actually create one\n *\n * v91: FIX numberOfPatients FLOWISE BUG - Change schema type from integer to string\n *      - Flowise drops integer-typed params as undefined causing cleanParams to strip them\n *      - Schema now types numberOfPatients and timeWindowMinutes as string\n *      - parseInt() already handles string to number conversion in tool code\n *      - ROOT CAUSE of sibling booking failures (Ted Test session 8e82e784)\n *\n * v89: FIX CRITICAL SIBLING BOOKING BUG - Remove v80 redirect + fix numberOfPatients\n *      - REMOVED v80 redirect that sent grouped_slots to getApptSlots (wrong endpoint!)\n *      - Flowise integer schema params may arrive as undefined - now defaults numberOfPatients=2\n *      - Derive numberOfPatients from children array length as backup\n *      - INSUFFICIENT mode: warn LLM when fewer slots than children found\n *      - Added endpoint logging to trace which Node-RED URL is actually called\n *\n * v88: BULLETPROOF slot-to-child mapping (still active)\n *      - Consecutive mode: data.slots = groups[0].slots (exactly N for N children)\n *      - Individual mode: data.slots = first N slots\n *      - Top-level booking_plan maps child_number → slot\n *\n * v87: SIMPLIFY for Node-RED v22 - grouped_slots now always returns 'slots' array\n *      - hasResults now true when grouped_slots returns slots (not just groups)\n *      - Removed v86 recursive fallback (no longer needed - Node-RED handles it)\n *      - Removed v82 bestIndividualSlots tracking (dead code)\n *      - Booking plan comes directly from Node-RED response\n *\n * v86: FIX GROUPED_SLOTS FALLBACK - Node-RED returns no 'slots' field, so v82 was dead code\n *      - When grouped_slots has 0 groups, now calls regular 'slots' endpoint as fallback\n *      - Returns individual slots so LLM can book children at separate times\n *      - MAX_SLOTS_RETURNED exemption: grouped_slots fallback needs >=numberOfPatients slots\n *      - Fixes the #1 sibling booking failure where 0 groups led to immediate transfer\n *\n  * v85: ENFORCE UNIQUE SLOTS PER CHILD - Server-side duplicate slot rejection\n *      - book_child.validate() checks each child has unique startTime+scheduleColumnGUID\n *      - Atomic bookConsultation path also validates unique slots before calling Node-RED\n *      - Prevents the #1 sibling booking failure: both children assigned same slot\n *\n * v84: PRESERVE BOOKING_PLAN - Stop overwriting Node-RED's child→slot mapping\n *      - Save booking_plan and SLOT_USAGE_RULE before guidance override\n *      - Merge them back into standard guidance so LLM sees explicit slot assignments\n *      - Added \"each child MUST use DIFFERENT startTime\" to BOOKING_SEQUENCE_MANDATORY\n *\n * v78: FIX CHILDREN PARSING - Handle both string and array input from Flowise\n *      - Flowise schema types children as \"string\" but LLM may send native array\n *      - Tool now parses $children whether it arrives as JSON string or array\n *      - Fixes \"Received tool input did not match expected schema\" error\n *\n * v76: ATOMIC BOOK CONSULTATION - book_child expanded for atomic create+book\n *      - When parentFirstName is present, routes to /ortho-prd/bookConsultation\n *      - Node-RED creates parent + children + books all appointments in one call\n *      - LLM makes exactly 2 tool calls: (1) slots/grouped_slots, (2) book_child with parent+children info\n *      - Eliminates duplicate patient bug (LLM can't call create twice)\n *      - Eliminates skipped booking bug (booking is inside same call as creation)\n *      - Backward compatible: without parentFirstName, existing behavior unchanged\n *\n * v75: BULLETPROOF SIBLING BOOKING - Time window set to 40 minutes (matches appointment spacing)\n *      - Exactly matches 40-minute appointment slot spacing\n *      - Works with Node-RED v17 which maintains Chair 8 filter requirement\n *      - Enables successful booking for 2+ children at all locations\n *\n * v73: PENDING RESPONSE SUPPORT - Handle getApptSlots v9 cold cache timeout\n *      - Added _pending response handling in searchSlotsWithExpansion\n *      - When Node-RED returns _pending (cache cold, quick-sync timed out), return guidance to retry\n *      - Prevents LLM from treating pending as \"no slots\"\n *      - Works with Node-RED getApptSlots v9 (Bulletproof)\n *\n * v72: FIX - Each child uses their OWN bookingAuthToken from child create (not parent's)\n *      - Updated LLM guidance in BOOKING_SEQUENCE_MANDATORY, error messages, sibling_workflow\n *      - Works with patient tool v12 which clarifies child token generation\n *\n * v71: ENFORCE PER-CHILD PATIENTGUID + REQUIRE bookingAuthToken\n *      - book_child.validate now REQUIRES bookingAuthToken (forces create-before-book sequence)\n *      - Per-child patientGUID validation in children array (each child must have own GUID)\n *      - Missing bookingAuthToken returns BOOKING_AUTH_REQUIRED with step-by-step guidance\n *\n * v69: ENHANCED SESSION ID FALLBACK LOGGING\n *      - Added explicit WARNING when using uui as sessionId fallback\n *      - Logs guidance on how to fix ($flow.sessionId should be populated by Flowise)\n *      - Helps diagnose why cross-session reservation filtering may be ineffective\n *\n * v68: CROSS-SESSION SLOT RESERVATION - Pass sessionId for reservation filtering\n *      - grouped_slots now passes sessionId to Node-RED\n *      - Node-RED filters out slots reserved by other sessions\n *      - book_child already passes sessionId for reservation creation\n *      - Prevents race condition where 2 callers book same slot\n *\n * v67: REMOVED DIRECT REDIS CACHE READ - All requests go through Node-RED\n *      - FIXED: v66 read Redis cache directly, bypassing Node-RED's cache logic\n *      - Node-RED handles caching internally with correct data structure handling\n *      - Tool now ALWAYS calls Node-RED endpoints (getApptSlots, getGroupedApptSlots)\n *      - This ensures consistent cache interpretation and slot grouping\n *\n * v66: (REVERTED) REDIS SLOT CACHE - Direct cache read caused empty slot responses\n *\n * v65: EXPANDED DATE SEARCH TIERS - Search up to 90 days (3 months)\n *      - Changed tiers from [14, 28, 56] to [30, 60, 90]\n *      - Fixes transfer issue when no slots in first 8 weeks but available at 9-12 weeks\n *\n * v64: FLOW CONTEXT FALLBACK - Extract childName from $flow.input if not passed\n *      - Tool now logs $flow context for debugging\n *      - If LLM doesn't pass $childName, tool attempts to extract from $flow.input\n *      - $flow.input may contain PAYLOAD with children array from conversation\n *      - This prevents missing childName when LLM forgets to pass it\n *\n * v63: CHILDREN ARRAY SUPPORT - Book all children in a single call\n *      - book_child now accepts a 'children' array parameter\n *      - Each child object contains: childName, childDOB, startTime, slot details\n *      - Node-RED loops through and creates all appointments atomically\n *      - Uses same rate limiting safeguards (2 retries + async queue fallback)\n *      - Prevents LLM from \"forgetting\" to book additional children\n *\n * v60: DISABLED PRE-BOOKING VERIFICATION (Rate Limiting Fix)\n *      - REMOVED v59 slot verification because it triggered API rate limiting\n *      - The verification called getApptSlots AGAIN before each book_child\n *      - After grouped_slots, subsequent API calls returned 0 slots (rate limited)\n *      - This caused \"slot not available\" errors even when slots WERE available\n *      - Node-RED handles validation server-side as fallback\n *\n * v59: BULLETPROOF SLOT VALIDATION (DISABLED - caused rate limiting failures)\n *      - book_child verified slot exists before booking via real-time API call\n *      - Validates ALL parameters but triggers rate limiting after grouped_slots\n *\n * v57: SERVER-SIDE AUTH VALIDATION (Tool Pass-Through)\n *      - REMOVED tool-level bookingAuthToken validation (was breaking LLM parallelism)\n *      - Tool now passes through to Node-RED, which handles session-based fallback\n *      - Node-RED auto-injects token from session cache if missing\n *      - This allows LLM to call create + book_child in any order\n *\n * v55: BOOKING AUTHORIZATION TOKEN\n *      - book_child now accepts bookingAuthToken parameter\n *      - Token is generated by chord_ortho_patient create and MUST be passed here\n *      - Prevents parallel tool call collisions (LLM using stale/hallucinated GUIDs)\n *      - Node-RED validates token and rejects mismatched patientGUIDs\n *\n * v54: PARENT-AS-PATIENT MODEL\n *      - Parent is the patient record, child info stored in appointment note\n *      - book_child now accepts childName, childDOB for the note field\n *      - SAME patientGUID is reused for ALL siblings\n *      - Note format: \"Child: [name] | DOB: [date] | Insurance: [provider]\"\n *      - Updated BOOKING_SEQUENCE_MANDATORY for parent-as-patient workflow\n *\n * v53 FIX: BOOKING SEQUENCE GUIDANCE - Add explicit llm_guidance to slots response\n * v52 FIX: INDIVIDUAL GUIDs FOR BOOKING - Accept individual params for book_child\n * v51 FIX: FUTURE DATE VALIDATION - Auto-correct dates too far in the future\n * v50 FIX: DYNAMIC SLOT SEARCH - Progressive date expansion when no slots found\n * v49 FIX: STRIP GUIDs FROM SLOTS RESPONSE\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\nconst TOOL_VERSION = 'v92';\nconst MAX_SLOTS_RETURNED = 1;\nconst BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord';\nconst DEFAULT_SCHEDULE_COLUMN_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\nconst SANDBOX_MIN_DATE = new Date(2026, 0, 13);\n\n// v50: Progressive date expansion tiers (in days)\n// v65: Expanded to 30/60/90 days for better slot coverage\nconst DATE_EXPANSION_TIERS = [30, 60, 90]; // 1 month, 2 months, 3 months\nconst MIN_DATE_RANGE_DAYS = 30; // Minimum range to prevent single-day searches\n// v51: Maximum days in the future to accept (prevents LLM hallucinated dates)\nconst MAX_FUTURE_DAYS = 90; // ~3 months - anything beyond this is likely an error\n\nfunction encodeBookingToken(slot) {\n    const data = {\n        st: slot.startTime,\n        sv: slot.scheduleViewGUID,\n        sc: slot.scheduleColumnGUID,\n        at: slot.appointmentTypeGUID,\n        mn: slot.minutes\n    };\n    return Buffer.from(JSON.stringify(data)).toString('base64');\n}\n\nfunction decodeBookingToken(token) {\n    try {\n        const data = JSON.parse(Buffer.from(token, 'base64').toString('utf8'));\n        return {\n            startTime: data.st,\n            scheduleViewGUID: data.sv,\n            scheduleColumnGUID: data.sc,\n            appointmentTypeGUID: data.at,\n            minutes: data.mn\n        };\n    } catch (e) {\n        console.error('[decodeBookingToken] Failed to decode:', e.message);\n        return null;\n    }\n}\n\n// v52: Return individual GUIDs in slots response for direct booking\nfunction formatSlotsResponse(data) {\n    if (data && data.slots && Array.isArray(data.slots)) {\n        data.slots = data.slots.map(slot => ({\n            displayTime: slot.startTime || slot.StartTime,\n            startTime: slot.startTime || slot.StartTime,\n            scheduleViewGUID: slot.scheduleViewGUID,\n            scheduleColumnGUID: slot.scheduleColumnGUID,\n            appointmentTypeGUID: slot.appointmentTypeGUID,\n            minutes: slot.minutes\n        }));\n    }\n    if (data && data.groups && Array.isArray(data.groups)) {\n        data.groups = data.groups.map(group => ({\n            groupTime: group.slots && group.slots[0] ? (group.slots[0].startTime || group.slots[0].StartTime) : null,\n            slots: group.slots ? group.slots.map(slot => ({\n                displayTime: slot.startTime || slot.StartTime,\n                startTime: slot.startTime || slot.StartTime,\n                scheduleViewGUID: slot.scheduleViewGUID,\n                scheduleColumnGUID: slot.scheduleColumnGUID,\n                appointmentTypeGUID: slot.appointmentTypeGUID,\n                minutes: slot.minutes\n            })) : []\n        }));\n    }\n    delete data.voiceSlots;\n    return data;\n}\n\nconst ACTIONS = {\n    slots: {\n        endpoint: `${BASE_URL}/ortho-prd/getApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui, sessionId) => {\n            const body = {\n                uui: uui,\n                startDate: params.startDate,\n                endDate: params.endDate,\n                // v68: Pass sessionId for cross-session reservation filtering\n                sessionId: sessionId\n            };\n            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.count || (data.slots ? data.slots.length : 0) || 0} available slots`\n    },\n    grouped_slots: {\n        endpoint: `${BASE_URL}/ortho-prd/getGroupedApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui, sessionId) => {\n            const body = {\n                uui: uui,\n                startDate: params.startDate,\n                endDate: params.endDate,\n                numberOfPatients: params.numberOfPatients || 1,  // v90: Default to 1, dynamically set upstream\n                timeWindowMinutes: params.timeWindowMinutes || 40,  // v75: Set to 40 to match appointment spacing for 40-min appointment spacing\n                // v68: Pass sessionId for cross-session reservation filtering\n                sessionId: sessionId\n            };\n            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.totalGroups || (data.groups ? data.groups.length : 0) || 0} grouped slot options`\n    },\n    book_child: {\n        endpoint: `${BASE_URL}/ortho-prd/createAppt`,\n        method: 'POST',\n        buildBody: (params, uui, sessionId) => {\n            // v63: CHILDREN ARRAY SUPPORT - Pass all children to Node-RED for atomic booking\n            console.log('[book_child v63] Children array support, params:', JSON.stringify(params));\n\n            const body = {\n                uui: uui,\n                patientGUID: params.patientGUID,  // v71: Child's own GUID (INDIVIDUAL_PATIENT_PER_PERSON) or parent GUID (legacy batch)\n                // v55: Booking auth token - validates patientGUID came from create response\n                bookingAuthToken: params.bookingAuthToken,\n                // v68: Pass sessionId for cross-session slot reservation\n                sessionId: sessionId\n            };\n\n            // v63/v71: If children array provided, pass it through for batch booking\n            // v71: Each child now has their own patientGUID (INDIVIDUAL_PATIENT_PER_PERSON)\n            if (params.children && Array.isArray(params.children) && params.children.length > 0) {\n                console.log('[book_child v71] Batch booking ' + params.children.length + ' children (INDIVIDUAL_PATIENT_PER_PERSON)');\n                body.children = params.children.map(child => {\n                    // Build note for each child\n                    let note = '';\n                    if (child.childName) {\n                        note = 'Child: ' + child.childName;\n                        if (child.childDOB) note += ' | DOB: ' + child.childDOB;\n                        if (child.insuranceProvider) note += ' | Insurance: ' + child.insuranceProvider;\n                        if (child.groupID) note += ' | GroupID: ' + child.groupID;\n                        if (child.memberID) note += ' | MemberID: ' + child.memberID;\n                    }\n                    return {\n                        // v71: Each child has their own patientGUID\n                        patientGUID: child.patientGUID,\n                        childName: child.childName,\n                        childDOB: child.childDOB,\n                        startTime: child.startTime,\n                        scheduleViewGUID: child.scheduleViewGUID,\n                        scheduleColumnGUID: child.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID,\n                        appointmentTypeGUID: child.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n                        minutes: child.minutes || 40,\n                        note: note\n                    };\n                });\n            } else {\n                // v54: Single child backward compatibility\n                let note = '';\n                if (params.childName) {\n                    note = 'Child: ' + params.childName;\n                    if (params.childDOB) note += ' | DOB: ' + params.childDOB;\n                    if (params.insuranceProvider) note += ' | Insurance: ' + params.insuranceProvider;\n                    if (params.groupID) note += ' | GroupID: ' + params.groupID;\n                    if (params.memberID) note += ' | MemberID: ' + params.memberID;\n                }\n                body.startTime = params.startTime;\n                body.scheduleViewGUID = params.scheduleViewGUID;\n                body.scheduleColumnGUID = params.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID;\n                body.appointmentTypeGUID = params.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705';\n                body.minutes = params.minutes || 40;\n                body.childName = params.childName;\n                if (note) body.note = note;\n            }\n\n            return body;\n        },\n        validate: (params) => {\n            // v71: patientGUID is now the CHILD's GUID (INDIVIDUAL_PATIENT_PER_PERSON model)\n            if (!params.patientGUID) throw new Error('BOOKING FAILED - Missing patientGUID (child GUID from create response)');\n            // v71: Require bookingAuthToken to force create-before-book sequence\n            if (!params.bookingAuthToken) {\n                throw new Error(JSON.stringify({\n                    success: false,\n                    error: 'BOOKING_AUTH_REQUIRED',\n                    llm_guidance: {\n                        error_type: 'missing_booking_token',\n                        action_required: 'create_patient_first',\n                        CRITICAL: 'You must call chord_ortho_patient action=create for each child FIRST. Each child gets their own patientGUID AND bookingAuthToken. Use BOTH values from the child create response.',\n                        steps: [\n                            '1. chord_ortho_patient action=create, isChild=true, parentPatientGUID, familyId -> returns child patientGUID + child bookingAuthToken',\n                            '2. book_child with child patientGUID + child bookingAuthToken (NOT parent token)'\n                        ]\n                    }\n                }));\n            }\n            // v63/v71: Either children array OR single child params required\n            if (params.children && Array.isArray(params.children) && params.children.length > 0) {\n                const usedSlots = new Set(); // v85: Track used slot keys\n                // Validate each child has required fields\n                for (let i = 0; i < params.children.length; i++) {\n                    const child = params.children[i];\n                    if (!child.startTime) throw new Error('BOOKING FAILED - Child ' + (i+1) + ' missing startTime');\n                    if (!child.scheduleViewGUID) throw new Error('BOOKING FAILED - Child ' + (i+1) + ' missing scheduleViewGUID');\n                    // v71: Require per-child patientGUID\n                    if (!child.patientGUID) throw new Error('BOOKING FAILED - Child ' + (i+1) + ' missing patientGUID. Each child must have their own patientGUID from chord_ortho_patient create.');\n                    if (!child.childName) console.log('[book_child v71] WARNING: Child ' + (i+1) + ' has no childName');\n                    // v85: ENFORCE UNIQUE SLOTS\n                    const slotKey = (child.startTime || '').trim().toLowerCase() + '|' + (child.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID).toLowerCase();\n                    if (usedSlots.has(slotKey)) {\n                        console.error('[v85] DUPLICATE SLOT DETECTED: Child ' + (i+1) + ' has same slot as another child: ' + child.startTime);\n                        throw new Error(JSON.stringify({\n                            success: false,\n                            error: 'DUPLICATE_SLOT_ASSIGNMENT',\n                            llm_guidance: {\n                                error_type: 'duplicate_slot',\n                                voice_response: 'Let me find a separate appointment time for your other child.',\n                                action_required: 'use_different_slots_per_child',\n                                CRITICAL: 'v85: EACH child MUST have a DIFFERENT startTime. You assigned the same slot (' + child.startTime + ') to multiple children. Look at the booking_plan from grouped_slots - Child 1 uses slot 1, Child 2 uses slot 2. Call grouped_slots again if you lost the slot assignments.',\n                                duplicate_startTime: child.startTime,\n                                child_index: i + 1,\n                                fix: 'Re-read the booking_plan from the grouped_slots response. Each child has a unique startTime assigned. Use those exact values.'\n                            }\n                        }));\n                    }\n                    usedSlots.add(slotKey);\n                }\n            } else {\n                // Single child validation\n                if (!params.startTime) throw new Error('BOOKING FAILED - Missing startTime');\n                if (!params.scheduleViewGUID) throw new Error('BOOKING FAILED - Missing scheduleViewGUID');\n                if (!params.childName) console.log('[book_child v71] WARNING: No childName provided');\n            }\n        },\n        successLog: (data) => data.results ? 'Booked ' + data.results.length + ' appointments' : 'Appointment booked successfully'\n    },\n    cancel: {\n        endpoint: `${BASE_URL}/ortho-prd/cancelAppt`,\n        method: 'POST',\n        buildBody: (params, uui, sessionId) => ({ uui: uui, appointmentGUID: params.appointmentGUID, sessionId: sessionId }),\n        validate: (params) => { if (!params.appointmentGUID) throw new Error(\"appointmentGUID required\"); },\n        successLog: () => 'Appointment cancelled successfully'\n    }\n};\n\nfunction getAuthHeader() {\n    try {\n        const credentials = Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n        return `Basic ${credentials}`;\n    } catch (e) { return null; }\n}\n\n// v92: Validate Cloud9 GUID format (8-4-4-4-12 hexadecimal)\nconst CLOUD9_GUID_REGEX = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;\nfunction isRealAppointmentGUID(id) {\n    return id && typeof id === 'string' && CLOUD9_GUID_REGEX.test(id);\n}\n\nfunction checkForError(data) {\n    if (!data || typeof data !== 'object') return null;\n    if (data.success === false && !data.llm_guidance) return data.error || data.message || 'Operation failed';\n    if (data.code === false) return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    if (data.error && !data.slots && !data.groups && !data.appointmentGUID && !data.llm_guidance) {\n        return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    }\n    if (data.message && data.message.toLowerCase().includes('error') && !data.appointmentGUID) return data.message;\n    return null;\n}\n\nfunction formatDate(date) {\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    return `${mm}/${dd}/${date.getFullYear()}`;\n}\n\nfunction parseDate(dateStr) {\n    if (!dateStr) return null;\n    const parts = dateStr.split('/');\n    if (parts.length !== 3) return null;\n    return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n}\n\n// v51: Enhanced date range correction with future date validation\nfunction correctDateRange(startDate, endDate, expansionDays = DATE_EXPANSION_TIERS[0]) {\n    let correctedStart = startDate ? parseDate(startDate) : null;\n    let correctedEnd = endDate ? parseDate(endDate) : null;\n    const today = new Date(); today.setHours(0, 0, 0, 0);\n    let datesCorrected = false;\n    let originalStart = startDate;\n    let originalEnd = endDate;\n    \n    // v51: Check if dates are too far in the future (LLM hallucination detection)\n    const maxFutureDate = new Date(today);\n    maxFutureDate.setDate(maxFutureDate.getDate() + MAX_FUTURE_DAYS);\n    \n    if (correctedStart && correctedStart > maxFutureDate) {\n        console.log('[v51] WARNING: startDate ' + startDate + ' is ' + Math.ceil((correctedStart - today) / (1000 * 60 * 60 * 24)) + ' days in future - AUTO-CORRECTING to today');\n        correctedStart = null; // Will be set to today below\n        datesCorrected = true;\n    }\n    if (correctedEnd && correctedEnd > maxFutureDate) {\n        console.log('[v51] WARNING: endDate ' + endDate + ' is too far in future - will be recalculated');\n        correctedEnd = null; // Will be recalculated below\n        datesCorrected = true;\n    }\n    \n    // Fix dates in the past or missing\n    if (!correctedStart || correctedStart < today) {\n        correctedStart = new Date(Math.max(today.getTime(), SANDBOX_MIN_DATE.getTime()));\n    }\n    if (correctedStart < SANDBOX_MIN_DATE) correctedStart = new Date(SANDBOX_MIN_DATE);\n    \n    // v50: Calculate days between dates\n    let daysDiff = 0;\n    if (correctedEnd && correctedEnd > correctedStart) {\n        daysDiff = Math.ceil((correctedEnd - correctedStart) / (1000 * 60 * 60 * 24));\n    }\n    \n    // v50: Enforce minimum range AND use expansion tier\n    if (!correctedEnd || correctedEnd <= correctedStart || daysDiff < MIN_DATE_RANGE_DAYS) {\n        correctedEnd = new Date(correctedStart);\n        correctedEnd.setDate(correctedEnd.getDate() + expansionDays);\n    }\n    \n    // v51: Log when dates were auto-corrected\n    if (datesCorrected) {\n        console.log('[v51] Date auto-correction: original=' + originalStart + ' to ' + originalEnd + ' -> corrected=' + formatDate(correctedStart) + ' to ' + formatDate(correctedEnd));\n    }\n    \n    return { startDate: formatDate(correctedStart), endDate: formatDate(correctedEnd), expansionDays: expansionDays, datesCorrected: datesCorrected };\n}\n\nfunction cleanParams(params) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(params)) {\n        if (value !== null && value !== undefined && value !== '' && value !== 'NULL' && value !== 'null' && value !== 'None') {\n            cleaned[key] = value;\n        }\n    }\n    return cleaned;\n}\n\n// v59: BULLETPROOF SLOT VALIDATION - Verify slot exists with ALL parameters before booking\nasync function verifySlotAvailability(params, headers) {\n    console.log('[v59] Verifying slot availability before booking...');\n    const startTime = params.startTime;\n    if (!startTime) return { valid: false, reason: 'missing_startTime' };\n    const dateMatch = startTime.match(/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/);\n    if (!dateMatch) return { valid: false, reason: 'invalid_startTime_format' };\n    const slotDate = dateMatch[0];\n    console.log('[v59] Checking real-time availability for date: ' + slotDate);\n    try {\n        const response = await fetch(BASE_URL + '/ortho-prd/getApptSlots', {\n            method: 'POST', headers: headers,\n            body: JSON.stringify({ uui: params.uui || 'verify-' + Date.now(), startDate: slotDate, endDate: slotDate, duration: params.minutes || 40 })\n        });\n        const data = JSON.parse(await response.text());\n        if (!response.ok || !data || !data.slots) return { valid: true, reason: 'verification_skipped' };\n        console.log('[v59] Found ' + data.slots.length + ' slots on ' + slotDate);\n        const normalizeTime = t => (t || '').toLowerCase().replace(/\\s+/g, ' ').trim();\n        const normalizeGUID = g => (g || '').toLowerCase().trim();\n        const reqTime = normalizeTime(params.startTime);\n        const reqChair = normalizeGUID(params.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID);\n        const reqView = normalizeGUID(params.scheduleViewGUID);\n        const reqApptType = normalizeGUID(params.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705');\n        const reqMinutes = parseInt(params.minutes || 40);\n        console.log('[v59] Looking for: time=' + reqTime + ' chair=' + reqChair + ' min=' + reqMinutes);\n        const match = data.slots.find(s => {\n            const sTime = normalizeTime(s.startTime || s.StartTime);\n            const sChair = normalizeGUID(s.scheduleColumnGUID || s.ScheduleColumnGUID);\n            const sView = normalizeGUID(s.scheduleViewGUID || s.ScheduleViewGUID);\n            const sApptType = normalizeGUID(s.appointmentTypeGUID || s.AppointmentTypeGUID);\n            const sMin = parseInt(s.minutes || s.Minutes || 40);\n            if (sTime === reqTime) console.log('[v59] Time match! Chair:' + (sChair===reqChair) + ' View:' + (!reqView||sView===reqView) + ' Type:' + (sApptType===reqApptType) + ' Min:' + (sMin===reqMinutes));\n            return sTime === reqTime && sChair === reqChair && (!reqView || sView === reqView) && sApptType === reqApptType && sMin === reqMinutes;\n        });\n        if (match) { console.log('[v59] SLOT VERIFIED'); return { valid: true, reason: 'verified', slot: match }; }\n        console.log('[v59] SLOT NOT FOUND in current availability');\n        return { valid: false, reason: 'slot_not_available', freshSlots: data.slots.slice(0, 5).map(s => ({ startTime: s.startTime || s.StartTime, scheduleViewGUID: s.scheduleViewGUID, scheduleColumnGUID: s.scheduleColumnGUID, appointmentTypeGUID: s.appointmentTypeGUID, minutes: s.minutes || 40 })) };\n    } catch (e) { console.log('[v59] Verification error: ' + e.message); return { valid: true, reason: 'verification_skipped_error' }; }\n}\n\n// v50: Dynamic slot search with progressive expansion\n// v68: Added sessionId parameter for cross-session reservation filtering\nasync function searchSlotsWithExpansion(action, params, uui, headers, sessionId) {\n    const config = ACTIONS[action];\n    let lastError = null;\n    let searchExpanded = false;\n    let finalExpansionDays = DATE_EXPANSION_TIERS[0];\n            // v87: bestIndividualSlots removed - Node-RED v22 handles individual slot fallback natively\n\n\n    for (let tierIndex = 0; tierIndex < DATE_EXPANSION_TIERS.length; tierIndex++) {\n        const expansionDays = DATE_EXPANSION_TIERS[tierIndex];\n        const corrected = correctDateRange(params.startDate, params.endDate, expansionDays);\n\n        const searchParams = { ...params, startDate: corrected.startDate, endDate: corrected.endDate };\n        const body = config.buildBody(searchParams, uui, sessionId);\n        \n        console.log('[v50] Tier ' + tierIndex + ' search: ' + corrected.startDate + ' to ' + corrected.endDate + ' (' + expansionDays + ' days)');\n\n        try {\n            const response = await fetch(config.endpoint, { method: config.method, headers: headers, body: JSON.stringify(body) });\n            const responseText = await response.text();\n            let data;\n            try { data = JSON.parse(responseText); } catch (e) { data = responseText; }\n\n            if (!response.ok) {\n                lastError = 'HTTP ' + response.status + ': ' + response.statusText;\n                continue;\n            }\n\n            const errorMessage = checkForError(data);\n            if (errorMessage) {\n                lastError = errorMessage;\n                continue;\n            }\n\n            // v73: Check for pending response from getApptSlots v9 (cold cache timeout)\n            if (data._pending) {\n                console.log('[v73] Node-RED returned _pending - cache cold, quick-sync timed out');\n                return {\n                    success: false,\n                    _pending: true,\n                    data: {\n                        slots: [],\n                        groups: [],\n                        count: 0,\n                        _pending: true,\n                        _toolVersion: TOOL_VERSION,\n                        llm_guidance: data.llm_guidance || {\n                            action_required: 'inform_caller_and_retry',\n                            voice_response: 'Let me check on that availability. One moment please.',\n                            retry_after_ms: 10000,\n                            CRITICAL: 'v73: Slots being fetched in background. Retry request in 10 seconds. If still pending after 2 retries, offer transfer.'\n                        }\n                    }\n                };\n            }\n\n            const hasGroups = data.groups && data.groups.length > 0;\n            const hasSlots = data.slots && data.slots.length > 0;\n            // v87: grouped_slots v22 now ALWAYS returns slots array alongside groups\n            // Success when we have groups OR individual slots (for either action)\n            const hasResults = hasSlots || hasGroups;\n\n            if (hasResults) {\n                // v50: Add metadata about the search\n                data._searchExpanded = tierIndex > 0;\n                data._expansionTier = tierIndex;\n                data._dateRange = { start: corrected.startDate, end: corrected.endDate, days: expansionDays };\n                if (tierIndex > 0) {\n                    console.log('[v50] Found slots after expanding to tier ' + tierIndex + ' (' + expansionDays + ' days)');\n                }\n                return { success: true, data: data };\n            }\n\n            // v87: No fallback tracking needed - Node-RED v22 always returns slots alongside groups\n            \n            // No results, try next tier\n            searchExpanded = true;\n            finalExpansionDays = expansionDays;\n            console.log('[v50] No slots found at tier ' + tierIndex + ', expanding...');\n            \n        } catch (e) {\n            lastError = e.message;\n            console.log('[v50] Search error at tier ' + tierIndex + ': ' + e.message);\n        }\n    }\n    \n    // v87: No fallback needed - Node-RED v22 returns individual slots in the response\n\n    // v50: All tiers exhausted, truly no slots found\n    console.log('[v50] All expansion tiers exhausted, no slots found. lastError=' + lastError);\n    return {\n        success: false,\n        data: {\n            slots: [],\n            groups: [],\n            count: 0,\n            totalGroups: 0,\n            _toolVersion: TOOL_VERSION,\n            _searchExpanded: searchExpanded,\n            _expansionTier: DATE_EXPANSION_TIERS.length - 1,\n            _dateRange: { days: finalExpansionDays },\n            llm_guidance: {\n                error_type: 'no_slots_after_expansion',\n                voice_response: 'I apologize, but I was not able to find any available appointments within the next ' + Math.round(finalExpansionDays / 7) + ' weeks. Let me connect you with someone who can help schedule your appointment.',\n                action_required: 'transfer_to_agent',\n                transfer_reason: 'no_availability_after_8_week_search',\n                CRITICAL: 'All date expansion tiers exhausted. Transfer to agent for manual scheduling assistance.'\n            }\n        }\n    };\n}\n\nasync function executeRequest() {\n    const toolName = 'schedule_appointment_ortho';\n    const action = $action;\n    console.log('[' + toolName + '] ' + TOOL_VERSION + ' - INDIVIDUAL_PATIENT_PER_PERSON MODEL');\n    console.log('[' + toolName + '] Action: ' + action);\n\n    if (!action || !ACTIONS[action]) throw new Error('Invalid action. Valid: ' + Object.keys(ACTIONS).join(', '));\n    const config = ACTIONS[action];\n\n    // v64: Log $flow context for debugging - helps understand what context is available\n    console.log('[v64] $flow available:', typeof $flow !== 'undefined');\n    if (typeof $flow !== 'undefined' && $flow) {\n        console.log('[v64] $flow.sessionId:', $flow.sessionId || 'NOT SET');\n        console.log('[v64] $flow.chatId:', $flow.chatId || 'NOT SET');\n        console.log('[v64] $flow.chatflowId:', $flow.chatflowId || 'NOT SET');\n        console.log('[v64] $flow.input type:', typeof $flow.input);\n        if ($flow.input) {\n            const inputStr = typeof $flow.input === 'string' ? $flow.input : JSON.stringify($flow.input);\n            console.log('[v64] $flow.input (first 500 chars):', inputStr.substring(0, 500));\n        }\n        if ($flow.state) {\n            console.log('[v64] $flow.state keys:', Object.keys($flow.state).join(', '));\n        }\n    }\n\n    // v64: Log $vars context\n    console.log('[v64] $vars available:', typeof $vars !== 'undefined');\n    if (typeof $vars !== 'undefined' && $vars) {\n        console.log('[v64] $vars keys:', Object.keys($vars).join(', '));\n    }\n\n    let uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';\n    if ($vars && $vars.c1mg_uui && $vars.c1mg_uui !== 'c1mg_uui' && $vars.c1mg_uui.trim() !== '') uui = $vars.c1mg_uui;\n\n    // v68: Extract sessionId for cross-session reservation (prefer $flow.sessionId, fallback to uui)\n    let sessionId = null;\n    if (typeof $flow !== 'undefined' && $flow && $flow.sessionId) {\n        sessionId = $flow.sessionId;\n        console.log('[v68] Using $flow.sessionId for reservation:', sessionId.substring(0, 8) + '...');\n    } else if (typeof $flow !== 'undefined' && $flow && $flow.chatId) {\n        sessionId = $flow.chatId;\n        console.log('[v68] Using $flow.chatId as sessionId for reservation:', sessionId.substring(0, 8) + '...');\n    } else {\n        sessionId = uui;\n        console.log('[v68] WARNING: Using uui as sessionId fallback - cross-session reservation filtering may be ineffective');\n        console.log('[v68] To fix: Ensure $flow.sessionId or $flow.chatId is populated by Flowise');\n        console.log('[v68] UUI used:', uui.substring(0, 30) + '...');\n    }\n\n    // v64: Helper function to extract childName from flow context\n    function extractChildNameFromFlowContext() {\n        if (typeof $flow === 'undefined' || !$flow) return null;\n        // Try $flow.input - might contain PAYLOAD with children\n        if ($flow.input) {\n            try {\n                let inputData = $flow.input;\n                if (typeof inputData === 'string') {\n                    try { inputData = JSON.parse(inputData); } catch (e) { /* not JSON */ }\n                }\n                if (inputData && inputData.children && Array.isArray(inputData.children) && inputData.children.length > 0) {\n                    const firstChild = inputData.children[0];\n                    if (firstChild && firstChild.name) {\n                        console.log('[v64] Extracted childName from $flow.input.children:', firstChild.name);\n                        return firstChild.name;\n                    }\n                }\n                if (inputData && inputData.PAYLOAD && inputData.PAYLOAD.children) {\n                    const children = inputData.PAYLOAD.children;\n                    if (Array.isArray(children) && children.length > 0 && children[0].name) {\n                        console.log('[v64] Extracted childName from $flow.input.PAYLOAD.children:', children[0].name);\n                        return children[0].name;\n                    }\n                }\n            } catch (e) {\n                console.log('[v64] Error extracting from $flow.input:', e.message);\n            }\n        }\n        // Try $flow.state - might contain conversation state\n        if ($flow.state) {\n            try {\n                if ($flow.state.children && Array.isArray($flow.state.children) && $flow.state.children.length > 0) {\n                    const firstChild = $flow.state.children[0];\n                    if (firstChild && firstChild.name) {\n                        console.log('[v64] Extracted childName from $flow.state.children:', firstChild.name);\n                        return firstChild.name;\n                    }\n                }\n                if ($flow.state.PAYLOAD && $flow.state.PAYLOAD.children) {\n                    const children = $flow.state.PAYLOAD.children;\n                    if (Array.isArray(children) && children.length > 0 && children[0].name) {\n                        console.log('[v64] Extracted childName from $flow.state.PAYLOAD.children:', children[0].name);\n                        return children[0].name;\n                    }\n                }\n            } catch (e) {\n                console.log('[v64] Error extracting from $flow.state:', e.message);\n            }\n        }\n        return null;\n    }\n\n    // v64: Capture flow context debug info for response\n    const flowContextDebug = {\n        flowAvailable: typeof $flow !== 'undefined',\n        varsAvailable: typeof $vars !== 'undefined',\n        varsKeys: (typeof $vars !== 'undefined' && $vars) ? Object.keys($vars) : [],\n        flowSessionId: (typeof $flow !== 'undefined' && $flow) ? ($flow.sessionId || null) : null,\n        flowChatId: (typeof $flow !== 'undefined' && $flow) ? ($flow.chatId || null) : null,\n        flowInputType: (typeof $flow !== 'undefined' && $flow) ? typeof $flow.input : null,\n        flowInputPreview: null,\n        flowStateKeys: null\n    };\n    if (typeof $flow !== 'undefined' && $flow) {\n        if ($flow.input) {\n            const inputStr = typeof $flow.input === 'string' ? $flow.input : JSON.stringify($flow.input);\n            flowContextDebug.flowInputPreview = inputStr.substring(0, 300);\n        }\n        if ($flow.state) {\n            flowContextDebug.flowStateKeys = Object.keys($flow.state);\n        }\n    }\n\n    // v64: Get childName - first from explicit param, then try flow context fallback\n    let childNameFromLLM = typeof $childName !== 'undefined' ? $childName : null;\n    let childNameFromFlow = null;\n    if (!childNameFromLLM && action === 'book_child') {\n        childNameFromFlow = extractChildNameFromFlowContext();\n        if (childNameFromFlow) {\n            console.log('[v64] Using childName from flow context fallback:', childNameFromFlow);\n            flowContextDebug.childNameSource = 'flow_context';\n            flowContextDebug.childNameExtracted = childNameFromFlow;\n        } else {\n            console.log('[v64] WARNING: No childName from LLM or flow context');\n            flowContextDebug.childNameSource = 'none';\n        }\n    } else if (childNameFromLLM) {\n        flowContextDebug.childNameSource = 'llm_param';\n        flowContextDebug.childNameExtracted = childNameFromLLM;\n    }\n\n    const rawParams = {\n        startDate: typeof $startDate !== 'undefined' ? $startDate : null,\n        endDate: typeof $endDate !== 'undefined' ? $endDate : null,\n        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,\n        startTime: typeof $startTime !== 'undefined' ? $startTime : null,\n        scheduleViewGUID: typeof $scheduleViewGUID !== 'undefined' ? $scheduleViewGUID : null,\n        scheduleColumnGUID: typeof $scheduleColumnGUID !== 'undefined' ? $scheduleColumnGUID : null,\n        appointmentTypeGUID: typeof $appointmentTypeGUID !== 'undefined' ? $appointmentTypeGUID : null,\n        minutes: typeof $minutes !== 'undefined' ? $minutes : null,\n        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null,\n        // v64: childName with flow context fallback\n        childName: childNameFromLLM || childNameFromFlow,\n        // v54: Additional params for parent-as-patient note field\n        childDOB: typeof $childDOB !== 'undefined' ? $childDOB : null,\n        insuranceProvider: typeof $insuranceProvider !== 'undefined' ? $insuranceProvider : null,\n        groupID: typeof $groupID !== 'undefined' ? $groupID : null,\n        memberID: typeof $memberID !== 'undefined' ? $memberID : null,\n        // v55: Booking authorization token - validates patientGUID came from create response\n        bookingAuthToken: typeof $bookingAuthToken !== 'undefined' ? $bookingAuthToken : null,\n        // v63: Children array for batch booking\n        // v78: Parse children - may arrive as string (Flowise schema) or array (direct)\n        children: (() => {\n            if (typeof $children === 'undefined' || $children === null) return null;\n            if (Array.isArray($children)) return $children;\n            if (typeof $children === 'string') {\n                try { const parsed = JSON.parse($children); return Array.isArray(parsed) ? parsed : null; }\n                catch (e) { console.log('[v78] Failed to parse children string:', e.message); return null; }\n            }\n            return null;\n        })(),\n        // v76: Atomic book consultation - parent info triggers bookConsultation endpoint\n        parentFirstName: typeof $parentFirstName !== 'undefined' ? $parentFirstName : null,\n        parentLastName: typeof $parentLastName !== 'undefined' ? $parentLastName : null,\n        parentPhone: typeof $parentPhone !== 'undefined' ? $parentPhone : null,\n        parentEmail: typeof $parentEmail !== 'undefined' ? $parentEmail : null,\n        parentDOB: typeof $parentDOB !== 'undefined' ? $parentDOB : null\n    };\n    const params = cleanParams(rawParams);\n\n    try {\n        // v67: Always call Node-RED endpoints - Node-RED handles caching internally\n        if (action === 'slots' || action === 'grouped_slots') {\n            // v89: REMOVED v80 redirect - always use the endpoint the LLM requested\n            // v80 redirect was the ROOT CAUSE of sibling booking failures:\n            // Flowise sometimes doesn't inject $numberOfPatients for integer-typed schema fields,\n            // causing it to be undefined → removed by cleanParams → v80 redirected to getApptSlots\n            // which returns only 1 slot instead of paired slots from getGroupedApptSlots\n            let effectiveAction = action;\n\n            // v90: Dynamically determine numberOfPatients from children array\n            // Priority: explicit params.numberOfPatients > children array length > default 1\n            if (action === 'grouped_slots' && !params.numberOfPatients) {\n                if (params.children && Array.isArray(params.children) && params.children.length > 0) {\n                    params.numberOfPatients = params.children.length;\n                    console.log('[v90] Derived numberOfPatients=' + params.numberOfPatients + ' from children array length');\n                } else {\n                    params.numberOfPatients = 1; // v90: Default to 1 — single child is the common case\n                    console.log('[v90] Defaulting numberOfPatients=1 for grouped_slots (no children array provided)');\n                }\n            }\n            console.log('[v89] effectiveAction=' + effectiveAction + ' numberOfPatients=' + params.numberOfPatients + ' endpoint=' + ACTIONS[effectiveAction].endpoint);\n\n            const headers = { 'Content-Type': 'application/json' };\n            const authHeader = getAuthHeader();\n            if (authHeader) headers['Authorization'] = authHeader;\n\n            // v67: Call Node-RED endpoint via searchSlotsWithExpansion\n            // Node-RED handles Redis cache internally with correct data structure\n            // v68: Pass sessionId for cross-session reservation filtering\n            console.log('[v68] Calling Node-RED endpoint for ' + effectiveAction + ' with sessionId...');\n            const searchResult = await searchSlotsWithExpansion(effectiveAction, params, uui, headers, sessionId);\n\n            if (!searchResult.success) {\n                // Return the no-slots response with guidance\n                return JSON.stringify(searchResult.data);\n            }\n\n            let data = searchResult.data\n\n            console.log('[' + toolName + '] ' + config.successLog(data));\n            \n            // v52: Format slots with individual GUIDs for direct booking\n            data = formatSlotsResponse(data);\n\n            // v89: BULLETPROOF slot-to-child mapping\n            // Build final slots array to contain EXACTLY what LLM needs: one slot per child\n            // v90: numberOfPatients dynamically derived from children array upstream\n            const numberOfPatients = parseInt(params.numberOfPatients) || 1;\n            console.log('[v90] Processing response: numberOfPatients=' + numberOfPatients + ' action=' + action);\n            const bookingMode = data._bookingMode || (data.groups && data.groups.length > 0 ? 'consecutive' : (data.slots && data.slots.length > 0 ? 'individual' : 'none'));\n            const nodeRedBookingPlan = (data.llm_guidance && data.llm_guidance.booking_plan) ? data.llm_guidance.booking_plan : null;\n\n            if (bookingMode === 'consecutive' && data.groups && data.groups.length > 0) {\n                const bestGroup = data.groups[0];\n                const groupSlots = bestGroup.slots || [];\n                console.log('[v89] CONSECUTIVE: Using group[0] with ' + groupSlots.length + ' slots as data.slots');\n                data.slots = groupSlots;\n                data.count = groupSlots.length;\n                data._bookingMode = 'consecutive';\n                delete data.groups;\n                delete data.totalGroups;\n            } else if ((bookingMode === 'individual' || !data.groups || data.groups.length === 0) && data.slots && data.slots.length >= numberOfPatients) {\n                console.log('[v89] INDIVIDUAL: Keeping first ' + numberOfPatients + ' of ' + data.slots.length + ' slots');\n                data.slots = data.slots.slice(0, numberOfPatients);\n                data.count = data.slots.length;\n                data._bookingMode = 'individual';\n                delete data.groups;\n                delete data.totalGroups;\n            } else {\n                console.log('[v89] INSUFFICIENT: mode=' + bookingMode + ' slots=' + (data.slots ? data.slots.length : 0) + ' groups=' + (data.groups ? data.groups.length : 0) + ' needed=' + numberOfPatients);\n                // v89: If we need N slots but have fewer, return what we have with a warning\n                // This prevents the LLM from getting 1 slot and assigning it to 2 children\n                if (data.slots && data.slots.length > 0 && data.slots.length < numberOfPatients) {\n                    data._warning = 'INSUFFICIENT_SLOTS: Found ' + data.slots.length + ' but need ' + numberOfPatients + '. Cannot book all children in one pass.';\n                    data._bookingMode = 'insufficient';\n                }\n            }\n\n            // v88: Top-level booking_plan maps slots[i] to child[i+1]\n            const bookingPlan = [];\n            if (data.slots && data.slots.length >= numberOfPatients) {\n                for (let i = 0; i < numberOfPatients; i++) {\n                    const slot = data.slots[i];\n                    bookingPlan.push({\n                        child_number: i + 1,\n                        use_this_startTime: slot.startTime || slot.displayTime,\n                        use_this_scheduleViewGUID: slot.scheduleViewGUID,\n                        use_this_scheduleColumnGUID: slot.scheduleColumnGUID,\n                        use_this_appointmentTypeGUID: slot.appointmentTypeGUID,\n                        minutes: slot.minutes || '40'\n                    });\n                }\n            }\n\n            if (typeof data === 'object') {\n                data._toolVersion = TOOL_VERSION;\n                data._debug_v64_flow_context = flowContextDebug;\n                data.booking_plan = bookingPlan;\n                data.booking_mode = bookingMode;\n\n                if (data.llm_guidance && data.llm_guidance.action_required === 'book_children_separately') {\n                    console.log('[v84] Preserving book_children_separately guidance');\n                } else {\n                data.llm_guidance = {\n                    timestamp: new Date().toISOString(),\n                    model: 'INDIVIDUAL_PATIENT_PER_PERSON_V71',\n                    confirmation_triggers: ['yes', 'yeah', 'yep', 'yup', 'sure', 'okay', 'ok', 'alright', 'that works', 'works for me', 'perfect', 'sounds good'],\n                    goodbye_triggers: [\"that's all\", 'thats all', \"that's it\", 'thats it', 'no thank you', 'no thanks'],\n                    BOOKING_INSTRUCTIONS: numberOfPatients === 1 ? [\n                        'STEP 1: Offer the time to the caller.',\n                        'STEP 2: When confirmed, call book_child with parentFirstName + children array containing 1 child.',\n                        'STEP 3: The child MUST use the startTime from booking_plan[0].use_this_startTime.',\n                        'STEP 4: The children array in book_child MUST have EXACTLY 1 entry.'\n                    ] : [\n                        'STEP 1: Offer time(s) to caller. For consecutive slots say \"starting at [first time]\". For individual slots list each time.',\n                        'STEP 2: When confirmed, call book_child with parentFirstName + children array containing ALL ' + numberOfPatients + ' children.',\n                        'STEP 3: MANDATORY - Each child MUST use the startTime from booking_plan. Child N uses booking_plan[N-1].use_this_startTime. NEVER give two children the same startTime.',\n                        'STEP 4: The children array in book_child MUST have EXACTLY ' + numberOfPatients + ' entries. No more. No less. One slot per child.'\n                    ],\n                    CRITICAL_SLOT_RULE: 'v90: There are EXACTLY ' + numberOfPatients + ' slots for ' + numberOfPatients + ' children. The children array in book_child MUST contain EXACTLY ' + numberOfPatients + (numberOfPatients === 1 ? ' child.' : ' children. Even if caller only mentions one child when confirming, INCLUDE ALL CHILDREN.'),\n                    next_action: 'offer_time_to_caller_and_wait_for_confirmation',\n                    on_caller_confirms: 'call_book_child_with_parent_info_and_children_array',\n                    children_array_format: {\n                        description: 'v76 ATOMIC: Each child needs:',\n                        required_fields: ['firstName', 'dob', 'startTime', 'scheduleViewGUID'],\n                        optional_fields: ['lastName', 'scheduleColumnGUID', 'appointmentTypeGUID', 'minutes'],\n                        example: '{ firstName: \"Emma\", dob: \"05/15/2018\", startTime: \"01/25/2026 9:00 AM\", scheduleViewGUID: \"abc-123\" }'\n                    },\n                    IMPORTANT: 'v76: book_child with parentFirstName creates patients AND books atomically. Do NOT call chord_ortho_patient create separately.'\n                };\n                } // end else (v84)\n            }\n            return JSON.stringify(data);\n        }\n\n                // v76: ATOMIC BOOK CONSULTATION - route to bookConsultation when parent info present\n        if (action === 'book_child' && params.parentFirstName) {\n            console.log('[v76] ATOMIC BOOK CONSULTATION: parentFirstName present, routing to bookConsultation');\n            const headers = { 'Content-Type': 'application/json' };\n            const authHeader = getAuthHeader();\n            if (authHeader) headers['Authorization'] = authHeader;\n\n            // Validate children array is present\n            if (!params.children || !Array.isArray(params.children) || params.children.length === 0) {\n                throw new Error('BOOKING FAILED - Atomic book_child requires children array with slot assignments');\n            }\n\n            // v85: Validate unique slots BEFORE calling Node-RED\n            if (params.children.length > 1) {\n                const usedSlots = new Set();\n                for (let i = 0; i < params.children.length; i++) {\n                    const child = params.children[i];\n                    const slotKey = (child.startTime || '').trim().toLowerCase() + '|' + (child.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID).toLowerCase();\n                    if (usedSlots.has(slotKey)) {\n                        console.error('[v85] ATOMIC PATH: Duplicate slot for child ' + (i+1) + ': ' + child.startTime);\n                        return JSON.stringify({\n                            success: false,\n                            error: 'DUPLICATE_SLOT_ASSIGNMENT',\n                            _toolVersion: TOOL_VERSION,\n                            llm_guidance: {\n                                error_type: 'duplicate_slot',\n                                voice_response: 'Let me find a separate appointment time for your other child.',\n                                action_required: 'use_different_slots_per_child',\n                                CRITICAL: 'v85: EACH child MUST have a DIFFERENT startTime. You assigned the same slot (' + child.startTime + ') to multiple children. Look at the booking_plan from grouped_slots - Child 1 uses slot 1, Child 2 uses slot 2. Call grouped_slots again if needed.',\n                                duplicate_startTime: child.startTime,\n                                child_index: i + 1,\n                                fix: 'Re-read the booking_plan from the grouped_slots response. Each child has a unique startTime assigned.'\n                            }\n                        });\n                    }\n                    usedSlots.add(slotKey);\n                }\n                console.log('[v85] ATOMIC PATH: All ' + params.children.length + ' children have unique slot assignments');\n            }\n\n            const consultBody = {\n                uui: uui,\n                sessionId: sessionId,\n                parentFirstName: params.parentFirstName,\n                parentLastName: params.parentLastName,\n                parentPhone: params.parentPhone,\n                parentEmail: params.parentEmail || null,\n                parentDOB: params.parentDOB || null,\n                children: params.children.map(child => ({\n                    firstName: child.firstName || child.childName,\n                    lastName: child.lastName || params.parentLastName,\n                    dob: child.dob || child.childDOB,\n                    startTime: child.startTime,\n                    scheduleViewGUID: child.scheduleViewGUID,\n                    scheduleColumnGUID: child.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID,\n                    appointmentTypeGUID: child.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n                    minutes: child.minutes || 40\n                })),\n                insuranceProvider: params.insuranceProvider || null,\n                insuranceGroupId: params.groupID || null,\n                insuranceMemberId: params.memberID || null\n            };\n\n            console.log('[v76] bookConsultation body:', JSON.stringify(consultBody));\n            const response = await fetch(`${BASE_URL}/ortho-prd/bookConsultation`, {\n                method: 'POST', headers: headers, body: JSON.stringify(consultBody)\n            });\n            const responseText = await response.text();\n            let data;\n            try { data = JSON.parse(responseText); } catch (e) { data = responseText; }\n\n            if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);\n            const errorMessage = checkForError(data);\n            if (errorMessage) throw new Error(errorMessage);\n\n            console.log('[v76] bookConsultation success:', JSON.stringify(data).substring(0, 200));\n            if (typeof data === 'object') {\n                data._toolVersion = TOOL_VERSION;\n                data._debug_v64_flow_context = flowContextDebug;\n\n                // v89: Warn if fewer children booked than expected\n                const bookedCount = params.children ? params.children.length : 1;\n                const expectedCount = parseInt(params.numberOfPatients) || bookedCount;\n                if (data.children && data.children.length < expectedCount) {\n                    data._warning = 'INCOMPLETE_BOOKING: Only ' + data.children.length + ' of ' + expectedCount + ' children were booked. Book remaining children immediately.';\n                    data.llm_guidance = data.llm_guidance || {};\n                    data.llm_guidance.CRITICAL = 'Not all children were booked. Call book_child again for the remaining children.';\n                }\n\n                // v92: BOOKING RESPONSE VALIDATION - verify real Cloud9 GUIDs\n                if (data.children && Array.isArray(data.children)) {\n                    const verified = [];\n                    const unverified = [];\n                    for (const child of data.children) {\n                        const guid = child.appointment?.appointmentGUID || child.appointmentGUID;\n                        if (child.success && isRealAppointmentGUID(guid)) {\n                            verified.push(child.firstName || 'child');\n                        } else if (child.success) {\n                            unverified.push(child.firstName || 'child');\n                            child._booking_verified = false;\n                            child._warning = 'UNVERIFIED: No valid Cloud9 appointmentGUID in response';\n                        }\n                    }\n                    if (verified.length > 0) {\n                        data._booking_verified = true;\n                        console.log('[v92] BOOKING VERIFIED: ' + verified.join(', ') + ' have real Cloud9 GUIDs');\n                    }\n                    if (unverified.length > 0) {\n                        console.log('[v92] WARNING: ' + unverified.join(', ') + ' missing real Cloud9 GUIDs');\n                        data._booking_verified = false;\n                        data.llm_guidance = data.llm_guidance || {};\n                        data.llm_guidance.CRITICAL = (data.llm_guidance.CRITICAL || '') +\n                            ' v92 WARNING: ' + unverified.join(', ') + ' booking(s) could NOT be verified with a real Cloud9 appointment GUID. Do NOT confirm these appointments to the caller. Transfer to a live agent instead.';\n                    }\n                } else if (data.appointmentGUID) {\n                    data._booking_verified = isRealAppointmentGUID(data.appointmentGUID);\n                    if (!data._booking_verified) {\n                        console.log('[v92] WARNING: appointmentGUID \"' + data.appointmentGUID + '\" is not a valid Cloud9 GUID');\n                        data.llm_guidance = data.llm_guidance || {};\n                        data.llm_guidance.CRITICAL = 'v92 WARNING: The appointment ID returned is not a valid Cloud9 GUID. Do NOT confirm this booking. Transfer to a live agent.';\n                    }\n                }\n            }\n            return JSON.stringify(data);\n        }\n\n        // v77: ENFORCE ATOMIC PATH - block legacy book_child without parentFirstName\n        if (action === 'book_child' && !params.parentFirstName) {\n            console.log('[v77] BLOCKED legacy book_child - missing parentFirstName');\n            return JSON.stringify({\n                success: false,\n                error: 'ATOMIC_BOOKING_REQUIRED',\n                message: 'book_child requires parentFirstName for atomic booking. Do NOT create patients separately.',\n                llm_guidance: {\n                    error_type: 'missing_parent_info',\n                    action_required: 'retry_with_parent_info',\n                    voice_response: 'Let me get that set up for you.',\n                    CRITICAL: 'You MUST include parentFirstName, parentLastName, parentPhone, and children array in book_child. Node-RED creates patients + books appointments atomically. Do NOT call chord_ortho_patient create separately.',\n                    required_fields: ['parentFirstName', 'parentLastName', 'parentPhone', 'children'],\n                    example: {\n                        action: 'book_child',\n                        parentFirstName: 'Jane',\n                        parentLastName: 'Smith',\n                        parentPhone: '5551234567',\n                        children: [{ firstName: 'Jake', dob: '01/15/2015', startTime: '...', scheduleViewGUID: '...', scheduleColumnGUID: '...' }]\n                    }\n                },\n                _toolVersion: TOOL_VERSION\n            });\n        }\n\n        // Non-slot actions (cancel, etc.) - use original flow\n        config.validate(params);\n\n        const headers = { 'Content-Type': 'application/json' };\n        const authHeader = getAuthHeader();\n        if (authHeader) headers['Authorization'] = authHeader;\n\n        // v60: DISABLED v59 BULLETPROOF SLOT VALIDATION (Rate Limiting Fix)\n        // The verification called getApptSlots AGAIN before each book_child, triggering rate limiting\n        // After grouped_slots, subsequent API calls returned 0 slots (rate limited)\n        // Node-RED handles validation server-side as fallback\n        // ORIGINAL CODE REMOVED - was causing \"slot not available\" errors on valid slots\n        if (action === 'book_child') {\n            console.log('[v60] book_child - proceeding directly (v59 verification DISABLED due to rate limiting)');\n        }\n\n        // v68: Pass sessionId for cross-session reservation\n        const body = config.buildBody(params, uui, sessionId);\n        console.log('[' + toolName + '] Request:', JSON.stringify(body));\n\n        const response = await fetch(config.endpoint, { method: config.method, headers: headers, body: JSON.stringify(body) });\n        const responseText = await response.text();\n        let data;\n        try { data = JSON.parse(responseText); } catch (e) { data = responseText; }\n\n        if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);\n        const errorMessage = checkForError(data);\n        if (errorMessage) throw new Error(errorMessage);\n\n        console.log('[' + toolName + '] ' + config.successLog(data));\n        if (typeof data === 'object') {\n            data._toolVersion = TOOL_VERSION;\n            // v64: Include flow context debug in book_child response\n            data._debug_v64_flow_context = flowContextDebug;\n        }\n        return JSON.stringify(data);\n\n    } catch (error) {\n        console.error('[' + toolName + '] Error:', error.message);\n\n        // v57: BOOKING_AUTH errors now come from Node-RED (not tool) - pass through with guidance\n        if (error.message.includes('BOOKING_AUTH') || error.message.includes('booking_auth')) {\n            return JSON.stringify({\n                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,\n                _debug_v64_flow_context: flowContextDebug,\n                llm_guidance: {\n                    error_type: 'booking_auth_error',\n                    voice_response: 'Let me get that set up for you.',\n                    action_required: 'retry_after_create_completes',\n                    CRITICAL: 'v72: Each child has their own bookingAuthToken. Use the token from the CHILD create response, NOT the parent token.',\n                    recovery_steps: ['1) Check you are using the child patientGUID (not parent)', '2) Use the bookingAuthToken from that child\\'s create response', '3) Retry book_child with child patientGUID + child bookingAuthToken']\n                }\n            });\n        }\n\n        if (error.message.includes('BOOKING FAILED') || error.message.includes('Missing')) {\n            return JSON.stringify({\n                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,\n                _debug_v64_flow_context: flowContextDebug,\n                llm_guidance: {\n                    error_type: 'missing_params', \n                    voice_response: 'Let me check those details again.', \n                    action_required: 'provide_required_params',\n                    CRITICAL: 'book_child requires: patientGUID, startTime, scheduleViewGUID. Ensure chord_ortho_patient create completed and you have the patientGUID.'\n                }\n            });\n        }\n\n        if (error.message.includes('cannot be scheduled') || error.message.includes('time slot') || error.message.includes('not available')) {\n            return JSON.stringify({\n                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,\n                _debug_v64_flow_context: flowContextDebug,\n                llm_guidance: {\n                    error_type: 'slot_no_longer_available',\n                    voice_response: 'That time is no longer available. Let me find another option.',\n                    action_required: 'call_slots_offer_new_time',\n                    CRITICAL: 'The slot is taken. Call slots again to get a new bookingToken and offer the new time to caller.'\n                }\n            });\n        }\n\n        return JSON.stringify({\n            success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,\n            _debug_v64_flow_context: flowContextDebug,\n            llm_guidance: { error_type: 'api_error', voice_response: 'Let me connect you with a specialist.', action_required: 'transfer_to_agent' }\n        });\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}