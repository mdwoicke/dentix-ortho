/**
 * ============================================================================
 * CHORD SCHEDULING DSO - Appointment Scheduling Tool (Node Red Version)
 * Version: v69 | Updated: 2026-01-22
 * ============================================================================
 * Actions: slots, grouped_slots, book_child, cancel
 *
 * v69: ENHANCED SESSION ID FALLBACK LOGGING
 *      - Added explicit WARNING when using uui as sessionId fallback
 *      - Logs guidance on how to fix ($flow.sessionId should be populated by Flowise)
 *      - Helps diagnose why cross-session reservation filtering may be ineffective
 *
 * v68: CROSS-SESSION SLOT RESERVATION - Pass sessionId for reservation filtering
 *      - grouped_slots now passes sessionId to Node-RED
 *      - Node-RED filters out slots reserved by other sessions
 *      - book_child already passes sessionId for reservation creation
 *      - Prevents race condition where 2 callers book same slot
 *
 * v67: REMOVED DIRECT REDIS CACHE READ - All requests go through Node-RED
 *      - FIXED: v66 read Redis cache directly, bypassing Node-RED's cache logic
 *      - Node-RED handles caching internally with correct data structure handling
 *      - Tool now ALWAYS calls Node-RED endpoints (getApptSlots, getGroupedApptSlots)
 *      - This ensures consistent cache interpretation and slot grouping
 *
 * v66: (REVERTED) REDIS SLOT CACHE - Direct cache read caused empty slot responses
 *
 * v65: EXPANDED DATE SEARCH TIERS - Search up to 90 days (3 months)
 *      - Changed tiers from [14, 28, 56] to [30, 60, 90]
 *      - Fixes transfer issue when no slots in first 8 weeks but available at 9-12 weeks
 *
 * v64: FLOW CONTEXT FALLBACK - Extract childName from $flow.input if not passed
 *      - Tool now logs $flow context for debugging
 *      - If LLM doesn't pass $childName, tool attempts to extract from $flow.input
 *      - $flow.input may contain PAYLOAD with children array from conversation
 *      - This prevents missing childName when LLM forgets to pass it
 *
 * v63: CHILDREN ARRAY SUPPORT - Book all children in a single call
 *      - book_child now accepts a 'children' array parameter
 *      - Each child object contains: childName, childDOB, startTime, slot details
 *      - Node-RED loops through and creates all appointments atomically
 *      - Uses same rate limiting safeguards (2 retries + async queue fallback)
 *      - Prevents LLM from "forgetting" to book additional children
 *
 * v60: DISABLED PRE-BOOKING VERIFICATION (Rate Limiting Fix)
 *      - REMOVED v59 slot verification because it triggered API rate limiting
 *      - The verification called getApptSlots AGAIN before each book_child
 *      - After grouped_slots, subsequent API calls returned 0 slots (rate limited)
 *      - This caused "slot not available" errors even when slots WERE available
 *      - Node-RED handles validation server-side as fallback
 *
 * v59: BULLETPROOF SLOT VALIDATION (DISABLED - caused rate limiting failures)
 *      - book_child verified slot exists before booking via real-time API call
 *      - Validates ALL parameters but triggers rate limiting after grouped_slots
 *
 * v57: SERVER-SIDE AUTH VALIDATION (Tool Pass-Through)
 *      - REMOVED tool-level bookingAuthToken validation (was breaking LLM parallelism)
 *      - Tool now passes through to Node-RED, which handles session-based fallback
 *      - Node-RED auto-injects token from session cache if missing
 *      - This allows LLM to call create + book_child in any order
 *
 * v55: BOOKING AUTHORIZATION TOKEN
 *      - book_child now accepts bookingAuthToken parameter
 *      - Token is generated by chord_ortho_patient create and MUST be passed here
 *      - Prevents parallel tool call collisions (LLM using stale/hallucinated GUIDs)
 *      - Node-RED validates token and rejects mismatched patientGUIDs
 *
 * v54: PARENT-AS-PATIENT MODEL
 *      - Parent is the patient record, child info stored in appointment note
 *      - book_child now accepts childName, childDOB for the note field
 *      - SAME patientGUID is reused for ALL siblings
 *      - Note format: "Child: [name] | DOB: [date] | Insurance: [provider]"
 *      - Updated BOOKING_SEQUENCE_MANDATORY for parent-as-patient workflow
 *
 * v53 FIX: BOOKING SEQUENCE GUIDANCE - Add explicit llm_guidance to slots response
 * v52 FIX: INDIVIDUAL GUIDs FOR BOOKING - Accept individual params for book_child
 * v51 FIX: FUTURE DATE VALIDATION - Auto-correct dates too far in the future
 * v50 FIX: DYNAMIC SLOT SEARCH - Progressive date expansion when no slots found
 * v49 FIX: STRIP GUIDs FROM SLOTS RESPONSE
 * ============================================================================
 */

const fetch = require('node-fetch');

const TOOL_VERSION = 'v69';
const MAX_SLOTS_RETURNED = 1;
const BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord';
const DEFAULT_SCHEDULE_COLUMN_GUID = '07687884-7e37-49aa-8028-d43b751c9034';
const SANDBOX_MIN_DATE = new Date(2026, 0, 13);

// v50: Progressive date expansion tiers (in days)
// v65: Expanded to 30/60/90 days for better slot coverage
const DATE_EXPANSION_TIERS = [30, 60, 90]; // 1 month, 2 months, 3 months
const MIN_DATE_RANGE_DAYS = 30; // Minimum range to prevent single-day searches
// v51: Maximum days in the future to accept (prevents LLM hallucinated dates)
const MAX_FUTURE_DAYS = 90; // ~3 months - anything beyond this is likely an error

function encodeBookingToken(slot) {{
    const data = {{
        st: slot.startTime,
        sv: slot.scheduleViewGUID,
        sc: slot.scheduleColumnGUID,
        at: slot.appointmentTypeGUID,
        mn: slot.minutes
    }};
    return Buffer.from(JSON.stringify(data)).toString('base64');
}}

function decodeBookingToken(token) {{
    try {{
        const data = JSON.parse(Buffer.from(token, 'base64').toString('utf8'));
        return {{
            startTime: data.st,
            scheduleViewGUID: data.sv,
            scheduleColumnGUID: data.sc,
            appointmentTypeGUID: data.at,
            minutes: data.mn
        }};
    }} catch (e) {{
        console.error('[decodeBookingToken] Failed to decode:', e.message);
        return null;
    }}
}}

// v52: Return individual GUIDs in slots response for direct booking
function formatSlotsResponse(data) {{
    if (data && data.slots && Array.isArray(data.slots)) {{
        data.slots = data.slots.map(slot => ({{
            displayTime: slot.startTime || slot.StartTime,
            startTime: slot.startTime || slot.StartTime,
            scheduleViewGUID: slot.scheduleViewGUID,
            scheduleColumnGUID: slot.scheduleColumnGUID,
            appointmentTypeGUID: slot.appointmentTypeGUID,
            minutes: slot.minutes
        }}));
    }}
    if (data && data.groups && Array.isArray(data.groups)) {{
        data.groups = data.groups.map(group => ({{
            groupTime: group.slots && group.slots[0] ? (group.slots[0].startTime || group.slots[0].StartTime) : null,
            slots: group.slots ? group.slots.map(slot => ({{
                displayTime: slot.startTime || slot.StartTime,
                startTime: slot.startTime || slot.StartTime,
                scheduleViewGUID: slot.scheduleViewGUID,
                scheduleColumnGUID: slot.scheduleColumnGUID,
                appointmentTypeGUID: slot.appointmentTypeGUID,
                minutes: slot.minutes
            }})) : []
        }}));
    }}
    delete data.voiceSlots;
    return data;
}}

const ACTIONS = {{
    slots: {{
        endpoint: `${{BASE_URL}}/ortho-prd/getApptSlots`,
        method: 'POST',
        buildBody: (params, uui, sessionId) => {{
            const body = {{
                uui: uui,
                startDate: params.startDate,
                endDate: params.endDate,
                // v68: Pass sessionId for cross-session reservation filtering
                sessionId: sessionId
            }};
            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;
            return body;
        }},
        validate: () => {{}},
        successLog: (data) => `Found ${{data.count || (data.slots ? data.slots.length : 0) || 0}} available slots`
    }},
    grouped_slots: {{
        endpoint: `${{BASE_URL}}/ortho-prd/getGroupedApptSlots`,
        method: 'POST',
        buildBody: (params, uui, sessionId) => {{
            const body = {{
                uui: uui,
                startDate: params.startDate,
                endDate: params.endDate,
                numberOfPatients: params.numberOfPatients || 2,
                timeWindowMinutes: params.timeWindowMinutes || 30,
                // v68: Pass sessionId for cross-session reservation filtering
                sessionId: sessionId
            }};
            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;
            return body;
        }},
        validate: () => {{}},
        successLog: (data) => `Found ${{data.totalGroups || (data.groups ? data.groups.length : 0) || 0}} grouped slot options`
    }},
    book_child: {{
        endpoint: `${{BASE_URL}}/ortho-prd/createAppt`,
        method: 'POST',
        buildBody: (params, uui, sessionId) => {{
            // v63: CHILDREN ARRAY SUPPORT - Pass all children to Node-RED for atomic booking
            console.log('[book_child v63] Children array support, params:', JSON.stringify(params));

            const body = {{
                uui: uui,
                patientGUID: params.patientGUID,  // Parent's GUID - reused for all siblings
                // v55: Booking auth token - validates patientGUID came from create response
                bookingAuthToken: params.bookingAuthToken,
                // v68: Pass sessionId for cross-session slot reservation
                sessionId: sessionId
            }};

            // v63: If children array provided, pass it through for batch booking
            if (params.children && Array.isArray(params.children) && params.children.length > 0) {{
                console.log('[book_child v63] Batch booking ' + params.children.length + ' children');
                body.children = params.children.map(child => {{
                    // Build note for each child
                    let note = '';
                    if (child.childName) {{
                        note = 'Child: ' + child.childName;
                        if (child.childDOB) note += ' | DOB: ' + child.childDOB;
                        if (child.insuranceProvider) note += ' | Insurance: ' + child.insuranceProvider;
                        if (child.groupID) note += ' | GroupID: ' + child.groupID;
                        if (child.memberID) note += ' | MemberID: ' + child.memberID;
                    }}
                    return {{
                        childName: child.childName,
                        childDOB: child.childDOB,
                        startTime: child.startTime,
                        scheduleViewGUID: child.scheduleViewGUID,
                        scheduleColumnGUID: child.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID,
                        appointmentTypeGUID: child.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',
                        minutes: child.minutes || 40,
                        note: note
                    }};
                }});
            }} else {{
                // v54: Single child backward compatibility
                let note = '';
                if (params.childName) {{
                    note = 'Child: ' + params.childName;
                    if (params.childDOB) note += ' | DOB: ' + params.childDOB;
                    if (params.insuranceProvider) note += ' | Insurance: ' + params.insuranceProvider;
                    if (params.groupID) note += ' | GroupID: ' + params.groupID;
                    if (params.memberID) note += ' | MemberID: ' + params.memberID;
                }}
                body.startTime = params.startTime;
                body.scheduleViewGUID = params.scheduleViewGUID;
                body.scheduleColumnGUID = params.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID;
                body.appointmentTypeGUID = params.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705';
                body.minutes = params.minutes || 40;
                body.childName = params.childName;
                if (note) body.note = note;
            }}

            return body;
        }},
        validate: (params) => {{
            // v57: REMOVED bookingAuthToken validation - Node-RED handles this with session fallback
            if (!params.patientGUID) throw new Error('BOOKING FAILED - Missing patientGUID (parent GUID)');
            // v63: Either children array OR single child params required
            if (params.children && Array.isArray(params.children) && params.children.length > 0) {{
                // Validate each child has required fields
                for (let i = 0; i < params.children.length; i++) {{
                    const child = params.children[i];
                    if (!child.startTime) throw new Error('BOOKING FAILED - Child ' + (i+1) + ' missing startTime');
                    if (!child.scheduleViewGUID) throw new Error('BOOKING FAILED - Child ' + (i+1) + ' missing scheduleViewGUID');
                    if (!child.childName) console.log('[book_child v63] WARNING: Child ' + (i+1) + ' has no childName');
                }}
            }} else {{
                // Single child validation
                if (!params.startTime) throw new Error('BOOKING FAILED - Missing startTime');
                if (!params.scheduleViewGUID) throw new Error('BOOKING FAILED - Missing scheduleViewGUID');
                if (!params.childName) console.log('[book_child v63] WARNING: No childName provided');
            }}
        }},
        successLog: (data) => data.results ? 'Booked ' + data.results.length + ' appointments' : 'Appointment booked successfully'
    }},
    cancel: {{
        endpoint: `${{BASE_URL}}/ortho-prd/cancelAppt`,
        method: 'POST',
        buildBody: (params, uui, sessionId) => ({{ uui: uui, appointmentGUID: params.appointmentGUID, sessionId: sessionId }}),
        validate: (params) => {{ if (!params.appointmentGUID) throw new Error("appointmentGUID required"); }},
        successLog: () => 'Appointment cancelled successfully'
    }}
}};

function getAuthHeader() {{
    try {{
        const credentials = Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');
        return `Basic ${{credentials}}`;
    }} catch (e) {{ return null; }}
}}

function checkForError(data) {{
    if (!data || typeof data !== 'object') return null;
    if (data.success === false && !data.llm_guidance) return data.error || data.message || 'Operation failed';
    if (data.code === false) return Array.isArray(data.error) ? data.error.join(', ') : data.error;
    if (data.error && !data.slots && !data.groups && !data.appointmentGUID && !data.llm_guidance) {{
        return Array.isArray(data.error) ? data.error.join(', ') : data.error;
    }}
    if (data.message && data.message.toLowerCase().includes('error') && !data.appointmentGUID) return data.message;
    return null;
}}

function formatDate(date) {{
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    return `${{mm}}/${{dd}}/${{date.getFullYear()}}`;
}}

function parseDate(dateStr) {{
    if (!dateStr) return null;
    const parts = dateStr.split('/');
    if (parts.length !== 3) return null;
    return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));
}}

// v51: Enhanced date range correction with future date validation
function correctDateRange(startDate, endDate, expansionDays = DATE_EXPANSION_TIERS[0]) {{
    let correctedStart = startDate ? parseDate(startDate) : null;
    let correctedEnd = endDate ? parseDate(endDate) : null;
    const today = new Date(); today.setHours(0, 0, 0, 0);
    let datesCorrected = false;
    let originalStart = startDate;
    let originalEnd = endDate;
    
    // v51: Check if dates are too far in the future (LLM hallucination detection)
    const maxFutureDate = new Date(today);
    maxFutureDate.setDate(maxFutureDate.getDate() + MAX_FUTURE_DAYS);
    
    if (correctedStart && correctedStart > maxFutureDate) {{
        console.log('[v51] WARNING: startDate ' + startDate + ' is ' + Math.ceil((correctedStart - today) / (1000 * 60 * 60 * 24)) + ' days in future - AUTO-CORRECTING to today');
        correctedStart = null; // Will be set to today below
        datesCorrected = true;
    }}
    if (correctedEnd && correctedEnd > maxFutureDate) {{
        console.log('[v51] WARNING: endDate ' + endDate + ' is too far in future - will be recalculated');
        correctedEnd = null; // Will be recalculated below
        datesCorrected = true;
    }}
    
    // Fix dates in the past or missing
    if (!correctedStart || correctedStart < today) {{
        correctedStart = new Date(Math.max(today.getTime(), SANDBOX_MIN_DATE.getTime()));
    }}
    if (correctedStart < SANDBOX_MIN_DATE) correctedStart = new Date(SANDBOX_MIN_DATE);
    
    // v50: Calculate days between dates
    let daysDiff = 0;
    if (correctedEnd && correctedEnd > correctedStart) {{
        daysDiff = Math.ceil((correctedEnd - correctedStart) / (1000 * 60 * 60 * 24));
    }}
    
    // v50: Enforce minimum range AND use expansion tier
    if (!correctedEnd || correctedEnd <= correctedStart || daysDiff < MIN_DATE_RANGE_DAYS) {{
        correctedEnd = new Date(correctedStart);
        correctedEnd.setDate(correctedEnd.getDate() + expansionDays);
    }}
    
    // v51: Log when dates were auto-corrected
    if (datesCorrected) {{
        console.log('[v51] Date auto-correction: original=' + originalStart + ' to ' + originalEnd + ' -> corrected=' + formatDate(correctedStart) + ' to ' + formatDate(correctedEnd));
    }}
    
    return {{ startDate: formatDate(correctedStart), endDate: formatDate(correctedEnd), expansionDays: expansionDays, datesCorrected: datesCorrected }};
}}

function cleanParams(params) {{
    const cleaned = {{}};
    for (const [key, value] of Object.entries(params)) {{
        if (value !== null && value !== undefined && value !== '' && value !== 'NULL' && value !== 'null' && value !== 'None') {{
            cleaned[key] = value;
        }}
    }}
    return cleaned;
}}

// v59: BULLETPROOF SLOT VALIDATION - Verify slot exists with ALL parameters before booking
async function verifySlotAvailability(params, headers) {{
    console.log('[v59] Verifying slot availability before booking...');
    const startTime = params.startTime;
    if (!startTime) return {{ valid: false, reason: 'missing_startTime' }};
    const dateMatch = startTime.match(/(\d{{1,2}})\/(\d{{1,2}})\/(\d{{4}})/);
    if (!dateMatch) return {{ valid: false, reason: 'invalid_startTime_format' }};
    const slotDate = dateMatch[0];
    console.log('[v59] Checking real-time availability for date: ' + slotDate);
    try {{
        const response = await fetch(BASE_URL + '/ortho-prd/getApptSlots', {{
            method: 'POST', headers: headers,
            body: JSON.stringify({{ uui: params.uui || 'verify-' + Date.now(), startDate: slotDate, endDate: slotDate, duration: params.minutes || 40 }})
        }});
        const data = JSON.parse(await response.text());
        if (!response.ok || !data || !data.slots) return {{ valid: true, reason: 'verification_skipped' }};
        console.log('[v59] Found ' + data.slots.length + ' slots on ' + slotDate);
        const normalizeTime = t => (t || '').toLowerCase().replace(/\s+/g, ' ').trim();
        const normalizeGUID = g => (g || '').toLowerCase().trim();
        const reqTime = normalizeTime(params.startTime);
        const reqChair = normalizeGUID(params.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID);
        const reqView = normalizeGUID(params.scheduleViewGUID);
        const reqApptType = normalizeGUID(params.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705');
        const reqMinutes = parseInt(params.minutes || 40);
        console.log('[v59] Looking for: time=' + reqTime + ' chair=' + reqChair + ' min=' + reqMinutes);
        const match = data.slots.find(s => {{
            const sTime = normalizeTime(s.startTime || s.StartTime);
            const sChair = normalizeGUID(s.scheduleColumnGUID || s.ScheduleColumnGUID);
            const sView = normalizeGUID(s.scheduleViewGUID || s.ScheduleViewGUID);
            const sApptType = normalizeGUID(s.appointmentTypeGUID || s.AppointmentTypeGUID);
            const sMin = parseInt(s.minutes || s.Minutes || 40);
            if (sTime === reqTime) console.log('[v59] Time match! Chair:' + (sChair===reqChair) + ' View:' + (!reqView||sView===reqView) + ' Type:' + (sApptType===reqApptType) + ' Min:' + (sMin===reqMinutes));
            return sTime === reqTime && sChair === reqChair && (!reqView || sView === reqView) && sApptType === reqApptType && sMin === reqMinutes;
        }});
        if (match) {{ console.log('[v59] SLOT VERIFIED'); return {{ valid: true, reason: 'verified', slot: match }}; }}
        console.log('[v59] SLOT NOT FOUND in current availability');
        return {{ valid: false, reason: 'slot_not_available', freshSlots: data.slots.slice(0, 5).map(s => ({{ startTime: s.startTime || s.StartTime, scheduleViewGUID: s.scheduleViewGUID, scheduleColumnGUID: s.scheduleColumnGUID, appointmentTypeGUID: s.appointmentTypeGUID, minutes: s.minutes || 40 }})) }};
    }} catch (e) {{ console.log('[v59] Verification error: ' + e.message); return {{ valid: true, reason: 'verification_skipped_error' }}; }}
}}

// v50: Dynamic slot search with progressive expansion
// v68: Added sessionId parameter for cross-session reservation filtering
async function searchSlotsWithExpansion(action, params, uui, headers, sessionId) {{
    const config = ACTIONS[action];
    let lastError = null;
    let searchExpanded = false;
    let finalExpansionDays = DATE_EXPANSION_TIERS[0];

    for (let tierIndex = 0; tierIndex < DATE_EXPANSION_TIERS.length; tierIndex++) {{
        const expansionDays = DATE_EXPANSION_TIERS[tierIndex];
        const corrected = correctDateRange(params.startDate, params.endDate, expansionDays);

        const searchParams = {{ ...params, startDate: corrected.startDate, endDate: corrected.endDate }};
        const body = config.buildBody(searchParams, uui, sessionId);
        
        console.log('[v50] Tier ' + tierIndex + ' search: ' + corrected.startDate + ' to ' + corrected.endDate + ' (' + expansionDays + ' days)');
        
        try {{
            const response = await fetch(config.endpoint, {{ method: config.method, headers: headers, body: JSON.stringify(body) }});
            const responseText = await response.text();
            let data;
            try {{ data = JSON.parse(responseText); }} catch (e) {{ data = responseText; }}
            
            if (!response.ok) {{
                lastError = 'HTTP ' + response.status + ': ' + response.statusText;
                continue;
            }}
            
            const errorMessage = checkForError(data);
            if (errorMessage) {{
                lastError = errorMessage;
                continue;
            }}
            
            // Check if we got slots/groups
            const hasResults = (action === 'slots' && data.slots && data.slots.length > 0) ||
                               (action === 'grouped_slots' && data.groups && data.groups.length > 0);
            
            if (hasResults) {{
                // v50: Add metadata about the search
                data._searchExpanded = tierIndex > 0;
                data._expansionTier = tierIndex;
                data._dateRange = {{ start: corrected.startDate, end: corrected.endDate, days: expansionDays }};
                if (tierIndex > 0) {{
                    console.log('[v50] Found slots after expanding to tier ' + tierIndex + ' (' + expansionDays + ' days)');
                }}
                return {{ success: true, data: data }};
            }}
            
            // No results, try next tier
            searchExpanded = true;
            finalExpansionDays = expansionDays;
            console.log('[v50] No slots found at tier ' + tierIndex + ', expanding...');
            
        }} catch (e) {{
            lastError = e.message;
            console.log('[v50] Search error at tier ' + tierIndex + ': ' + e.message);
        }}
    }}
    
    // v50: All tiers exhausted, no slots found
    console.log('[v50] All expansion tiers exhausted, no slots found');
    return {{
        success: false,
        data: {{
            slots: [],
            groups: [],
            count: 0,
            totalGroups: 0,
            _toolVersion: TOOL_VERSION,
            _searchExpanded: searchExpanded,
            _expansionTier: DATE_EXPANSION_TIERS.length - 1,
            _dateRange: {{ days: finalExpansionDays }},
            _debug_error: lastError || 'No slots available after searching ' + finalExpansionDays + ' days',
            llm_guidance: {{
                error_type: 'no_slots_after_expansion',
                voice_response: 'I apologize, but I was not able to find any available appointments within the next ' + Math.round(finalExpansionDays / 7) + ' weeks. Let me connect you with someone who can help schedule your appointment.',
                action_required: 'transfer_to_agent',
                transfer_reason: 'no_availability_after_8_week_search',
                CRITICAL: 'All date expansion tiers exhausted. Transfer to agent for manual scheduling assistance.'
            }}
        }}
    }};
}}

async function executeRequest() {{
    const toolName = 'schedule_appointment_ortho';
    const action = $action;
    console.log('[' + toolName + '] ' + TOOL_VERSION + ' - FLOW CONTEXT FALLBACK');
    console.log('[' + toolName + '] Action: ' + action);

    if (!action || !ACTIONS[action]) throw new Error('Invalid action. Valid: ' + Object.keys(ACTIONS).join(', '));
    const config = ACTIONS[action];

    // v64: Log $flow context for debugging - helps understand what context is available
    console.log('[v64] $flow available:', typeof $flow !== 'undefined');
    if (typeof $flow !== 'undefined' && $flow) {{
        console.log('[v64] $flow.sessionId:', $flow.sessionId || 'NOT SET');
        console.log('[v64] $flow.chatId:', $flow.chatId || 'NOT SET');
        console.log('[v64] $flow.chatflowId:', $flow.chatflowId || 'NOT SET');
        console.log('[v64] $flow.input type:', typeof $flow.input);
        if ($flow.input) {{
            const inputStr = typeof $flow.input === 'string' ? $flow.input : JSON.stringify($flow.input);
            console.log('[v64] $flow.input (first 500 chars):', inputStr.substring(0, 500));
        }}
        if ($flow.state) {{
            console.log('[v64] $flow.state keys:', Object.keys($flow.state).join(', '));
        }}
    }}

    // v64: Log $vars context
    console.log('[v64] $vars available:', typeof $vars !== 'undefined');
    if (typeof $vars !== 'undefined' && $vars) {{
        console.log('[v64] $vars keys:', Object.keys($vars).join(', '));
    }}

    let uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';
    if ($vars && $vars.c1mg_uui && $vars.c1mg_uui !== 'c1mg_uui' && $vars.c1mg_uui.trim() !== '') uui = $vars.c1mg_uui;

    // v68: Extract sessionId for cross-session reservation (prefer $flow.sessionId, fallback to uui)
    let sessionId = null;
    if (typeof $flow !== 'undefined' && $flow && $flow.sessionId) {{
        sessionId = $flow.sessionId;
        console.log('[v68] Using $flow.sessionId for reservation:', sessionId.substring(0, 8) + '...');
    }} else if (typeof $flow !== 'undefined' && $flow && $flow.chatId) {{
        sessionId = $flow.chatId;
        console.log('[v68] Using $flow.chatId as sessionId for reservation:', sessionId.substring(0, 8) + '...');
    }} else {{
        sessionId = uui;
        console.log('[v68] WARNING: Using uui as sessionId fallback - cross-session reservation filtering may be ineffective');
        console.log('[v68] To fix: Ensure $flow.sessionId or $flow.chatId is populated by Flowise');
        console.log('[v68] UUI used:', uui.substring(0, 30) + '...');
    }}

    // v64: Helper function to extract childName from flow context
    function extractChildNameFromFlowContext() {{
        if (typeof $flow === 'undefined' || !$flow) return null;
        // Try $flow.input - might contain PAYLOAD with children
        if ($flow.input) {{
            try {{
                let inputData = $flow.input;
                if (typeof inputData === 'string') {{
                    try {{ inputData = JSON.parse(inputData); }} catch (e) {{ /* not JSON */ }}
                }}
                if (inputData && inputData.children && Array.isArray(inputData.children) && inputData.children.length > 0) {{
                    const firstChild = inputData.children[0];
                    if (firstChild && firstChild.name) {{
                        console.log('[v64] Extracted childName from $flow.input.children:', firstChild.name);
                        return firstChild.name;
                    }}
                }}
                if (inputData && inputData.PAYLOAD && inputData.PAYLOAD.children) {{
                    const children = inputData.PAYLOAD.children;
                    if (Array.isArray(children) && children.length > 0 && children[0].name) {{
                        console.log('[v64] Extracted childName from $flow.input.PAYLOAD.children:', children[0].name);
                        return children[0].name;
                    }}
                }}
            }} catch (e) {{
                console.log('[v64] Error extracting from $flow.input:', e.message);
            }}
        }}
        // Try $flow.state - might contain conversation state
        if ($flow.state) {{
            try {{
                if ($flow.state.children && Array.isArray($flow.state.children) && $flow.state.children.length > 0) {{
                    const firstChild = $flow.state.children[0];
                    if (firstChild && firstChild.name) {{
                        console.log('[v64] Extracted childName from $flow.state.children:', firstChild.name);
                        return firstChild.name;
                    }}
                }}
                if ($flow.state.PAYLOAD && $flow.state.PAYLOAD.children) {{
                    const children = $flow.state.PAYLOAD.children;
                    if (Array.isArray(children) && children.length > 0 && children[0].name) {{
                        console.log('[v64] Extracted childName from $flow.state.PAYLOAD.children:', children[0].name);
                        return children[0].name;
                    }}
                }}
            }} catch (e) {{
                console.log('[v64] Error extracting from $flow.state:', e.message);
            }}
        }}
        return null;
    }}

    // v64: Capture flow context debug info for response
    const flowContextDebug = {{
        flowAvailable: typeof $flow !== 'undefined',
        varsAvailable: typeof $vars !== 'undefined',
        varsKeys: (typeof $vars !== 'undefined' && $vars) ? Object.keys($vars) : [],
        flowSessionId: (typeof $flow !== 'undefined' && $flow) ? ($flow.sessionId || null) : null,
        flowChatId: (typeof $flow !== 'undefined' && $flow) ? ($flow.chatId || null) : null,
        flowInputType: (typeof $flow !== 'undefined' && $flow) ? typeof $flow.input : null,
        flowInputPreview: null,
        flowStateKeys: null
    }};
    if (typeof $flow !== 'undefined' && $flow) {{
        if ($flow.input) {{
            const inputStr = typeof $flow.input === 'string' ? $flow.input : JSON.stringify($flow.input);
            flowContextDebug.flowInputPreview = inputStr.substring(0, 300);
        }}
        if ($flow.state) {{
            flowContextDebug.flowStateKeys = Object.keys($flow.state);
        }}
    }}

    // v64: Get childName - first from explicit param, then try flow context fallback
    let childNameFromLLM = typeof $childName !== 'undefined' ? $childName : null;
    let childNameFromFlow = null;
    if (!childNameFromLLM && action === 'book_child') {{
        childNameFromFlow = extractChildNameFromFlowContext();
        if (childNameFromFlow) {{
            console.log('[v64] Using childName from flow context fallback:', childNameFromFlow);
            flowContextDebug.childNameSource = 'flow_context';
            flowContextDebug.childNameExtracted = childNameFromFlow;
        }} else {{
            console.log('[v64] WARNING: No childName from LLM or flow context');
            flowContextDebug.childNameSource = 'none';
        }}
    }} else if (childNameFromLLM) {{
        flowContextDebug.childNameSource = 'llm_param';
        flowContextDebug.childNameExtracted = childNameFromLLM;
    }}

    const rawParams = {{
        startDate: typeof $startDate !== 'undefined' ? $startDate : null,
        endDate: typeof $endDate !== 'undefined' ? $endDate : null,
        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,
        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,
        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,
        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,
        startTime: typeof $startTime !== 'undefined' ? $startTime : null,
        scheduleViewGUID: typeof $scheduleViewGUID !== 'undefined' ? $scheduleViewGUID : null,
        scheduleColumnGUID: typeof $scheduleColumnGUID !== 'undefined' ? $scheduleColumnGUID : null,
        appointmentTypeGUID: typeof $appointmentTypeGUID !== 'undefined' ? $appointmentTypeGUID : null,
        minutes: typeof $minutes !== 'undefined' ? $minutes : null,
        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null,
        // v64: childName with flow context fallback
        childName: childNameFromLLM || childNameFromFlow,
        // v54: Additional params for parent-as-patient note field
        childDOB: typeof $childDOB !== 'undefined' ? $childDOB : null,
        insuranceProvider: typeof $insuranceProvider !== 'undefined' ? $insuranceProvider : null,
        groupID: typeof $groupID !== 'undefined' ? $groupID : null,
        memberID: typeof $memberID !== 'undefined' ? $memberID : null,
        // v55: Booking authorization token - validates patientGUID came from create response
        bookingAuthToken: typeof $bookingAuthToken !== 'undefined' ? $bookingAuthToken : null,
        // v63: Children array for batch booking
        children: typeof $children !== 'undefined' ? $children : null
    }};
    const params = cleanParams(rawParams);

    try {{
        // v67: Always call Node-RED endpoints - Node-RED handles caching internally
        if (action === 'slots' || action === 'grouped_slots') {{
            const headers = {{ 'Content-Type': 'application/json' }};
            const authHeader = getAuthHeader();
            if (authHeader) headers['Authorization'] = authHeader;

            // v67: Call Node-RED endpoint via searchSlotsWithExpansion
            // Node-RED handles Redis cache internally with correct data structure
            // v68: Pass sessionId for cross-session reservation filtering
            console.log('[v68] Calling Node-RED endpoint for ' + action + ' with sessionId...');
            const searchResult = await searchSlotsWithExpansion(action, params, uui, headers, sessionId);

            if (!searchResult.success) {{
                // Return the no-slots response with guidance
                return JSON.stringify(searchResult.data);
            }}

            let data = searchResult.data

            console.log('[' + toolName + '] ' + config.successLog(data));
            
            // v52: Format slots with individual GUIDs for direct booking
            data = formatSlotsResponse(data);
            
            // Truncate to MAX_SLOTS_RETURNED
            if (data && data.slots && data.slots.length > MAX_SLOTS_RETURNED) {{
                data.slots = data.slots.slice(0, MAX_SLOTS_RETURNED);
                data.count = MAX_SLOTS_RETURNED;
                data._truncated = true;
            }}
            if (data && data.groups && data.groups.length > MAX_SLOTS_RETURNED) {{
                data.groups = data.groups.slice(0, MAX_SLOTS_RETURNED);
                data.totalGroups = MAX_SLOTS_RETURNED;
                data._truncated = true;
            }}
            
            if (typeof data === 'object') {{
                data._toolVersion = TOOL_VERSION;
                // v64: Include flow context debug in response
                data._debug_v64_flow_context = flowContextDebug;
                // v63: Children array booking sequence guidance
                data.llm_guidance = {{
                    timestamp: new Date().toISOString(),
                    model: 'PARENT_AS_PATIENT_V63',
                    confirmation_triggers: ['yes', 'yeah', 'yep', 'yup', 'sure', 'okay', 'ok', 'alright', 'that works', 'works for me', 'perfect', 'sounds good'],
                    goodbye_triggers: ["that's all", 'thats all', "that's it", 'thats it', 'no thank you', 'no thanks'],
                    BOOKING_SEQUENCE_MANDATORY: [
                        'STEP 1: Offer the slot time(s) to the caller and wait for confirmation',
                        'STEP 2: When caller confirms, call chord_ortho_patient action=create with PARENT firstName/lastName/phone',
                        'STEP 3: Get the patientGUID and bookingAuthToken from the chord_ortho_patient response',
                        'STEP 4: Call schedule_appointment_ortho action=book_child ONE TIME with ALL children:',
                        '        - patientGUID: the PARENT GUID from step 3',
                        '        - bookingAuthToken: the token from step 3',
                        '        - children: array of objects, one per child, each containing:',
                        '          {{ childName, childDOB, startTime, scheduleViewGUID, scheduleColumnGUID }}',
                        'CRITICAL: Pass ALL children in ONE book_child call using the children array. Do NOT call book_child multiple times.'
                    ],
                    sibling_workflow: 'For 2+ children: create PARENT once, then pass ALL children in a single book_child call using the children array parameter',
                    next_action: 'offer_time_to_caller_and_wait_for_confirmation',
                    on_caller_confirms: 'call_chord_ortho_patient_action_create_then_book_child_with_children_array',
                    children_array_format: {{
                        description: 'Each child object in the children array should have:',
                        required_fields: ['childName', 'startTime', 'scheduleViewGUID'],
                        optional_fields: ['childDOB', 'scheduleColumnGUID', 'appointmentTypeGUID', 'minutes', 'insuranceProvider', 'groupID', 'memberID'],
                        example: '{{ childName: "Emma", childDOB: "05/15/2018", startTime: "01/25/2026 9:00 AM", scheduleViewGUID: "abc-123" }}'
                    }}
                }};
            }}
            return JSON.stringify(data);
        }}
        
        // Non-slot actions (book_child, cancel) - use original flow
        config.validate(params);

        const headers = {{ 'Content-Type': 'application/json' }};
        const authHeader = getAuthHeader();
        if (authHeader) headers['Authorization'] = authHeader;

        // v60: DISABLED v59 BULLETPROOF SLOT VALIDATION (Rate Limiting Fix)
        // The verification called getApptSlots AGAIN before each book_child, triggering rate limiting
        // After grouped_slots, subsequent API calls returned 0 slots (rate limited)
        // Node-RED handles validation server-side as fallback
        // ORIGINAL CODE REMOVED - was causing "slot not available" errors on valid slots
        if (action === 'book_child') {{
            console.log('[v60] book_child - proceeding directly (v59 verification DISABLED due to rate limiting)');
        }}

        // v68: Pass sessionId for cross-session reservation
        const body = config.buildBody(params, uui, sessionId);
        console.log('[' + toolName + '] Request:', JSON.stringify(body));

        const response = await fetch(config.endpoint, {{ method: config.method, headers: headers, body: JSON.stringify(body) }});
        const responseText = await response.text();
        let data;
        try {{ data = JSON.parse(responseText); }} catch (e) {{ data = responseText; }}

        if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);
        const errorMessage = checkForError(data);
        if (errorMessage) throw new Error(errorMessage);

        console.log('[' + toolName + '] ' + config.successLog(data));
        if (typeof data === 'object') {{
            data._toolVersion = TOOL_VERSION;
            // v64: Include flow context debug in book_child response
            data._debug_v64_flow_context = flowContextDebug;
        }}
        return JSON.stringify(data);

    }} catch (error) {{
        console.error('[' + toolName + '] Error:', error.message);

        // v57: BOOKING_AUTH errors now come from Node-RED (not tool) - pass through with guidance
        if (error.message.includes('BOOKING_AUTH') || error.message.includes('booking_auth')) {{
            return JSON.stringify({{
                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,
                _debug_v64_flow_context: flowContextDebug,
                llm_guidance: {{ 
                    error_type: 'booking_auth_error', 
                    voice_response: 'Let me get that set up for you.', 
                    action_required: 'retry_after_create_completes',
                    CRITICAL: 'The booking auth token may be missing or expired. Ensure chord_ortho_patient action=create completed successfully, then retry book_child.',
                    recovery_steps: ['1) Verify create response has bookingAuthToken', '2) Retry book_child with token from create response']
                }}
            }});
        }}

        if (error.message.includes('BOOKING FAILED') || error.message.includes('Missing')) {{
            return JSON.stringify({{
                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,
                _debug_v64_flow_context: flowContextDebug,
                llm_guidance: {{
                    error_type: 'missing_params', 
                    voice_response: 'Let me check those details again.', 
                    action_required: 'provide_required_params',
                    CRITICAL: 'book_child requires: patientGUID, startTime, scheduleViewGUID. Ensure chord_ortho_patient create completed and you have the patientGUID.'
                }}
            }});
        }}

        if (error.message.includes('cannot be scheduled') || error.message.includes('time slot') || error.message.includes('not available')) {{
            return JSON.stringify({{
                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,
                _debug_v64_flow_context: flowContextDebug,
                llm_guidance: {{
                    error_type: 'slot_no_longer_available',
                    voice_response: 'That time is no longer available. Let me find another option.',
                    action_required: 'call_slots_offer_new_time',
                    CRITICAL: 'The slot is taken. Call slots again to get a new bookingToken and offer the new time to caller.'
                }}
            }});
        }}

        return JSON.stringify({{
            success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,
            _debug_v64_flow_context: flowContextDebug,
            llm_guidance: {{ error_type: 'api_error', voice_response: 'Let me connect you with a specialist.', action_required: 'transfer_to_agent' }}
        }});
    }}
}}

return executeRequest();
