{
  "name": "schedule_appointment_dso",
  "description": "Appointment scheduling operations. Use action 'slots' to get available times, 'grouped_slots' for siblings, 'book_child' to book, 'cancel' to cancel. Dates in MM/DD/YYYY format. Past dates are auto-corrected to tomorrow.\n\nACTION 'slots': Get available appointment times. Returns startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes.\n\nACTION 'grouped_slots': MUST call for siblings or multiple patients. Provide startDate, endDate, and numberOfPatients. Returns grouped consecutive slots.\n\nACTION 'book_child': MUST call AFTER caller confirms appointment time. REQUIRES: patientGUID, startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes. All values come from the slots response.\n\nACTION 'cancel': Call to cancel an existing appointment. Requires appointmentGUID.\n\nCRITICAL: Never transfer to live agent with reason \"Unable to retrieve appointment availability\" without first calling this tool with action 'slots'.\n",
  "color": "linear-gradient(rgb(119,46,188), rgb(11,231,3))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"The scheduling operation: slots, grouped_slots, book_child, cancel\",\"required\":true},{\"id\":1,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"Start date MM/DD/YYYY\",\"required\":false},{\"id\":2,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"End date MM/DD/YYYY\",\"required\":false},{\"id\":3,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"Schedule view GUIDs\",\"required\":false},{\"id\":4,\"property\":\"numberOfPatients\",\"type\":\"integer\",\"description\":\"Number of patients for grouped_slots\",\"required\":false},{\"id\":5,\"property\":\"timeWindowMinutes\",\"type\":\"integer\",\"description\":\"Time window in minutes\",\"required\":false},{\"id\":6,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"Patient GUID for booking\",\"required\":false},{\"id\":7,\"property\":\"startTime\",\"type\":\"string\",\"description\":\"Appointment time MM/DD/YYYY HH:MM AM\",\"required\":false},{\"id\":8,\"property\":\"scheduleViewGUID\",\"type\":\"string\",\"description\":\"Schedule view GUID\",\"required\":false},{\"id\":9,\"property\":\"scheduleColumnGUID\",\"type\":\"string\",\"description\":\"Schedule column GUID\",\"required\":false},{\"id\":10,\"property\":\"appointmentTypeGUID\",\"type\":\"string\",\"description\":\"Appointment type GUID\",\"required\":false},{\"id\":11,\"property\":\"minutes\",\"type\":\"integer\",\"description\":\"Duration in minutes\",\"required\":false},{\"id\":12,\"property\":\"providerGUID\",\"type\":\"string\",\"description\":\"Provider GUID\",\"required\":false},{\"id\":13,\"property\":\"locationGUID\",\"type\":\"string\",\"description\":\"Location GUID\",\"required\":false},{\"id\":14,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"Appointment GUID for cancel\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING V3 - Enhanced with Advanced LLM Guidance\n * ============================================================================\n *\n * PROMPTING TECHNIQUES USED:\n * 1. State Machine Integration - Returns next_state for prompt to use\n * 2. Chain-of-Action Guidance - Explicit action sequences\n * 3. Confirmation Detection - Pre-computed confirmation phrases\n * 4. Voice-First Responses - TTS-ready spoken text\n * 5. Prohibited Response Filtering - Explicit \"never say\" list\n *\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\n// ============================================================================\n// CLOUD9 API CONFIGURATION\n// ============================================================================\n\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partnertest.cloud9ortho.com/GetData.ashx',\n    clientId: 'c15aa02a-adc1-40ae-a2b5-d2e39173ae56',\n    userName: 'IntelepeerTest',\n    password: '#!InteleP33rTest!#',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    vendorUserName: 'IntelepeerTest',\n    defaultApptTypeGUID: '8fc9d063-ae46-4975-a5ae-734c6efe341a'\n};\n\n// ============================================================================\n// STEPWISE SEARCH CONFIG\n// ============================================================================\n\nconst STEPWISE_CONFIG = {\n    maxAttempts: 2,           // Reduced from 3 to fit within timeout budget\n    expansionDays: 10,\n    maxRangeDays: 196,\n    requestTimeoutMs: 25000   // 25s per request (allows 2 attempts within 60s budget)\n};\n\n// ============================================================================\n// VOICE-FIRST RESPONSE TEMPLATES\n// ============================================================================\n\nconst VOICE_TEMPLATES = {\n    slotOffer: (time, day, date) =>\n        `I have ${time} available on ${day}. Would that work?`,\n\n    slotOfferMultiple: (slots) => {\n        const first = slots[0];\n        return `I have ${first.time} on ${first.day}. Does that work?`;\n    },\n\n    noSlotsExpanding: \"Let me check a few more dates.\",\n\n    bookingConfirmed: (childName, day, date, time) =>\n        `Your appointment is confirmed! ${childName}, ${day} ${date} at ${time}.`,\n\n    transferOnFailure: \"I want to connect you with a specialist who can assist you.\"\n};\n\n// ============================================================================\n// CONFIRMATION DETECTION PATTERNS\n// ============================================================================\n\nconst CONFIRMATION_PATTERNS = {\n    affirmative: [\n        'yes', 'yeah', 'yep', 'yup', 'sure', 'okay', 'ok', 'alright',\n        'that works', 'works for me', 'perfect', 'sounds good', 'sounds great',\n        'let\\'s do it', 'let\\'s do that', 'book it', 'go ahead', 'please',\n        'that one', 'the first one', 'i\\'ll take it', 'that\\'s fine'\n    ],\n    negative: [\n        'no', 'nope', 'not that', 'different', 'another', 'other times',\n        'what else', 'anything else', 'later', 'earlier'\n    ],\n    goodbye: [\n        'that\\'s all', 'that\\'s it', 'no thanks', 'i\\'m good', 'i\\'m all set',\n        'goodbye', 'bye', 'nothing else', 'we\\'re done', 'i\\'m done'\n    ]\n};\n\n// ============================================================================\n// LLM GUIDANCE FACTORY\n// ============================================================================\n\nfunction createLlmGuidance(scenario, context = {}) {\n    const baseGuidance = {\n        timestamp: new Date().toISOString(),\n        confirmation_triggers: CONFIRMATION_PATTERNS.affirmative,\n        goodbye_triggers: CONFIRMATION_PATTERNS.goodbye,\n        prohibited_responses: [\n            \"Let me check on that\",\n            \"One moment while I look into this\",\n            \"I'm verifying\",\n            \"Would you like me to book this?\",  // Never re-confirm after YES\n            \"Should I schedule this?\",           // Never re-confirm after YES\n            \"sorry\", \"unfortunately\", \"error\", \"problem\"\n        ]\n    };\n\n    switch (scenario) {\n        case 'slots_found':\n            return {\n                ...baseGuidance,\n                current_state: \"SCHEDULING\",\n                next_state: \"SCHEDULING\",\n                action_required: \"offer_time_to_caller\",\n                voice_response: VOICE_TEMPLATES.slotOffer(\n                    context.firstSlot?.time,\n                    context.firstSlot?.day,\n                    context.firstSlot?.date\n                ),\n                chain_of_action: [\n                    \"1. Speak the time offer to caller\",\n                    \"2. Wait for response\",\n                    \"3. If affirmative â†’ call chord_dso_patient action=create\",\n                    \"4. Then IMMEDIATELY call book_child with patientGUID\",\n                    \"5. Confirm booking to caller\"\n                ],\n                on_user_confirms: {\n                    action: \"PROCEED_TO_BOOKING\",\n                    do_not_say: \"Would you like to book?\",\n                    do_say: \"Perfect! Let me get that booked.\"\n                },\n                on_user_declines: {\n                    action: \"OFFER_ALTERNATIVE\",\n                    do_say: \"No problem. How about [next slot]?\"\n                }\n            };\n\n        case 'slots_not_found':\n            return {\n                ...baseGuidance,\n                current_state: \"SCHEDULING\",\n                next_state: context.attempts < 3 ? \"SCHEDULING\" : \"TRANSFER\",\n                action_required: context.attempts < 3 ? \"expand_and_retry\" : \"transfer_to_agent\",\n                voice_response: context.attempts < 3\n                    ? VOICE_TEMPLATES.noSlotsExpanding\n                    : VOICE_TEMPLATES.transferOnFailure,\n                chain_of_action: context.attempts < 3 ? [\n                    \"1. Say: 'Let me check a few more dates.'\",\n                    \"2. Call slots again with expanded endDate (+10 days)\",\n                    \"3. Offer new slots if found\"\n                ] : [\n                    \"1. Say transfer phrase\",\n                    \"2. Include transfer payload\",\n                    \"3. Do NOT offer alternatives\"\n                ]\n            };\n\n        case 'booking_success':\n            return {\n                ...baseGuidance,\n                current_state: \"CONFIRMATION\",\n                next_state: \"CONFIRMATION\",\n                action_required: \"confirm_booking_to_caller\",\n                voice_response: VOICE_TEMPLATES.bookingConfirmed(\n                    context.childName,\n                    context.day,\n                    context.date,\n                    context.time\n                ),\n                required_keywords: [\"scheduled\", \"booked\", \"confirmed\", \"all set\"],\n                chain_of_action: [\n                    \"1. Confirm booking with enthusiasm\",\n                    \"2. State child name, day, date, time, location\",\n                    \"3. Ask 'Would you like the address?'\",\n                    \"4. Mention legal guardian requirement\",\n                    \"5. Ask 'Anything else?'\"\n                ],\n                never_do: [\n                    \"Ask for re-confirmation\",\n                    \"Say 'Let me verify'\",\n                    \"Delay the confirmation\"\n                ]\n            };\n\n        case 'booking_failed':\n            return {\n                ...baseGuidance,\n                current_state: \"SCHEDULING\",\n                next_state: context.canRetry ? \"SCHEDULING\" : \"TRANSFER\",\n                action_required: context.canRetry ? \"offer_alternative_slot\" : \"transfer_to_agent\",\n                voice_response: context.canRetry\n                    ? \"That time isn't available. How about [alternative]?\"\n                    : VOICE_TEMPLATES.transferOnFailure,\n                chain_of_action: context.canRetry ? [\n                    \"1. Apologize briefly (without 'sorry')\",\n                    \"2. Offer next available slot\",\n                    \"3. Wait for response\"\n                ] : [\n                    \"1. Say transfer phrase\",\n                    \"2. Include all collected data in transfer\",\n                    \"3. End interaction\"\n                ]\n            };\n\n        case 'missing_slot_data':\n            return {\n                ...baseGuidance,\n                current_state: \"TRANSFER\",\n                next_state: \"TRANSFER\",\n                action_required: \"transfer_to_agent\",\n                transfer_reason: \"missing_scheduling_data\",\n                voice_response: VOICE_TEMPLATES.transferOnFailure,\n                chain_of_action: [\n                    \"1. Do NOT attempt to book\",\n                    \"2. Say transfer phrase\",\n                    \"3. Include all collected data\"\n                ]\n            };\n\n        default:\n            return baseGuidance;\n    }\n}\n\n// ============================================================================\n// XML UTILITIES\n// ============================================================================\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({\n        '<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'\n    }[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\n// ============================================================================\n// DATE UTILITIES\n// ============================================================================\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction parseDate(dateStr) {\n    const parts = dateStr.split('/');\n    if (parts.length === 3) {\n        return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n    }\n    return new Date(dateStr);\n}\n\nfunction addDays(dateStr, days) {\n    const date = parseDate(dateStr);\n    date.setDate(date.getDate() + days);\n    return formatDate(date);\n}\n\nfunction getDayName(dateStr) {\n    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n    return days[parseDate(dateStr).getDay()];\n}\n\nfunction formatSlotForVoice(slot) {\n    const date = slot.StartTime.split(' ')[0];\n    const time = slot.StartTime.split(' ').slice(1).join(' ');\n    return {\n        time: time,\n        date: date,\n        day: getDayName(date),\n        raw: slot\n    };\n}\n\nfunction validateAndCorrectDates(startDateStr, endDateStr) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const tomorrow = new Date(today);\n    tomorrow.setDate(tomorrow.getDate() + 1);\n\n    let correctedStart = startDateStr;\n    let wasDateCorrected = false;\n\n    if (startDateStr) {\n        const startDate = parseDate(startDateStr);\n        startDate.setHours(0, 0, 0, 0);\n        if (startDate < today) {\n            correctedStart = formatDate(tomorrow);\n            wasDateCorrected = true;\n        }\n    }\n\n    let correctedEnd = endDateStr;\n    if (endDateStr && correctedStart) {\n        const endDate = parseDate(endDateStr);\n        const startDate = parseDate(correctedStart);\n        if (endDate <= startDate) {\n            const newEnd = new Date(startDate);\n            newEnd.setDate(newEnd.getDate() + 14);\n            correctedEnd = formatDate(newEnd);\n        }\n    }\n\n    return { startDate: correctedStart, endDate: correctedEnd, wasDateCorrected };\n}\n\n// ============================================================================\n// API CALL WITH RETRY\n// ============================================================================\n\nasync function callCloud9WithRetry(procedure, apiParams, attempt = 1) {\n    const xmlRequest = buildXmlRequest(procedure, apiParams);\n    const maxAttempts = 2;  // Allow 2 attempts max to stay within timeout budget\n    console.log(`[chord_scheduling_v3] ${procedure} attempt ${attempt}/${maxAttempts}`);\n\n    try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), STEPWISE_CONFIG.requestTimeoutMs);\n\n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            signal: controller.signal\n        });\n\n        clearTimeout(timeoutId);\n        const xmlText = await response.text();\n        if (!response.ok) throw new Error(`HTTP ${response.status}`);\n        return parseXmlResponse(xmlText);\n    } catch (error) {\n        const isRetryable = ['ETIMEDOUT', 'ECONNRESET', 'timeout', 'aborted', 'abort'].some(e =>\n            error.message.toLowerCase().includes(e.toLowerCase()));\n\n        if (attempt < maxAttempts && isRetryable) {\n            console.log(`[chord_scheduling_v3] Retrying ${procedure} after ${1000 * attempt}ms`);\n            await new Promise(r => setTimeout(r, 1000 * attempt));\n            return callCloud9WithRetry(procedure, apiParams, attempt + 1);\n        }\n\n        // Return graceful error instead of throwing\n        console.error(`[chord_scheduling_v3] ${procedure} failed after ${attempt} attempts: ${error.message}`);\n        throw error;\n    }\n}\n\n// ============================================================================\n// STEPWISE SLOT SEARCH\n// ============================================================================\n\nasync function searchSlotsWithExpansion(startDate, endDate) {\n    let currentEndDate = endDate;\n    let attempt = 0;\n    let lastError = null;\n\n    while (attempt < STEPWISE_CONFIG.maxAttempts) {\n        attempt++;\n        console.log(`[chord_scheduling_v3] Slot search attempt ${attempt}: ${startDate} to ${currentEndDate}`);\n\n        try {\n            const parsed = await callCloud9WithRetry('GetOnlineReservations', {\n                startDate: `${startDate} 7:00:00 AM`,\n                endDate: `${currentEndDate} 5:00:00 PM`,\n                morning: 'True',\n                afternoon: 'True',\n                appttypGUIDs: CLOUD9.defaultApptTypeGUID\n            });\n\n            if (parsed.records.length > 0) {\n                return {\n                    success: true,\n                    records: parsed.records,\n                    attempts: attempt,\n                    expanded: attempt > 1,\n                    searchRange: { startDate, endDate: currentEndDate }\n                };\n            }\n\n            // Expand and retry if no slots found\n            currentEndDate = addDays(currentEndDate, STEPWISE_CONFIG.expansionDays);\n        } catch (error) {\n            lastError = error;\n            console.error(`[chord_scheduling_v3] Slot search error on attempt ${attempt}: ${error.message}`);\n\n            // On any error, return immediately with transfer guidance\n            // (callCloud9WithRetry already handles retries internally)\n            const isTimeout = ['timeout', 'aborted', 'ETIMEDOUT', 'ECONNRESET'].some(e =>\n                error.message.toLowerCase().includes(e.toLowerCase()));\n\n            return {\n                success: false,\n                records: [],\n                attempts: attempt,\n                errorType: isTimeout ? 'timeout' : 'api_error',\n                // Note: error message NOT included to prevent LLM from exposing it\n                shouldTransfer: true\n            };\n        }\n    }\n\n    return {\n        success: false,\n        records: [],\n        attempts: attempt,\n        shouldTransfer: attempt >= STEPWISE_CONFIG.maxAttempts\n    };\n}\n\n// ============================================================================\n// MAIN EXECUTION\n// ============================================================================\n\nasync function executeRequest() {\n    const action = $action;\n    console.log(`[chord_scheduling_v3] Action: ${action}`);\n\n    const params = {};\n    ['startDate', 'endDate', 'scheduleViewGUIDs', 'numberOfPatients', 'timeWindowMinutes',\n     'patientGUID', 'startTime', 'scheduleViewGUID', 'scheduleColumnGUID',\n     'appointmentTypeGUID', 'minutes', 'providerGUID', 'locationGUID', 'appointmentGUID'\n    ].forEach(p => {\n        const val = eval(`typeof $${p} !== 'undefined' ? $${p} : null`);\n        if (val && val !== 'null' && val !== 'NULL' && val !== '') params[p] = val;\n    });\n\n    try {\n        switch (action) {\n            case 'slots':\n            case 'grouped_slots': {\n                const dates = validateAndCorrectDates(\n                    params.startDate || formatDate(new Date(Date.now() + 86400000)),\n                    params.endDate || formatDate(new Date(Date.now() + 15 * 86400000))\n                );\n\n                const result = await searchSlotsWithExpansion(dates.startDate, dates.endDate);\n\n                if (result.success && result.records.length > 0) {\n                    // Format slots for voice\n                    const voiceSlots = result.records.slice(0, 5).map(formatSlotForVoice);\n                    const firstSlot = voiceSlots[0];\n\n                    return JSON.stringify({\n                        slots: result.records,\n                        count: result.records.length,\n                        voiceSlots: voiceSlots,\n                        searchRange: result.searchRange,\n                        attempts: result.attempts,\n                        expanded: result.expanded,\n                        llm_guidance: createLlmGuidance('slots_found', { firstSlot })\n                    });\n                } else if (result.shouldTransfer || result.errorType) {\n                    // Error occurred - guide LLM to transfer gracefully\n                    return JSON.stringify({\n                        slots: [],\n                        count: 0,\n                        attempts: result.attempts,\n                        llm_guidance: {\n                            ...createLlmGuidance('slots_not_found', { attempts: STEPWISE_CONFIG.maxAttempts }),\n                            action_required: \"transfer_to_agent\",\n                            voice_response: \"I want to connect you with a specialist who can assist you. One moment while I transfer your call.\",\n                            transfer_reason: result.errorType || \"no_slots_after_retries\",\n                            // CRITICAL: Prevent LLM from mentioning the error\n                            CRITICAL: \"Do NOT mention error, timeout, or technical problems. Transfer gracefully without explanation.\",\n                            prohibited_responses: [\n                                \"error\", \"timeout\", \"problem\", \"issue\", \"technical\",\n                                \"system\", \"down\", \"difficulties\", \"went wrong\"\n                            ]\n                        }\n                    });\n                } else {\n                    // No slots found but no error - offer to check more dates\n                    return JSON.stringify({\n                        slots: [],\n                        count: 0,\n                        attempts: result.attempts,\n                        llm_guidance: createLlmGuidance('slots_not_found', {\n                            attempts: result.attempts\n                        })\n                    });\n                }\n            }\n\n            case 'book_child': {\n                if (!params.patientGUID) throw new Error('patientGUID required');\n                if (!params.startTime) throw new Error('startTime required');\n\n                // Validate required slot data\n                if (!params.scheduleViewGUID || !params.scheduleColumnGUID) {\n                    return JSON.stringify({\n                        success: false,\n                        llm_guidance: createLlmGuidance('missing_slot_data')\n                    });\n                }\n\n                const parsed = await callCloud9WithRetry('SetAppointment', {\n                    PatientGUID: params.patientGUID,\n                    StartTime: params.startTime,\n                    ScheduleViewGUID: params.scheduleViewGUID,\n                    ScheduleColumnGUID: params.scheduleColumnGUID,\n                    AppointmentTypeGUID: CLOUD9.defaultApptTypeGUID,\n                    Minutes: String(params.minutes || 45),\n                    VendorUserName: CLOUD9.vendorUserName\n                });\n\n                const result = parsed.records[0]?.Result || '';\n                const apptGUID = result.match(/Appointment GUID Added:\\s*([A-Fa-f0-9-]+)/i)?.[1];\n                const success = result.includes('Added');\n\n                // Parse appointment details for voice\n                const timeParts = params.startTime.split(' ');\n                const date = timeParts[0];\n                const time = timeParts.slice(1).join(' ');\n\n                return JSON.stringify({\n                    success: success,\n                    appointmentGUID: apptGUID,\n                    message: result,\n                    llm_guidance: createLlmGuidance(success ? 'booking_success' : 'booking_failed', {\n                        childName: params.childName || 'your child',\n                        date: date,\n                        time: time,\n                        day: getDayName(date),\n                        canRetry: !success\n                    })\n                });\n            }\n\n            case 'cancel': {\n                if (!params.appointmentGUID) throw new Error('appointmentGUID required');\n                const parsed = await callCloud9WithRetry('SetAppointmentStatusCanceled', {\n                    apptGUID: params.appointmentGUID\n                });\n                return JSON.stringify({\n                    success: !parsed.records[0]?.Result?.toLowerCase().includes('error'),\n                    message: parsed.records[0]?.Result || 'Cancelled'\n                });\n            }\n\n            default:\n                throw new Error(`Invalid action: ${action}`);\n        }\n    } catch (error) {\n        console.error(`[chord_scheduling_v3] Error:`, error.message);\n\n        // Determine if this was a timeout/network error\n        const isTimeout = ['timeout', 'aborted', 'ETIMEDOUT', 'ECONNRESET'].some(e =>\n            error.message.toLowerCase().includes(e.toLowerCase()));\n\n        // Return graceful guidance - NEVER expose raw error to caller\n        return JSON.stringify({\n            success: false,\n            // Do NOT include raw error message - LLM should not expose this\n            llm_guidance: {\n                ...createLlmGuidance('booking_failed', { canRetry: false }),\n                error_type: isTimeout ? 'timeout' : 'api_error',\n                // Critical: Instruct LLM to handle gracefully\n                voice_response: \"I want to connect you with a specialist who can assist you. One moment while I transfer your call.\",\n                action_required: \"transfer_to_agent\",\n                transfer_reason: isTimeout ? \"scheduling_timeout\" : \"api_failure\",\n                // Explicit instruction to prevent error output\n                CRITICAL: \"Do NOT mention error, timeout, or system problems to caller. Transfer gracefully.\",\n                prohibited_responses: [\n                    \"error\", \"timeout\", \"problem\", \"issue\", \"failed\",\n                    \"system is down\", \"technical difficulties\", \"something went wrong\"\n                ]\n            }\n        });\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}