[
    {
        "id": "cb091dda25252c01",
        "type": "tab",
        "label": "Chord-NexHealth",
        "disabled": false,
        "info": "",
        "env": [
            {
                "name": "subdomainSand",
                "value": "cdm",
                "type": "str"
            },
            {
                "name": "subdomainProd",
                "value": "cdm",
                "type": "str"
            },
            {
                "name": "providerIdSand",
                "value": "421458314",
                "type": "str"
            },
            {
                "name": "providerIdProd",
                "value": "223076809",
                "type": "str"
            },
            {
                "name": "locationIdSand",
                "value": "333725",
                "type": "str"
            },
            {
                "name": "locationIdProd",
                "value": "77523",
                "type": "str"
            },
            {
                "name": "phoneNumber",
                "value": "3218675309",
                "type": "str"
            },
            {
                "name": "providerId",
                "value": "providerIdProd",
                "type": "env"
            },
            {
                "name": "locationId",
                "value": "locationIdProd",
                "type": "env"
            },
            {
                "name": "apiKey",
                "value": "dXNlci0yNzQtcHJvZHVjdGlvbg.eqAjEe1KyadP0pZ56bNbULBObZG3VKqU",
                "type": "str"
            },
            {
                "name": "patientId",
                "value": "428717317",
                "type": "str"
            },
            {
                "name": "subdomain",
                "value": "subdomainProd",
                "type": "env"
            },
            {
                "name": "maxApptSlots",
                "value": "50",
                "type": "num"
            },
            {
                "name": "maxApptSlotsOverlapping",
                "value": "100",
                "type": "str"
            }
        ]
    },
    {
        "id": "e1a21f43e6e5d2bd",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "NULL PATIENT - DANGER ",
        "style": {
            "stroke": "#000000",
            "fill": "#ff3f3f",
            "label": true,
            "color": "#ffffff"
        },
        "nodes": [
            "13c2f93b78c5a7d6",
            "dcb0e8805bad0671",
            "d05d41ec0768b654",
            "562472209a90a58e",
            "4818e6bd5bb4504f",
            "56fc2e5457f9f2af",
            "7cc5862cb2a23f7c",
            "4ce1390c1c13ad57",
            "f35fb5671e7b3223"
        ],
        "x": 74,
        "y": 3119,
        "w": 1072,
        "h": 122
    },
    {
        "id": "8912dadd9ad9094d",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "getApptSlots",
        "style": {
            "label": true,
            "color": "#ffffff",
            "fill": "#addb7b"
        },
        "nodes": [
            "de2ddbee35e7601b",
            "5e6d28d59d07ec5b",
            "cdf59990ea1dc80c",
            "0bb08d8bed12b310",
            "1aa4311d64416e61",
            "2b456a8c2ad64a14",
            "8282c8c9f45bb754",
            "8e83fa56678a1331",
            "56ee0b68b8b48848",
            "b25b992651ad9d6b",
            "4d74ba579ef66846",
            "26300057398b209c",
            "ce39e9472e76eb3e"
        ],
        "x": 64,
        "y": 899,
        "w": 1422,
        "h": 182
    },
    {
        "id": "6282d2c22d141111",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "getGroupedApptSlots",
        "style": {
            "fill": "#92d04f",
            "label": true,
            "color": "#ffffff"
        },
        "nodes": [
            "1a6a877ef6bbb534",
            "6da3bdc196eaabe5",
            "22ce6f882a82abb2",
            "c98fb9e6c18da833",
            "19da52b8bb9879a1",
            "de66f77742809b64",
            "cde03e5db1227091",
            "fe8d041c17561655",
            "a367888d745765fb",
            "dbaecfb7ced92ed9",
            "5a0c4c38c8525ba3",
            "e211e5722f86e26b",
            "d40e6e5eba28dffe",
            "ed3fd28e71f9da76",
            "a64f7a25eac76243",
            "b2792488e4a6f247"
        ],
        "x": 54,
        "y": 1139,
        "w": 1932,
        "h": 162
    },
    {
        "id": "47b76f2157d33f68",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "Get Appointment Types",
        "style": {
            "fill": "#b797cf",
            "label": true,
            "color": "#ffffff"
        },
        "nodes": [
            "2334696f7e7a1b88",
            "b19458dc88b6af84",
            "3e3ef37154695dd1"
        ],
        "x": 74,
        "y": 2959,
        "w": 592,
        "h": 82
    },
    {
        "id": "a372f53aad09888a",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "Get Insurance Plans",
        "style": {
            "fill": "#b797cf",
            "label": true,
            "color": "#ffffff"
        },
        "nodes": [
            "112ffa2fe18b9448",
            "62dd58bba415f00d",
            "da286309356ac2fe"
        ],
        "x": 714,
        "y": 2959,
        "w": 592,
        "h": 82
    },
    {
        "id": "f9ed3759d3ab4cf8",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "GetPatientByPatientId",
        "style": {
            "label": true
        },
        "nodes": [
            "e4399373da2f9f5e",
            "2f57a2f0f2c9186f",
            "31b309561adc169e",
            "c74d3d53b0323805",
            "53b8941e29e2db6f",
            "6600557958d878e1",
            "51c6f07ac929e691",
            "17ae79259ea74777",
            "42f2271bf7d0c7e1",
            "dbfdafad659a5e4a"
        ],
        "x": 1564,
        "y": 139,
        "w": 1162,
        "h": 122
    },
    {
        "id": "712c1fe569af7e6d",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "GetPatientByPhone",
        "style": {
            "label": true,
            "fill": "#3f93cf",
            "color": "#ffffff"
        },
        "nodes": [
            "f3ea80c4d43a7e49",
            "1602520a629897ac",
            "f840c1c595d1fe2b",
            "182759a7f1d80d75",
            "e51b295556726df3",
            "9c3d1c02ed2c51d0",
            "7b1422ce1e8ee8f0",
            "77fe085b21a772eb",
            "6005bfd25271cf84",
            "fe22213d34bf536c",
            "93492add994e91e4",
            "d5ca0a376ceeea89",
            "9680fe37f534791c"
        ],
        "x": 114,
        "y": 339,
        "w": 1292,
        "h": 182
    },
    {
        "id": "0fb2feb44514306f",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "GetPatientByEmail",
        "style": {
            "label": true
        },
        "nodes": [
            "4ae654ff0152fe6b",
            "93d8deb456796648",
            "0a6333d2d0c09d51",
            "bf15e1acbfa06939",
            "4625dd1161a71643",
            "0e6e750bd7305240",
            "3c29fbe0f6421974",
            "4838d0bef9c86f85",
            "7eb21a1ba101e779",
            "12fab74e303e40ca",
            "23772f57e7dfb85f",
            "55642a32a0a57d99"
        ],
        "x": 94,
        "y": 139,
        "w": 1372,
        "h": 182
    },
    {
        "id": "499a28b954ecb5bb",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "getPatientAppts",
        "style": {
            "label": true,
            "color": "#777777",
            "fill": "#c8e7a7"
        },
        "nodes": [
            "007e046836494ebe",
            "804c6d634810d2a5",
            "fc8ac68df269e529",
            "c47fb246ec515c12",
            "4ab8dc9913913c62",
            "8a2f0f010e9acb12",
            "d2ba7b687348cb9e",
            "6e8029b299e0062a",
            "83dede7b863766d4",
            "266937cfdb2f8b33",
            "10e51a46931c7be2",
            "ab58cd62893bff53",
            "d0269b54e1f28ae7",
            "8331a48e2263763c",
            "75c89f53ecc25321"
        ],
        "x": 64,
        "y": 639,
        "w": 1482,
        "h": 222
    },
    {
        "id": "5c665bc565f3fd82",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "CancelAppt",
        "style": {
            "label": true,
            "fill": "#e3f3d3"
        },
        "nodes": [
            "3132feabace0025f",
            "0c11e9e473840c15",
            "b85a0e8af4032faf",
            "5682ca6fadd2bb9a",
            "e2eb2833bb803f91",
            "ecd53087f3ee7fa5",
            "e35067c70c9706fb",
            "9c203c1f6522a682",
            "4c0345908803bea4"
        ],
        "x": 54,
        "y": 2159,
        "w": 1112,
        "h": 122
    },
    {
        "id": "baaf85afce595f5f",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "ConfirmAppt",
        "style": {
            "label": true,
            "fill": "#e3f3d3"
        },
        "nodes": [
            "8bf1658aceca2d71",
            "a9d53317ca1de2f7",
            "096e06bb70d82ec5",
            "26a444411f61c09f",
            "5f5cf1f8375fd5b8",
            "4cd7185e1650fa8a",
            "13eb1e488c3796e9"
        ],
        "x": 54,
        "y": 2339,
        "w": 1072,
        "h": 122
    },
    {
        "id": "730bdee0925a4184",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "CreatePatient",
        "style": {
            "label": true,
            "fill": "#0070c0",
            "color": "#ffffff"
        },
        "nodes": [
            "cf208737b8e69c2b",
            "561df1dfdb7c522c",
            "cfb61a13bb81723c",
            "80705f4510abd3e0",
            "9463e8541c653c27",
            "ecc65b4adf9b677d",
            "8b80bf786e1c1d33",
            "d0092387f9cb86a2",
            "e1226d731376d750"
        ],
        "x": 64,
        "y": 2499,
        "w": 1262,
        "h": 162
    },
    {
        "id": "b2d67743184cc26e",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "Deprecated Other types of appts",
        "style": {
            "label": true
        },
        "nodes": [
            "79bd1cc5e54c80d7",
            "c2189159710e251a",
            "52d22ed0195d7c8a",
            "63c15979bef0de96",
            "6c6b4c49f88af363",
            "205dfc6604d35e3e",
            "bc61b018ea9d38b5",
            "040125ecfc531030",
            "a9e8241b92aae854",
            "3cdfad76847824e6",
            "114c1eb6cebe0dfe",
            "305bfd6f029418f3",
            "baba64677c81a5f4",
            "dfa5bbf79b09f450",
            "16255887a7d25a4f",
            "8a1905e18839e671",
            "7356633aed44023a",
            "6d8df77c8ad35b6b"
        ],
        "x": 1894,
        "y": 1519,
        "w": 1392,
        "h": 382
    },
    {
        "id": "7375dac1352eefcb",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "GetLocation",
        "style": {
            "label": true,
            "fill": "#a4a4a4",
            "color": "#ffffff"
        },
        "nodes": [
            "14e9b9f9e6b846fb",
            "8c230b9d2435e680",
            "3ba1fad23a5cb964",
            "58b46383a7cab2ca",
            "e926510bf2efba77",
            "4101412b851fce41",
            "fcc6bfb2aea05f82",
            "63626ca29ccfda8e",
            "b01dca98098a4293",
            "8be41de85b2f7b6e",
            "607df74a9384e68d"
        ],
        "x": 34,
        "y": 1879,
        "w": 1392,
        "h": 162
    },
    {
        "id": "934e7067c60517f2",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "CreateAppt",
        "style": {
            "label": true,
            "fill": "#e3f3d3",
            "color": "#777777"
        },
        "nodes": [
            "fc6a683eed0b6de7",
            "48d519a374f4332d",
            "5f5550a84835b02c",
            "1476be69d5af1e85",
            "9cb641266f3b2c26",
            "f86307f2bd42a986",
            "abd2a679ee994abc",
            "1df75ccc2ca60061",
            "8a35fb512ca3562c",
            "ce98930e10a62ffe",
            "7582f8f3cb420cbc",
            "c56b15f387d9cb2a",
            "948d7f2678a68bfa",
            "5d0d05d9d9b8e123"
        ],
        "x": 34,
        "y": 1359,
        "w": 1572,
        "h": 202
    },
    {
        "id": "fa6c90989b81f095",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "Get Payments",
        "style": {
            "fill": "#3f3f3f",
            "label": true,
            "color": "#ffffff"
        },
        "nodes": [
            "08b04d2fa7ec4bba",
            "b7f02451dfdd1e3c",
            "6f6cefdc8bf1a800",
            "898a645711dd0925",
            "6cbbc4eeb860682c"
        ],
        "x": 84,
        "y": 3379,
        "w": 902,
        "h": 142
    },
    {
        "id": "058e8eeb7d55776a",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "CreateChildAppt",
        "style": {
            "label": true,
            "fill": "#3f93cf",
            "color": "#ffffff"
        },
        "nodes": [
            "2bf88d8e27c8845e",
            "4529dc67ef023a24",
            "e2879838ddc5c0a4",
            "fc5398a0b2cde9f0",
            "024d2d34aa8b528d",
            "f912a63cf4fee944",
            "ef3a424d1b4deaae",
            "6637def903adec31",
            "ccf30b19041c58f4",
            "6c34ab1ffb06eae2",
            "e9241c198db2f385"
        ],
        "x": 44,
        "y": 1639,
        "w": 1662,
        "h": 182
    },
    {
        "id": "f981b1c14633130a",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "EditPatientInsurance",
        "style": {
            "label": true,
            "fill": "#3f93cf",
            "color": "#ffffff"
        },
        "nodes": [
            "a1f34f82a22e7450",
            "43caccec5fbb1d7b",
            "88cf081c7d5609c2",
            "9f4e824644d1d389",
            "dbd0d16e591a7343",
            "bd07c44a370ae0f8",
            "a01cc523c75d0b7c",
            "1efffca56bfbbb63"
        ],
        "x": 54,
        "y": 2699,
        "w": 1312,
        "h": 122
    },
    {
        "id": "5013cdec34e6a01e",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "GetAppointment",
        "style": {
            "label": true,
            "fill": "#e3f3d3"
        },
        "nodes": [
            "833982824e3d44a5",
            "f5ee8fbba2beea3a",
            "e528e03f3269879f",
            "e6ecf1b49bbb8002",
            "481b499410d9bd0b",
            "61f1fca8164c27dc",
            "1ce1d4f4274f6222",
            "73100eea61cea72d",
            "973139af2b430bd0"
        ],
        "x": 134,
        "y": 3639,
        "w": 1152,
        "h": 122
    },
    {
        "id": "4ab53e735c8a8bbf",
        "type": "group",
        "z": "cb091dda25252c01",
        "name": "GetPatientByLastName",
        "style": {
            "label": true
        },
        "nodes": [
            "3a1f6826e414ea73",
            "766016634b41b326",
            "993e4a8ff84c663d",
            "48e11d5b5dfe1731",
            "fed7a803176396ca",
            "9ea62f09a13d9973",
            "34497ab544b665d5",
            "10ef4f8903704779"
        ],
        "x": 1814,
        "y": 319,
        "w": 1132,
        "h": 162
    },
    {
        "id": "4c0345908803bea4",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "x": 460,
        "y": 2240,
        "wires": [
            [
                "9c203c1f6522a682",
                "e35067c70c9706fb"
            ]
        ]
    },
    {
        "id": "13eb1e488c3796e9",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "baaf85afce595f5f",
        "x": 460,
        "y": 2420,
        "wires": [
            [
                "4cd7185e1650fa8a",
                "5f5cf1f8375fd5b8"
            ]
        ]
    },
    {
        "id": "d0092387f9cb86a2",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "x": 480,
        "y": 2580,
        "wires": [
            [
                "561df1dfdb7c522c",
                "8b80bf786e1c1d33"
            ]
        ]
    },
    {
        "id": "55642a32a0a57d99",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "x": 540,
        "y": 180,
        "wires": [
            [
                "23772f57e7dfb85f",
                "0a6333d2d0c09d51"
            ]
        ]
    },
    {
        "id": "9680fe37f534791c",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "x": 660,
        "y": 440,
        "wires": [
            [
                "d5ca0a376ceeea89",
                "9c3d1c02ed2c51d0"
            ]
        ]
    },
    {
        "id": "8331a48e2263763c",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "x": 500,
        "y": 760,
        "wires": [
            [
                "d0269b54e1f28ae7",
                "fc8ac68df269e529"
            ]
        ]
    },
    {
        "id": "ce39e9472e76eb3e",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "x": 480,
        "y": 1000,
        "wires": [
            [
                "26300057398b209c",
                "cdf59990ea1dc80c"
            ]
        ]
    },
    {
        "id": "b2792488e4a6f247",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "x": 500,
        "y": 1220,
        "wires": [
            [
                "a64f7a25eac76243",
                "1a6a877ef6bbb534"
            ]
        ]
    },
    {
        "id": "5d0d05d9d9b8e123",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "x": 440,
        "y": 1420,
        "wires": [
            [
                "948d7f2678a68bfa",
                "ce98930e10a62ffe"
            ]
        ]
    },
    {
        "id": "607df74a9384e68d",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "x": 440,
        "y": 1960,
        "wires": [
            [
                "e926510bf2efba77",
                "8be41de85b2f7b6e"
            ]
        ]
    },
    {
        "id": "6c34ab1ffb06eae2",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "x": 500,
        "y": 1680,
        "wires": [
            [
                "ccf30b19041c58f4",
                "ef3a424d1b4deaae"
            ]
        ]
    },
    {
        "id": "1efffca56bfbbb63",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "x": 520,
        "y": 2780,
        "wires": [
            [
                "43caccec5fbb1d7b",
                "a01cc523c75d0b7c"
            ]
        ]
    },
    {
        "id": "973139af2b430bd0",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "x": 540,
        "y": 3720,
        "wires": [
            [
                "73100eea61cea72d",
                "1ce1d4f4274f6222"
            ]
        ]
    },
    {
        "id": "34497ab544b665d5",
        "type": "junction",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "x": 2000,
        "y": 360,
        "wires": [
            [
                "766016634b41b326",
                "9ea62f09a13d9973"
            ]
        ]
    },
    {
        "id": "9cb641266f3b2c26",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "",
        "url": "/chord/createAppt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 1480,
        "wires": [
            [
                "5d0d05d9d9b8e123"
            ]
        ]
    },
    {
        "id": "0c11e9e473840c15",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "",
        "url": "/chord/cancelAppt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 250,
        "y": 2240,
        "wires": [
            [
                "4c0345908803bea4"
            ]
        ]
    },
    {
        "id": "cdf59990ea1dc80c",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "IngressApptSlots",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 570,
        "y": 940,
        "wires": []
    },
    {
        "id": "ce98930e10a62ffe",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "IngressCreateAppt",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 570,
        "y": 1420,
        "wires": []
    },
    {
        "id": "e35067c70c9706fb",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "IngressCancelAppt",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 2200,
        "wires": []
    },
    {
        "id": "1aa4311d64416e61",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "",
        "props": [
            {
                "p": "payload.uui",
                "v": "�\b,\u0007\u0005i8l2765305129-000000000001105456-SR-000-000000000000DEN140-5AA00C14|333725|421458314VO|6733e082-0129-4e68-97dc-bd8b71aa02a6|FSV",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 170,
        "y": 940,
        "wires": [
            [
                "ce39e9472e76eb3e"
            ]
        ]
    },
    {
        "id": "8282c8c9f45bb754",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1370,
        "y": 1000,
        "wires": []
    },
    {
        "id": "5f5550a84835b02c",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "createAppt Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 1420,
        "wires": []
    },
    {
        "id": "3132feabace0025f",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "cancelAppt Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 2240,
        "wires": []
    },
    {
        "id": "b85a0e8af4032faf",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "",
        "props": [
            {
                "p": "payload.appointmentId",
                "v": "1131315368",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 310,
        "y": 2200,
        "wires": [
            [
                "4c0345908803bea4"
            ]
        ]
    },
    {
        "id": "fc6a683eed0b6de7",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1350,
        "y": 1480,
        "wires": []
    },
    {
        "id": "e2eb2833bb803f91",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 850,
        "y": 2240,
        "wires": []
    },
    {
        "id": "007e046836494ebe",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "",
        "url": "/chord/getPatientAppts",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 270,
        "y": 760,
        "wires": [
            [
                "8331a48e2263763c"
            ]
        ]
    },
    {
        "id": "804c6d634810d2a5",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "getPatientAppts",
        "func": "// Node-RED Function Node - Get Patient Appointments\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n//const providerId = msg.payload.providerId || env.get(\"providerId\");\n//const locationId = msg.payload.locationId || env.get(\"locationId\");\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst patientId = msg.payload.patientId;\nconst subdomain = msg.payload.subdomain || \"cdm\";\nconst cancelled = msg.payload.cancelled !== undefined ? msg.payload.cancelled : false;\n\n// Helper function to format date as YYYY-MM-DD\nconst formatDate = (date) => {\n    const d = new Date(date);\n    const year = d.getFullYear();\n    const month = String(d.getMonth() + 1).padStart(2, '0');\n    const day = String(d.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n};\n\n// Date range parameters (default to today and ~14 months from today in YYYY-MM-DD format)\nconst startDate = msg.payload.startDate || msg.startDate || formatDate(new Date());\nconst endDate = msg.payload.endDate || msg.endDate || formatDate(new Date(Date.now() + 425 * 24 * 60 * 60 * 1000));\n\n// Provider IDs filter - can be array or single value\n// Get from msg.payload.providerIds, msg.providerIds, or env variable\nlet providerIds = msg.payload.providerIds || msg.providerIds;\nif (!providerIds && providerId) {\n    providerIds = [providerId];\n}\nif (!Array.isArray(providerIds) && providerIds) {\n    providerIds = [providerIds];\n}\nif (!providerIds) {\n    providerIds = null; // Don't send provider filter if not specified\n}\n\nasync function getPatientAppointments() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Validate date formats\n        const startDateObj = new Date(startDate);\n        const endDateObj = new Date(endDate);\n        if (isNaN(startDateObj.getTime())) {\n            throw new Error('Invalid start date format. Expected YYYY-MM-DD format.');\n        }\n        if (isNaN(endDateObj.getTime())) {\n            throw new Error('Invalid end date format. Expected YYYY-MM-DD format.');\n        }\n\n        // First, authenticate to get the token\n        node.warn('Authenticating...');\n        const requestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": apiKey\n            },\n            redirect: \"follow\"\n        };\n\n        const authResponse = await fetch(\"https://nexhealth.info/authenticates\", requestOptions);\n\n        // Check for HTTP errors\n        if (!authResponse.ok) {\n            const errorText = await authResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Authentication failed with status ${authResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate authentication response\n        let authResult;\n        try {\n            authResult = await authResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse authentication response: ${parseError.message}`);\n        }\n\n        node.warn('Auth response received');\n\n        if (!authResult.data || !authResult.data.token) {\n            throw new Error('Authentication token not found in response. Response structure may have changed.');\n        }\n\n        const authToken = authResult.data.token;\n\n        // Build query parameters manually to match Postman format\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `start=${encodeURIComponent(startDate)}`,\n            `end=${encodeURIComponent(endDate)}`,\n            `cancelled=${encodeURIComponent(cancelled)}`,\n            `patient_id=${encodeURIComponent(patientId)}`,\n            `location_id=${encodeURIComponent(locationId)}`\n        ];\n\n        // Add provider IDs to query params (optional - only if specified)\n        if (providerIds && Array.isArray(providerIds)) {\n            providerIds.forEach(id => {\n                queryParts.push(`provider_ids[]=${encodeURIComponent(id)}`);\n            });\n        }\n\n        // Build the full URL with query parameters\n        const url = `https://nexhealth.info/appointments?${queryParts.join('&')}`;\n\n        const apptRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching patient appointments...');\n        const apptResponse = await fetch(url, apptRequestOptions);\n\n        // Check for HTTP errors\n        if (!apptResponse.ok) {\n            const errorText = await apptResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointments failed with status ${apptResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate appointments response\n        let result;\n        try {\n            result = await apptResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointments response: ${parseError.message}`);\n        }\n\n        node.warn('Appointments retrieved successfully');\n        node.warn(result);\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        const appointments = result.data;\n        const count = Array.isArray(appointments) ? appointments.length : 0;\n        node.warn(`Found ${count} appointment(s)`);\n\n        // Set the payload with results (just the appointments array)\n        msg.payload = appointments;\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patient appointments: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while retrieving appointments',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getPatientAppointments();\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 1000,
        "y": 820,
        "wires": [
            [
                "4ab8dc9913913c62",
                "d2ba7b687348cb9e"
            ]
        ]
    },
    {
        "id": "fc8ac68df269e529",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "IngressPatientAppts",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 720,
        "wires": []
    },
    {
        "id": "c47fb246ec515c12",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "Philly",
        "props": [
            {
                "p": "payload.patientId",
                "v": "435619532",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u00075i9��765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 370,
        "y": 720,
        "wires": [
            [
                "8331a48e2263763c"
            ]
        ]
    },
    {
        "id": "4ab8dc9913913c62",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1430,
        "y": 700,
        "wires": []
    },
    {
        "id": "17ae79259ea74777",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "",
        "url": "/chord/getPatient",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 1750,
        "y": 220,
        "wires": [
            [
                "31b309561adc169e",
                "42f2271bf7d0c7e1"
            ]
        ]
    },
    {
        "id": "2f57a2f0f2c9186f",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "getPatient",
        "func": "// Node-RED Function Node - Get Patient Appointments\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n\nconst patientId = msg.payload.patientId || env.get(\"patientId\");\n\n\n\nconst authEndpoint = \"https://nexhealth.info/authenticates\";\nconst requestEndpoint = \"https://nexhealth.info/patients/\";\n\nconst phoneNum = msg.payload.phoneNum || \"3218675309\";\nconst subdomain = msg.subdomain || 'cdm';\n\n\n\n// Optional provider IDs filter (can be array or single value)\nconst providerIds = msg.providerIds || msg.providerId ? [msg.providerId] : [421458314];\n\nasync function getPatient() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // First, authenticate to get the token\n        node.warn('Authenticating...');\n        const requestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": apiKey\n            },\n            redirect: \"follow\"\n        };\n\n        const authResponse = await fetch(authEndpoint, requestOptions);\n\n        // Check for HTTP errors\n        if (!authResponse.ok) {\n            const errorText = await authResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Authentication failed with status ${authResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate authentication response\n        let authResult;\n        try {\n            authResult = await authResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse authentication response: ${parseError.message}`);\n        }\n\n        node.warn('Auth response received');\n\n        if (!authResult.data || !authResult.data.token) {\n            throw new Error('Authentication token not found in response. Response structure may have changed.');\n        }\n\n        const authToken = authResult.data.token;\n\n        // Build query parameters manually (patientId goes in the URL path, not query params)\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`,\n            `phone_number=${encodeURIComponent(phoneNum)}`\n        ];\n\n        // Add provider IDs to query params if needed (optional - may not be needed for patient endpoint)\n        if (Array.isArray(providerIds)) {\n            providerIds.forEach(id => {\n                queryParts.push(`provider_ids[]=${encodeURIComponent(id)}`);\n            });\n        } else if (providerIds) {\n            queryParts.push(`provider_ids[]=${encodeURIComponent(providerIds)}`);\n        }\n\n        // Build the full URL with patientId in the path\n        const url = `${requestEndpoint}${patientId}?${queryParts.join('&')}`;\n\n        const patientRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching patient...');\n        const patientResponse = await fetch(url, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get patient failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient response: ${parseError.message}`);\n        }\n\n        node.warn('Patient retrieved successfully');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Patient retrieved successfully',\n            patient: result.data,\n            fullResponse: result\n        };\n        msg.payload = msg.payload.patient;\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patient: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while retrieving patient',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getPatient();\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 2250,
        "y": 220,
        "wires": [
            [
                "e4399373da2f9f5e",
                "c74d3d53b0323805",
                "53b8941e29e2db6f"
            ]
        ]
    },
    {
        "id": "42f2271bf7d0c7e1",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "IngressGetPatient",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2070,
        "y": 180,
        "wires": []
    },
    {
        "id": "e4399373da2f9f5e",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "patientAppts Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2580,
        "y": 220,
        "wires": []
    },
    {
        "id": "51c6f07ac929e691",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "",
        "props": [
            {
                "p": "OGpatientId",
                "v": "427698262",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.patientId",
                "v": "430264454",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1770,
        "y": 200,
        "wires": [
            [
                "31b309561adc169e",
                "42f2271bf7d0c7e1"
            ]
        ]
    },
    {
        "id": "c74d3d53b0323805",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2410,
        "y": 220,
        "wires": []
    },
    {
        "id": "0bb08d8bed12b310",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "",
        "url": "/chord/getApptSlots",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 260,
        "y": 980,
        "wires": [
            [
                "ce39e9472e76eb3e"
            ]
        ]
    },
    {
        "id": "cf208737b8e69c2b",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "",
        "url": "/chord/createPatient",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 260,
        "y": 2580,
        "wires": [
            [
                "d0092387f9cb86a2"
            ]
        ]
    },
    {
        "id": "561df1dfdb7c522c",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "IngressCreatePatient",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 2540,
        "wires": []
    },
    {
        "id": "cfb61a13bb81723c",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "CreatePatient Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 2580,
        "wires": []
    },
    {
        "id": "80705f4510abd3e0",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "",
        "props": [
            {
                "p": "OGpatientId",
                "v": "427698262",
                "vt": "str"
            },
            {
                "p": "payload.patientId",
                "v": "428441632",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "phoneNum",
                "v": "3218675309",
                "vt": "str"
            },
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"firstName\":\"Korra\",\"lastName\":\"Test\",\"phoneNumber\":\"3212002331\",\"birthDate\":\"2017-03-03\",\"insurance\":\"Delta\"}",
        "payloadType": "json",
        "x": 370,
        "y": 2540,
        "wires": [
            [
                "d0092387f9cb86a2"
            ]
        ]
    },
    {
        "id": "9463e8541c653c27",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 930,
        "y": 2580,
        "wires": []
    },
    {
        "id": "f3ea80c4d43a7e49",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "",
        "url": "/chord/getPatientByPhoneNum",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 350,
        "y": 420,
        "wires": [
            [
                "9680fe37f534791c"
            ]
        ]
    },
    {
        "id": "9c3d1c02ed2c51d0",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "IngressGetPatientByPhone",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 460,
        "wires": []
    },
    {
        "id": "1602520a629897ac",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "",
        "props": [
            {
                "p": "OGpatientId",
                "v": "427698262",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.phoneNumber",
                "v": "+14086076558",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u00075i9��765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 570,
        "y": 380,
        "wires": [
            [
                "9680fe37f534791c"
            ]
        ]
    },
    {
        "id": "182759a7f1d80d75",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1330,
        "y": 420,
        "wires": []
    },
    {
        "id": "a9d53317ca1de2f7",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "baaf85afce595f5f",
        "name": "",
        "url": "/chord/confirmAppt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 250,
        "y": 2420,
        "wires": [
            [
                "13eb1e488c3796e9"
            ]
        ]
    },
    {
        "id": "5f5cf1f8375fd5b8",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "baaf85afce595f5f",
        "name": "IngressConfirmAppt",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 2380,
        "wires": []
    },
    {
        "id": "26a444411f61c09f",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "baaf85afce595f5f",
        "name": "ConfirmAppt Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 2420,
        "wires": []
    },
    {
        "id": "096e06bb70d82ec5",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "baaf85afce595f5f",
        "name": "",
        "props": [
            {
                "p": "payload.appointmentId",
                "v": "1131314463",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 330,
        "y": 2380,
        "wires": [
            [
                "13eb1e488c3796e9"
            ]
        ]
    },
    {
        "id": "8bf1658aceca2d71",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "baaf85afce595f5f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1050,
        "y": 2420,
        "wires": []
    },
    {
        "id": "1a6a877ef6bbb534",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "Ingress ApptSlotsMultiple",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 1180,
        "wires": []
    },
    {
        "id": "6da3bdc196eaabe5",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "ApptSlotsMultiple Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1070,
        "y": 1180,
        "wires": []
    },
    {
        "id": "22ce6f882a82abb2",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.numberOfAppointments",
                "v": "2",
                "vt": "num"
            },
            {
                "p": "payload.timeWindowMinutes",
                "v": "30",
                "vt": "num"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u0007\u0005i8l2765305129-000000000001105456-SR-000-000000000000DEN140-5AA00C14|333725|421458314VO|6733e082-0129-4e68-97dc-bd8b71aa02a6|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 370,
        "y": 1180,
        "wires": [
            [
                "b2792488e4a6f247"
            ]
        ]
    },
    {
        "id": "c98fb9e6c18da833",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1670,
        "y": 1180,
        "wires": []
    },
    {
        "id": "19da52b8bb9879a1",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "",
        "url": "/chord/getGroupedApptSlots",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 280,
        "y": 1220,
        "wires": [
            [
                "b2792488e4a6f247"
            ]
        ]
    },
    {
        "id": "de66f77742809b64",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "filterGroupedAppts",
        "func": "/**\n * ============================================================================\n * FILTER GROUPED APPOINTMENTS - Node-RED Function\n * ============================================================================\n * Filters appointment slots to find groups suitable for scheduling multiple\n * children/patients around the same time.\n * \n * Use this in a Function node AFTER getting appointment slots.\n * \n * Expected msg properties:\n * - msg.payload.slots: Array of appointment slots\n * - msg.numberOfAppointments: How many appointments needed (default: 2)\n * - msg.timeWindowMinutes: Max time span in minutes (default: 31)\n * \n * Output msg properties:\n * - msg.payload.groups: Array of valid appointment groups\n * - msg.payload.totalGroups: Number of groups found\n * - msg.payload.parameters: Input parameters used\n */\n\n// ============================================================================\n// 🔧 GROUPED APPOINTMENTS UTILITY\n// ============================================================================\n\n/**\n * Find groups of appointment slots that occur within a specified time window\n */\nfunction findGroupedAppointments(appointmentSlots, numberOfAppointments, timeWindowMinutes) {\n    // Validate inputs\n    if (!Array.isArray(appointmentSlots) || appointmentSlots.length === 0) {\n        return [];\n    }\n\n    if (numberOfAppointments < 1) {\n        throw new Error('numberOfAppointments must be at least 1');\n    }\n\n    if (numberOfAppointments === 1) {\n        return appointmentSlots.map(slot => [slot]);\n    }\n\n    if (appointmentSlots.length < numberOfAppointments) {\n        return [];\n    }\n\n    // Sort appointments by time\n    const sortedSlots = [...appointmentSlots].sort((a, b) => {\n        return new Date(a.time).getTime() - new Date(b.time).getTime();\n    });\n\n    const validGroups = [];\n\n    // Use sliding window to find valid groups\n    for (let i = 0; i <= sortedSlots.length - numberOfAppointments; i++) {\n        const potentialGroup = [];\n        const startTime = new Date(sortedSlots[i].time);\n\n        for (let j = i; j < sortedSlots.length && potentialGroup.length < numberOfAppointments; j++) {\n            const currentTime = new Date(sortedSlots[j].time);\n            const timeDifferenceMinutes = (currentTime.getTime() - startTime.getTime()) / (1000 * 60);\n\n            if (timeDifferenceMinutes <= timeWindowMinutes) {\n                potentialGroup.push(sortedSlots[j]);\n            } else {\n                break;\n            }\n        }\n\n        if (potentialGroup.length === numberOfAppointments) {\n            validGroups.push(potentialGroup);\n        }\n    }\n\n    return validGroups;\n}\n\n/**\n * Format a group of appointments for display\n */\nfunction formatAppointmentGroup(group) {\n    if (!group || group.length === 0) return null;\n\n    return {\n        appointments: group.map(slot => ({\n            time: slot.time,\n            end_time: slot.end_time,\n            operatory_id: slot.operatory_id\n        }))\n    };\n}\n\n// ============================================================================\n// 🚀 MAIN EXECUTION\n// ============================================================================\n\ntry {\n    // Get appointment slots from payload\n    let appointmentSlots = msg.payload.slots || msg.payload || [];\n\n    if (!Array.isArray(appointmentSlots)) {\n        throw new Error('Appointment slots must be an array');\n    }\n\n    // Get parameters from msg properties or use defaults\n    const numberOfAppointments = msg.webReq.numberOfAppointments;\n    const timeWindowMinutes = msg.webReq.timeWindowMinutes;\n\n    node.log(`[filterGroupedAppts] Processing ${appointmentSlots.length} slots`);\n    node.log(`[filterGroupedAppts] Number of appointments: ${numberOfAppointments}`);\n    node.log(`[filterGroupedAppts] Time window: ${timeWindowMinutes} minutes`);\n\n    // Find grouped appointments\n    const groupedAppointments = findGroupedAppointments(\n        appointmentSlots,\n        numberOfAppointments,\n        timeWindowMinutes\n    );\n\n    node.log(`[filterGroupedAppts] Found ${groupedAppointments.length} valid groups`);\n\n    // Format the groups\n    const formattedGroups = groupedAppointments.map(group => formatAppointmentGroup(group));\n\n    // Prepare output message\n    msg.payload = {\n        totalGroups: formattedGroups.length,\n        groups: formattedGroups\n    };\n\n    // Log summary\n    node.log(`[filterGroupedAppts] Returning ${formattedGroups.length} groups`);\n\n    return msg;\n\n} catch (error) {\n    node.error('[filterGroupedAppts] Error: ' + error.message);\n\n    msg.payload = {\n        error: error.message\n    };\n\n    return msg;\n}\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 1220,
        "wires": [
            [
                "cde03e5db1227091",
                "5a0c4c38c8525ba3"
            ]
        ]
    },
    {
        "id": "cde03e5db1227091",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "filtered",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1390,
        "y": 1260,
        "wires": []
    },
    {
        "id": "fe8d041c17561655",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "webReq",
                "pt": "msg",
                "to": "payload",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 810,
        "y": 1220,
        "wires": [
            [
                "ed3fd28e71f9da76"
            ]
        ]
    },
    {
        "id": "a367888d745765fb",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "getApptSlotsMult",
        "links": [],
        "x": 265,
        "y": 1180,
        "wires": [
            [
                "b2792488e4a6f247"
            ]
        ]
    },
    {
        "id": "dbaecfb7ced92ed9",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "link out 3",
        "mode": "return",
        "links": [],
        "x": 1945,
        "y": 1180,
        "wires": []
    },
    {
        "id": "4ae654ff0152fe6b",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "getPatientByEmail Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1310,
        "y": 180,
        "wires": []
    },
    {
        "id": "93d8deb456796648",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "",
        "url": "/chord/getPatientByEmail",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 310,
        "y": 220,
        "wires": [
            [
                "55642a32a0a57d99"
            ]
        ]
    },
    {
        "id": "0a6333d2d0c09d51",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "IngressGetPatientByEmail",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 710,
        "y": 180,
        "wires": []
    },
    {
        "id": "bf15e1acbfa06939",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "",
        "props": [
            {
                "p": "OGpatientId",
                "v": "427698262",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.email",
                "v": "aiTest@intelepeer.com",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u00075i9��765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 450,
        "y": 180,
        "wires": [
            [
                "55642a32a0a57d99"
            ]
        ]
    },
    {
        "id": "4625dd1161a71643",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1110,
        "y": 220,
        "wires": []
    },
    {
        "id": "0e6e750bd7305240",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "getPatientsByEmail",
        "mode": "return",
        "links": [],
        "x": 1285,
        "y": 240,
        "wires": []
    },
    {
        "id": "3c29fbe0f6421974",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "getPatientByEmail",
        "links": [],
        "x": 525,
        "y": 280,
        "wires": [
            [
                "7eb21a1ba101e779",
                "0a6333d2d0c09d51"
            ]
        ]
    },
    {
        "id": "6600557958d878e1",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "GetPatient",
        "links": [],
        "x": 1785,
        "y": 180,
        "wires": [
            [
                "31b309561adc169e",
                "42f2271bf7d0c7e1"
            ]
        ]
    },
    {
        "id": "53b8941e29e2db6f",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "getPatient",
        "mode": "return",
        "links": [],
        "x": 2615,
        "y": 220,
        "wires": []
    },
    {
        "id": "8a2f0f010e9acb12",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "getPatientAppts",
        "links": [],
        "x": 475,
        "y": 680,
        "wires": [
            [
                "fc8ac68df269e529",
                "83dede7b863766d4"
            ]
        ]
    },
    {
        "id": "d2ba7b687348cb9e",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "getPatientAppts",
        "mode": "return",
        "links": [],
        "x": 1505,
        "y": 740,
        "wires": []
    },
    {
        "id": "5682ca6fadd2bb9a",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "CancelAppt",
        "links": [],
        "x": 165,
        "y": 2200,
        "wires": [
            [
                "4c0345908803bea4"
            ]
        ]
    },
    {
        "id": "ecd53087f3ee7fa5",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "CancelAppt",
        "mode": "return",
        "links": [],
        "x": 745,
        "y": 2200,
        "wires": []
    },
    {
        "id": "13c2f93b78c5a7d6",
        "type": "http in",
        "z": "cb091dda25252c01",
        "d": true,
        "g": "e1a21f43e6e5d2bd",
        "name": "",
        "url": "/chord/editPatient",
        "method": "patch",
        "upload": false,
        "swaggerDoc": "",
        "x": 270,
        "y": 3200,
        "wires": [
            [
                "dcb0e8805bad0671",
                "d05d41ec0768b654"
            ]
        ]
    },
    {
        "id": "dcb0e8805bad0671",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "NullPatient_DANGER",
        "func": "// Node-RED Function Node - Edit Patient\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\nconst subdomain = \"cdm\";\nconst patientId = msg.payload.patientId;\n\nconst apiEndpoint = \"https://nexhealth.info/patients/\"+patientId+\"?subdomain=\"+subdomain+\"&location_id=\"+locationId;\nasync function nullPatient() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!subdomain){\n            throw new Error('Subdomain is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n\n        // First, authenticate to get the token\n        node.warn('Authenticating...');\n        const requestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": apiKey\n            },\n            redirect: \"follow\"\n        };\n\n        const authResponse = await fetch(\"https://nexhealth.info/authenticates\", requestOptions);\n\n        // Check for HTTP errors\n        if (!authResponse.ok) {\n            const errorText = await authResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Authentication failed with status ${authResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate authentication response\n        let authResult;\n        try {\n            authResult = await authResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse authentication response: ${parseError.message}`);\n        }\n\n        node.warn('Auth response received');\n\n        if (!authResult.data || !authResult.data.token) {\n            throw new Error('Authentication token not found in response. Response structure may have changed.');\n        }\n\n        const authToken = authResult.data.token;\n\n        // Now create the patient with the auth token\n        const patientData = {\n            \"provider\": {\n                \"provider_id\": providerId\n            },\n            \"patient\": {\n                \"first_name\": null,\n                \"last_name\": null,\n                \"email\": null,\n                \"bio\": {\n                    \"date_of_birth\": null,\n                    \"phone_number\": null,\n                    \"home_phone_number\": \"\",\n                    \"cell_phone_number\": \"\",\n                    \"work_phone_number\": \"\",\n                    \"custom_contact_number\": \"\",\n                    \"weight\": \"\",\n                    \"height\": \"\",\n                    \"street_address\": \"\",\n                    \"address_line_1\": \"\",\n                    \"address_line_2\": \"\",\n                    \"city\": \"\",\n                    \"state\": \"\",\n                    \"zip_code\": \"\",\n                    \"insurance_name\": null,\n                    \"ssn\": \"\",\n                    \"race\": \"\"\n                }\n            }\n        };\n\n        const raw = JSON.stringify(patientData);\n\n        const patientRequestOptions = {\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Nulling patient...');\n        const patientResponse = await fetch(apiEndpoint, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Null patient failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient creation response: ${parseError.message}`);\n        }\n\n        node.warn('Patient nulled successfully');\n        node.warn(result);\n\n\n        // Set the payload with results\n        msg.payload = result.data.user;\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error creating patient: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during patient nullification',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn nullPatient();\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 620,
        "y": 3200,
        "wires": [
            [
                "4818e6bd5bb4504f",
                "56fc2e5457f9f2af",
                "4ce1390c1c13ad57"
            ]
        ]
    },
    {
        "id": "d05d41ec0768b654",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "IngressNullPatient",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 3160,
        "wires": []
    },
    {
        "id": "4818e6bd5bb4504f",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "NullPatient Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1010,
        "y": 3200,
        "wires": []
    },
    {
        "id": "562472209a90a58e",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "",
        "props": [
            {
                "p": "payload.patientId",
                "v": "430225709",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 410,
        "y": 3160,
        "wires": [
            [
                "dcb0e8805bad0671"
            ]
        ]
    },
    {
        "id": "56fc2e5457f9f2af",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 830,
        "y": 3200,
        "wires": []
    },
    {
        "id": "7cc5862cb2a23f7c",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "Null Patient - DANGER ",
        "links": [],
        "x": 275,
        "y": 3160,
        "wires": [
            [
                "d05d41ec0768b654",
                "dcb0e8805bad0671"
            ]
        ]
    },
    {
        "id": "4ce1390c1c13ad57",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "Null Patient - DANGER",
        "mode": "return",
        "links": [],
        "x": 855,
        "y": 3160,
        "wires": []
    },
    {
        "id": "f840c1c595d1fe2b",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "getPatientByPhone",
        "links": [],
        "x": 235,
        "y": 480,
        "wires": [
            [
                "9c3d1c02ed2c51d0",
                "6005bfd25271cf84"
            ]
        ]
    },
    {
        "id": "e51b295556726df3",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "getPatientByPhone",
        "mode": "return",
        "links": [],
        "x": 1195,
        "y": 480,
        "wires": []
    },
    {
        "id": "5e6d28d59d07ec5b",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "getApptSlots",
        "links": [],
        "x": 395,
        "y": 1040,
        "wires": [
            [
                "ce39e9472e76eb3e"
            ]
        ]
    },
    {
        "id": "2b456a8c2ad64a14",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "getApptSlots",
        "mode": "return",
        "links": [],
        "x": 1445,
        "y": 1000,
        "wires": []
    },
    {
        "id": "79bd1cc5e54c80d7",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsTimeSynced",
        "func": "// Node-RED Function Node - Get Appointment Slots\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n\n\nconst startDate = msg.startDate || \"2026-04-13\";\nconst days = msg.days || 30;\n\nconst maxSlots = msg.maxSlots || env.get(\"maxApptSlots\") || 50;\n\nasync function getAppointmentSlots() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!startDate) {\n            throw new Error('Start date is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        if (!days || days < 1) {\n            throw new Error('Days must be a positive number');\n        }\n\n        // Validate maxSlots parameter (optional - null/0 means return all)\n        if (maxSlots !== null && maxSlots !== 0 && maxSlots < 1) {\n            throw new Error('maxSlots must be null, 0, or a positive number');\n        }\n\n        // Validate startDate format (YYYY-MM-DD)\n        const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n        if (!dateRegex.test(startDate)) {\n            throw new Error('Invalid start date format. Expected YYYY-MM-DD format.');\n        }\n\n        const dateObj = new Date(startDate);\n        if (isNaN(dateObj.getTime())) {\n            throw new Error('Invalid start date. Please provide a valid date.');\n        }\n\n        // First, authenticate to get the token\n        node.warn('Authenticating...');\n        const requestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": apiKey\n            },\n            redirect: \"follow\"\n        };\n\n        const authResponse = await fetch(\"https://nexhealth.info/authenticates\", requestOptions);\n        \n        // Check for HTTP errors\n        if (!authResponse.ok) {\n            const errorText = await authResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Authentication failed with status ${authResponse.status}: ${errorText}`);\n        }\n        \n        // Parse and validate authentication response\n        let authResult;\n        try {\n            authResult = await authResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse authentication response: ${parseError.message}`);\n        }\n        \n        node.warn('Auth response received');\n        \n        if (!authResult.data || !authResult.data.token) {\n            throw new Error('Authentication token not found in response. Response structure may have changed.');\n        }\n        \n        const authToken = authResult.data.token;\n\n        // Now make the second request with the auth token\n        const apptRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching appointment slots...');\n        const slotsResponse = await fetch(\"https://nexhealth.info/appointment_slots?subdomain=cdm&lids[]=\" + locationId + \n            \"&pids[]=\" + providerId + \n            \"&start_date=\" + startDate + \n            \"&days=\" + days + \n            \"&location_id=\" + locationId +\n            \"&working_hour_source=synced\", apptRequestOptions);\n        \n        // Check for HTTP errors\n        if (!slotsResponse.ok) {\n            const errorText = await slotsResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointment slots failed with status ${slotsResponse.status}: ${errorText}`);\n        }\n        \n        // Parse and validate slots response\n        let result;\n        try {\n            result = await slotsResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment slots response: ${parseError.message}`);\n        }\n        \n        node.warn('Appointment slots response received');\n        \n        // Validate response structure\n        if (!result.data) {\n            throw new Error('No data found in appointment slots response');\n        }\n\n        if (!Array.isArray(result.data) || result.data.length === 0) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified criteria',\n                data: []\n            };\n            return msg;\n        }\n\n        if (!result.data[0].slots) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified provider',\n                data: []\n            };\n            return msg;\n        }\n        \n        const allSlots = result.data[0].slots;\n        \n        // Apply maxSlots limit if specified (null or 0 means return all)\n        let apptSlots;\n        let limitMessage = '';\n        \n        if (maxSlots === null || maxSlots === 0) {\n            apptSlots = allSlots;\n            limitMessage = 'all';\n        } else {\n            apptSlots = allSlots.slice(0, maxSlots);\n            limitMessage = maxSlots === apptSlots.length ? `first ${maxSlots}` : `all ${apptSlots.length}`;\n        }\n        \n        node.warn(`Returning ${limitMessage} appointment slots`);\n        \n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: `Found ${allSlots.length} appointment slots, returning ${apptSlots.length}`,\n            totalSlots: allSlots.length,\n            returnedSlots: apptSlots.length,\n            maxSlotsLimit: maxSlots || 'unlimited',\n            data: apptSlots\n        };\n        \n        // KGK 2025-11-18 reduce payload to just apptSlots array\n        msg.payload = msg.payload.data;\n\n        return msg;\n        \n    } catch (error) {\n        node.error('Error getting appointment slots: ' + error.message, msg);\n        \n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching appointment slots',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n        \n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAppointmentSlots();\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 2610,
        "y": 1640,
        "wires": [
            [
                "52d22ed0195d7c8a",
                "6c6b4c49f88af363",
                "040125ecfc531030"
            ]
        ]
    },
    {
        "id": "c2189159710e251a",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "Ingress getApptSlotsTimeSynced",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2800,
        "y": 1560,
        "wires": []
    },
    {
        "id": "52d22ed0195d7c8a",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsTimeSynced Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 3100,
        "y": 1640,
        "wires": []
    },
    {
        "id": "63c15979bef0de96",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2100,
        "y": 1560,
        "wires": [
            [
                "c2189159710e251a"
            ]
        ]
    },
    {
        "id": "6c6b4c49f88af363",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2850,
        "y": 1640,
        "wires": []
    },
    {
        "id": "205dfc6604d35e3e",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "",
        "url": "/chord/getApptSlotsTimeSynced",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 2130,
        "y": 1640,
        "wires": [
            [
                "c2189159710e251a"
            ]
        ]
    },
    {
        "id": "bc61b018ea9d38b5",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsTimeSynced",
        "links": [],
        "x": 2015,
        "y": 1600,
        "wires": [
            [
                "c2189159710e251a"
            ]
        ]
    },
    {
        "id": "040125ecfc531030",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsTimeSynced",
        "mode": "return",
        "links": [],
        "x": 3095,
        "y": 1600,
        "wires": []
    },
    {
        "id": "a9e8241b92aae854",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsOverlapping",
        "func": "// Node-RED Function Node - Get Appointment Slots\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n\n\nconst startDate = msg.startDate || \"2026-04-13\";\nconst days = msg.days || 30;\nconst apptTypeId = msg.payload.apptType || \"\";\n\nconst maxSlots = msg.maxSlots || env.get(\"maxApptSlotsOverlapping\") || 100;\n\nasync function getAppointmentSlots() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!startDate) {\n            throw new Error('Start date is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        if (!days || days < 1) {\n            throw new Error('Days must be a positive number');\n        }\n\n        // Validate maxSlots parameter (optional - null/0 means return all)\n        if (maxSlots !== null && maxSlots !== 0 && maxSlots < 1) {\n            throw new Error('maxSlots must be null, 0, or a positive number');\n        }\n\n        // Validate startDate format (YYYY-MM-DD)\n        const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n        if (!dateRegex.test(startDate)) {\n            throw new Error('Invalid start date format. Expected YYYY-MM-DD format.');\n        }\n\n        const dateObj = new Date(startDate);\n        if (isNaN(dateObj.getTime())) {\n            throw new Error('Invalid start date. Please provide a valid date.');\n        }\n\n        // First, authenticate to get the token\n        node.warn('Authenticating...');\n        const requestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": apiKey\n            },\n            redirect: \"follow\"\n        };\n\n        const authResponse = await fetch(\"https://nexhealth.info/authenticates\", requestOptions);\n        \n        // Check for HTTP errors\n        if (!authResponse.ok) {\n            const errorText = await authResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Authentication failed with status ${authResponse.status}: ${errorText}`);\n        }\n        \n        // Parse and validate authentication response\n        let authResult;\n        try {\n            authResult = await authResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse authentication response: ${parseError.message}`);\n        }\n        \n        node.warn('Auth response received');\n        \n        if (!authResult.data || !authResult.data.token) {\n            throw new Error('Authentication token not found in response. Response structure may have changed.');\n        }\n        \n        const authToken = authResult.data.token;\n\n        // Now make the second request with the auth token\n        const apptRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching appointment slots...');\n        const slotsResponse = await fetch(\"https://nexhealth.info/appointment_slots?subdomain=cdm&lids[]=\" + locationId + \n            \"&pids[]=\" + providerId + \n            \"&start_date=\" + startDate + \n            \"&days=\" + days + \n            \"&location_id=\" + locationId +\n            \"&overlapping_operatory_slots=true\" +\n            \"&appointment_type_id=\" + apptTypeId, apptRequestOptions);\n        \n        // Check for HTTP errors\n        if (!slotsResponse.ok) {\n            const errorText = await slotsResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointment slots failed with status ${slotsResponse.status}: ${errorText}`);\n        }\n        \n        // Parse and validate slots response\n        let result;\n        try {\n            result = await slotsResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment slots response: ${parseError.message}`);\n        }\n        \n        node.warn('Appointment slots response received');\n        \n        // Validate response structure\n        if (!result.data) {\n            throw new Error('No data found in appointment slots response');\n        }\n\n        if (!Array.isArray(result.data) || result.data.length === 0) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified criteria',\n                data: []\n            };\n            return msg;\n        }\n\n        if (!result.data[0].slots) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified provider',\n                data: []\n            };\n            return msg;\n        }\n        \n        const allSlots = result.data[0].slots;\n        \n        // Apply maxSlots limit if specified (null or 0 means return all)\n        let apptSlots;\n        let limitMessage = '';\n        \n        if (maxSlots === null || maxSlots === 0) {\n            apptSlots = allSlots;\n            limitMessage = 'all';\n        } else {\n            apptSlots = allSlots.slice(0, maxSlots);\n            limitMessage = maxSlots === apptSlots.length ? `first ${maxSlots}` : `all ${apptSlots.length}`;\n        }\n        \n        node.warn(`Returning ${limitMessage} appointment slots`);\n        \n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: `Found ${allSlots.length} appointment slots, returning ${apptSlots.length}`,\n            totalSlots: allSlots.length,\n            returnedSlots: apptSlots.length,\n            maxSlotsLimit: maxSlots || 'unlimited',\n            data: apptSlots\n        };\n        \n        // KGK 2025-11-18 reduce payload to just apptSlots array\n        msg.payload = msg.payload.data;\n\n        return msg;\n        \n    } catch (error) {\n        node.error('Error getting appointment slots: ' + error.message, msg);\n        \n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching appointment slots',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n        \n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAppointmentSlots();\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 2530,
        "y": 1840,
        "wires": [
            [
                "114c1eb6cebe0dfe",
                "baba64677c81a5f4",
                "8a1905e18839e671"
            ]
        ]
    },
    {
        "id": "3cdfad76847824e6",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "Ingress getApptSlotsOverlapping",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2590,
        "y": 1800,
        "wires": []
    },
    {
        "id": "114c1eb6cebe0dfe",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsOverlapping Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 3000,
        "y": 1840,
        "wires": []
    },
    {
        "id": "305bfd6f029418f3",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2320,
        "y": 1800,
        "wires": [
            [
                "a9e8241b92aae854"
            ]
        ]
    },
    {
        "id": "baba64677c81a5f4",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 2770,
        "y": 1860,
        "wires": []
    },
    {
        "id": "dfa5bbf79b09f450",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "",
        "url": "/chord/getApptSlotsOverlapping",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 2170,
        "y": 1840,
        "wires": [
            [
                "3cdfad76847824e6",
                "a9e8241b92aae854"
            ]
        ]
    },
    {
        "id": "16255887a7d25a4f",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsOverlapping",
        "links": [],
        "x": 2145,
        "y": 1800,
        "wires": [
            [
                "3cdfad76847824e6",
                "a9e8241b92aae854"
            ]
        ]
    },
    {
        "id": "8a1905e18839e671",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "getApptSlotsOverlapping",
        "mode": "return",
        "links": [],
        "x": 2815,
        "y": 1800,
        "wires": []
    },
    {
        "id": "d4a7896d3f26a796",
        "type": "inject",
        "z": "cb091dda25252c01",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 80,
        "wires": [
            [
                "e16de89f91df9659"
            ]
        ]
    },
    {
        "id": "e16de89f91df9659",
        "type": "change",
        "z": "cb091dda25252c01",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "LocationInfo",
                "pt": "flow",
                "to": "{\"providers\":[{\"providerName\":\"PDA Allegheny\",\"locationId\":\"77522\",\"providerId\":\"223076809\",\"officeHours\":[{\"day\":\"Monday\",\"startTime\":\"7:00AM\",\"endTime\":\"7:00PM\"},{\"day\":\"Tuesday\",\"startTime\":\"7:00AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Wednesday\",\"startTime\":\"7:00AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Thursday\",\"startTime\":\"7:00AM\",\"endTime\":\"3:00PM\"},{\"day\":\"Friday\",\"startTime\":\"7:00AM\",\"endTime\":\"2:30PM\"}]},{\"providerName\":\"CDH Ortho Allegheny\",\"locationId\":\"799d413a-5e1a-46a2-b169-e2108bf517d6\",\"providerId\":\"799d413a-5e1a-46a2-b169-e2108bf517d6\",\"officeHours\":[{\"day\":\"Monday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Tuesday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Wednesday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Thursday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Friday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"}]},{\"providerName\":\"PDA West Philadelphia\",\"locationId\":\"77523\",\"providerId\":\"223076809\",\"officeHours\":[{\"day\":\"Monday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"},{\"day\":\"Tuesday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"},{\"day\":\"Wednesday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"},{\"day\":\"Thursday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"}]},{\"providerName\":\"PDA Allegheny\",\"locationId\":\"333724\",\"providerId\":\"421458170\",\"officeHours\":[{\"day\":\"Monday\",\"startTime\":\"7:00AM\",\"endTime\":\"7:00PM\"},{\"day\":\"Tuesday\",\"startTime\":\"7:00AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Wednesday\",\"startTime\":\"7:00AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Thursday\",\"startTime\":\"7:00AM\",\"endTime\":\"3:00PM\"},{\"day\":\"Friday\",\"startTime\":\"7:00AM\",\"endTime\":\"2:30PM\"}]},{\"providerName\":\"PDA West Philadelphia\",\"locationId\":\"333725\",\"providerId\":\"421458314\",\"officeHours\":[{\"day\":\"Monday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"},{\"day\":\"Tuesday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"},{\"day\":\"Wednesday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"},{\"day\":\"Thursday\",\"startTime\":\"8:00AM\",\"endTime\":\"5:00PM\"}]},{\"providerName\":\"CDH Ortho Allegheny\",\"locationId\":\"799d413a-5e1a-46a2-b169-e2108bf517d6\",\"providerId\":\"799d413a-5e1a-46a2-b169-e2108bf517d6\",\"officeHours\":[{\"day\":\"Monday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Tuesday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Wednesday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Thursday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"},{\"day\":\"Friday\",\"startTime\":\"8:30AM\",\"endTime\":\"4:30PM\"}]}]}",
                "tot": "json"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 500,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "de2ddbee35e7601b",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "FormatTime",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 960,
        "wires": []
    },
    {
        "id": "8e83fa56678a1331",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "getApptSlots Egress",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 900,
        "y": 960,
        "wires": []
    },
    {
        "id": "56ee0b68b8b48848",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "convertTimeFormat",
        "func": "// Node-RED Function Node - Convert Time Format and Timezone\n// This code is designed to run inside a Node-RED Function node\n// Converts between 12-hour and 24-hour formats and between timezones with DST handling\n// Uses moment-timezone for reliable timezone and DST conversions\n\n/**\n * ============================================================================\n * CONVERT TIME FORMAT AND TIMEZONE - Node-RED Function\n * ============================================================================\n * Flexible time conversion function that can:\n * - Convert between 12-hour (e.g., \"9:00 PM\") and 24-hour (e.g., \"21:00\") formats\n * - Convert between timezones (e.g., UTC to EST/EDT) with automatic DST handling\n * - Handle ISO datetime strings with timezone information\n * \n * Configuration (via msg properties or environment variables):\n * - msg.timeFormat: \"12hour\" or \"24hour\" (output format, default: \"12hour\")\n * - msg.fromTimezone: Source timezone (e.g., \"UTC\", \"America/New_York\", default: auto-detect)\n * - msg.toTimezone: Target timezone (e.g., \"America/New_York\", \"UTC\", default: \"America/New_York\")\n * - msg.dateFormat: Date format string (optional, default: \"YYYY-MM-DD\")\n * - msg.timeFormatString: Custom time format string (optional, overrides timeFormat)\n * \n * Environment variables (fallback if msg properties not set):\n * - timeFormat: \"12hour\" or \"24hour\"\n * - fromTimezone: Source timezone\n * - toTimezone: Target timezone\n * \n * Expected msg properties:\n * - msg.payload: Array of appointment slots with time and end_time fields:\n *   - ISO format: { time: \"2026-04-14T15:00:00.000Z\", end_time: \"...\" }\n *   - 12-hour format: { time: \"9:00 PM\", date: \"2026-04-14\", end_time: \"...\" }\n *   - 24-hour format: { time: \"21:00\", date: \"2026-04-14\", end_time: \"...\" }\n * \n * Output msg properties:\n * - msg.payload: Array of appointment slots with converted times\n * - msg.conversionInfo: Metadata about the conversion performed\n */\n\n/*\n// Try to require moment-timezone\nlet moment;\ntry {\n    moment = require('moment-timezone');\n} catch (e) {\n    if (typeof global.moment !== 'undefined' && global.moment.tz) {\n        moment = global.moment;\n    } else {\n        throw new Error('moment-timezone is required. Please install it: npm install moment-timezone');\n    }\n}\n*/\n\n\n// ============================================================================\n// 🔧 CONFIGURATION\n// ============================================================================\n\n// Get configuration from msg properties or environment variables\nconst config = {\n    // Output format: \"12hour\" or \"24hour\"\n    timeFormat: msg.timeFormat || env.get(\"timeFormat\") || \"12hour\",\n\n    // Source timezone (null = auto-detect from input)\n    fromTimezone: msg.fromTimezone || env.get(\"fromTimezone\") || null,\n\n    // Target timezone\n    toTimezone: msg.toTimezone || env.get(\"toTimezone\") || \"America/New_York\",\n\n    // Date format (optional)\n    dateFormat: msg.dateFormat || env.get(\"dateFormat\") || \"YYYY-MM-DD\",\n\n    // Custom time format string (optional, overrides timeFormat)\n    timeFormatString: msg.timeFormatString || env.get(\"timeFormatString\") || null\n};\n\n// Validate timeFormat\nif (config.timeFormat !== \"12hour\" && config.timeFormat !== \"24hour\") {\n    node.warn(`[convertTimeFormat] Invalid timeFormat: ${config.timeFormat}. Using default: 12hour`);\n    config.timeFormat = \"12hour\";\n}\n\n// ============================================================================\n// 🔧 UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Detect the format of a time string\n * @param {string} timeString - Time string to analyze\n * @returns {object} { format: \"iso\"|\"12hour\"|\"24hour\", hasDate: boolean }\n */\nfunction detectTimeFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return { format: null, hasDate: false };\n    }\n\n    // Check for ISO format (contains T and timezone info)\n    if (timeString.includes('T') && (timeString.includes('Z') || timeString.match(/[+-]\\d{2}:\\d{2}$/))) {\n        return { format: \"iso\", hasDate: true };\n    }\n\n    // Check for ISO format without timezone (contains T)\n    if (timeString.includes('T')) {\n        return { format: \"iso\", hasDate: true };\n    }\n\n    // Check for 12-hour format (contains AM/PM)\n    if (timeString.match(/\\d{1,2}:\\d{2}\\s*(AM|PM)/i)) {\n        return { format: \"12hour\", hasDate: false };\n    }\n\n    // Check for 24-hour format (HH:MM or HH:MM:SS)\n    if (timeString.match(/^\\d{1,2}:\\d{2}(:\\d{2})?$/)) {\n        return { format: \"24hour\", hasDate: false };\n    }\n\n    // Default to ISO if we can't determine\n    return { format: \"iso\", hasDate: true };\n}\n\n/**\n * Parse a time string into a moment object\n * @param {string} timeString - Time string to parse\n * @param {string} dateString - Optional date string (YYYY-MM-DD)\n * @param {string} fromTimezone - Source timezone (null = auto-detect)\n * @returns {object} moment object or null if parsing fails\n */\nfunction parseTimeString(timeString, dateString, fromTimezone) {\n    if (!timeString) {\n        return null;\n    }\n\n    const formatInfo = detectTimeFormat(timeString);\n    let momentObj = null;\n\n    try {\n        if (formatInfo.format === \"iso\") {\n            // ISO format - parse with moment\n            momentObj = moment(timeString);\n\n            // If fromTimezone is specified, treat as that timezone\n            if (fromTimezone && momentObj.isValid()) {\n                momentObj = moment.tz(timeString, fromTimezone);\n            } else if (momentObj.isValid()) {\n                // Try to preserve timezone if present, otherwise assume UTC\n                if (!timeString.includes('Z') && !timeString.match(/[+-]\\d{2}:\\d{2}$/)) {\n                    momentObj = moment.utc(timeString);\n                }\n            }\n        } else if (formatInfo.format === \"12hour\") {\n            // 12-hour format - need date string\n            if (!dateString) {\n                node.warn(`[convertTimeFormat] 12-hour time format requires date. Time: ${timeString}`);\n                return null;\n            }\n\n            const combinedString = `${dateString} ${timeString}`;\n            const format = `${config.dateFormat} h:mm A`;\n            momentObj = moment(combinedString, format);\n\n            // Apply source timezone if specified\n            if (fromTimezone && momentObj.isValid()) {\n                momentObj = moment.tz(combinedString, format, fromTimezone);\n            }\n        } else if (formatInfo.format === \"24hour\") {\n            // 24-hour format - need date string\n            if (!dateString) {\n                node.warn(`[convertTimeFormat] 24-hour time format requires date. Time: ${timeString}`);\n                return null;\n            }\n\n            const combinedString = `${dateString} ${timeString}`;\n            const format = `${config.dateFormat} HH:mm`;\n            momentObj = moment(combinedString, format);\n\n            // Apply source timezone if specified\n            if (fromTimezone && momentObj.isValid()) {\n                momentObj = moment.tz(combinedString, format, fromTimezone);\n            }\n        }\n\n        if (!momentObj || !momentObj.isValid()) {\n            node.warn(`[convertTimeFormat] Could not parse time: ${timeString}`);\n            return null;\n        }\n\n        return momentObj;\n\n    } catch (error) {\n        node.warn(`[convertTimeFormat] Error parsing time ${timeString}: ${error.message}`);\n        return null;\n    }\n}\n\n/**\n * Format a moment object to the desired output format\n * @param {object} momentObj - moment object to format\n * @returns {object} { time: string, date: string }\n */\nfunction formatMoment(momentObj) {\n    if (!momentObj || !momentObj.isValid()) {\n        return { time: null, date: null };\n    }\n\n    // Convert to target timezone\n    const convertedMoment = momentObj.tz(config.toTimezone);\n\n    // Format date\n    const date = convertedMoment.format(config.dateFormat);\n\n    // Format time based on configuration\n    let time;\n    if (config.timeFormatString) {\n        // Use custom format string\n        time = convertedMoment.format(config.timeFormatString);\n    } else if (config.timeFormat === \"12hour\") {\n        // 12-hour format: \"9:00 PM\"\n        time = convertedMoment.format(\"h:mm A\");\n    } else {\n        // 24-hour format: \"21:00\"\n        time = convertedMoment.format(\"HH:mm\");\n    }\n\n    return { time, date };\n}\n\n/**\n * Convert a time string to the desired format and timezone\n * @param {string} timeString - Time string to convert\n * @param {string} dateString - Optional date string (for non-ISO formats)\n * @returns {object} { time: string, date: string, iso: string }\n */\nfunction convertTime(timeString, dateString) {\n    if (!timeString) {\n        return { time: null, date: null, iso: null };\n    }\n\n    // Parse the input time\n    const momentObj = parseTimeString(timeString, dateString, config.fromTimezone);\n\n    if (!momentObj) {\n        // Return original if we can't parse\n        return { time: timeString, date: dateString || null, iso: null };\n    }\n\n    // Format to desired output\n    const formatted = formatMoment(momentObj);\n\n    // Also provide ISO format for reference\n    const iso = momentObj.tz(config.toTimezone).format();\n\n    return {\n        time: formatted.time,\n        date: formatted.date,\n        iso: iso\n    };\n}\n\n// ============================================================================\n// 🚀 MAIN EXECUTION\n// ============================================================================\n\ntry {\n    // Get appointment slots from payload\n    let appointmentSlots = msg.payload;\n\n    if (!Array.isArray(appointmentSlots)) {\n        throw new Error('Appointment slots must be an array. Received: ' + typeof appointmentSlots);\n    }\n\n    if (appointmentSlots.length === 0) {\n        node.log('[convertTimeFormat] No appointment slots to convert');\n        return msg;\n    }\n\n    node.log(`[convertTimeFormat] Converting ${appointmentSlots.length} appointment slots`);\n    node.log(`[convertTimeFormat] Config: format=${config.timeFormat}, from=${config.fromTimezone || 'auto'}, to=${config.toTimezone}`);\n\n    // Convert each slot's time and end_time\n    const convertedSlots = appointmentSlots.map((slot, index) => {\n        const convertedSlot = { ...slot }; // Create a copy\n\n        // Get date from slot (may be needed for non-ISO formats)\n        const slotDate = slot.date || null;\n\n        // Convert time field\n        if (slot.time) {\n            const converted = convertTime(slot.time, slotDate);\n            convertedSlot.time = converted.time;\n\n            // Update date if we got a new one\n            if (converted.date) {\n                convertedSlot.date = converted.date;\n            }\n\n            // Log first few conversions for debugging\n            if (index < 3) {\n                node.log(`[convertTimeFormat] Slot ${index + 1}: ${slot.time} -> ${convertedSlot.time} (${config.toTimezone})`);\n            }\n        } else {\n            node.warn(`[convertTimeFormat] Slot ${index + 1} missing 'time' field`);\n        }\n\n        // Convert end_time field\n        if (slot.end_time) {\n            const converted = convertTime(slot.end_time, slotDate);\n            convertedSlot.end_time = converted.time;\n        } else if (slot.time) {\n            // If no end_time but has time, use the same converted time\n            convertedSlot.end_time = convertedSlot.time;\n        }\n\n        return convertedSlot;\n    });\n\n    node.log(`[convertTimeFormat] Successfully converted ${convertedSlots.length} appointment slots`);\n\n    // Update payload with converted slots\n    msg.payload = convertedSlots;\n\n    // Add metadata about conversion\n    msg.conversionInfo = {\n        originalCount: appointmentSlots.length,\n        convertedCount: convertedSlots.length,\n        timeFormat: config.timeFormat,\n        fromTimezone: config.fromTimezone || \"auto-detected\",\n        toTimezone: config.toTimezone,\n        dateFormat: config.dateFormat\n    };\n\n    return msg;\n\n} catch (error) {\n    node.error('[convertTimeFormat] Error: ' + error.message, msg);\n\n    msg.payload = {\n        error: error.message,\n        originalPayload: msg.payload,\n        config: config\n    };\n\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "moment",
                "module": "moment-timezone"
            }
        ],
        "x": 1150,
        "y": 1000,
        "wires": [
            [
                "de2ddbee35e7601b",
                "2b456a8c2ad64a14",
                "8282c8c9f45bb754"
            ]
        ]
    },
    {
        "id": "1df75ccc2ca60061",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "OldFormat",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.patientId",
                "v": "432833620",
                "vt": "str"
            },
            {
                "p": "payload.apptTime",
                "v": "2026-04-13T11:00:00.000-04:00",
                "vt": "str"
            },
            {
                "p": "payload.operatoryId",
                "v": "24841",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 140,
        "y": 1400,
        "wires": [
            [
                "5d0d05d9d9b8e123"
            ]
        ]
    },
    {
        "id": "f86307f2bd42a986",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "GoodFormat",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.patientId",
                "v": "433246523",
                "vt": "str"
            },
            {
                "p": "payload.apptTime",
                "v": "1:30 PM",
                "vt": "str"
            },
            {
                "p": "payload.operatoryId",
                "v": "24844",
                "vt": "str"
            },
            {
                "p": "payload.apptDate",
                "v": "2026-04-13",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 290,
        "y": 1440,
        "wires": [
            [
                "5d0d05d9d9b8e123"
            ]
        ]
    },
    {
        "id": "1476be69d5af1e85",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "ConvertedTime",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 1440,
        "wires": []
    },
    {
        "id": "e211e5722f86e26b",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "converted12Hr",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1800,
        "y": 1240,
        "wires": []
    },
    {
        "id": "48d519a374f4332d",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "normalizeTimeFormat",
        "func": "// Node-RED Function Node - Normalize Time Format\n// This code is designed to run inside a Node-RED Function node\n// Converts ISO datetime strings to separated date and time with timezone offset\n// Handles both ISO format and already-separated date/time formats\n\n/**\n * ============================================================================\n * NORMALIZE TIME FORMAT - Node-RED Function\n * ============================================================================\n * Converts time formats and creates convertedDateTime object with convertedDate and convertedTime.\n * \n * Handles multiple input formats:\n * - ISO with timezone: \"2026-04-13T16:00:00.000-04:00\" \n *   -> convertedDate: \"2026-04-13\", convertedTime: \"16:00:00.000-04:00\"\n * - ISO without timezone: \"2026-04-13T16:00:00\"\n *   -> convertedDate: \"2026-04-13\", convertedTime: \"16:00:00.000-04:00\" (detects timezone)\n * - Already separated 12-hour: apptTime: \"10:00 PM\", apptDate: \"2026-04-13\"\n *   -> convertedDate: \"2026-04-13\", convertedTime: \"10:00 PM\" (uses as-is)\n * - Already separated 24-hour: apptTime: \"15:15\", apptDate: \"2026-05-14\"\n *   -> convertedDate: \"2026-05-14\", convertedTime: \"3:15 PM\" (converts to 12-hour)\n * \n * Expected msg properties:\n * - msg.payload: Object with:\n *   - apptTime or time: Time string (ISO, 12-hour format, or 24-hour HH:MM format)\n *   - apptDate or date: Date string (YYYY-MM-DD format, optional if ISO format)\n * \n * Output msg properties:\n * - msg.payload.convertedDateTime: Object with:\n *   - convertedDate: \"YYYY-MM-DD\"\n *   - convertedTime: \"HH:mm:ss.SSS-04:00\" or \"h:mm A\" (12-hour format)\n * \n * Setup tab: Declare moment-timezone dependency:\n *   const moment = require('moment-timezone');\n */\n\n// ============================================================================\n// 🔧 UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check if a time string is in 12-hour format (e.g., \"10:00 PM\")\n */\nfunction is12HourFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for AM/PM indicators\n    return /^\\d{1,2}:\\d{2}\\s*(AM|PM)/i.test(timeString.trim());\n}\n\n/**\n * Check if a time string is in ISO format (with or without timezone)\n */\nfunction isISOFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for ISO format: contains 'T' and time pattern\n    return /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(timeString);\n}\n\n/**\n * Check if a time string is in 24-hour format without seconds (e.g., \"15:15\")\n */\nfunction is24HourFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for HH:MM format (24-hour, no seconds, no AM/PM)\n    // Must be exactly 5 characters (HH:MM) and match pattern\n    const trimmed = timeString.trim();\n    return /^\\d{2}:\\d{2}$/.test(trimmed) && trimmed.length === 5;\n}\n\n/**\n * Extract timezone offset from ISO string or detect from date\n * @param {string} isoString - ISO datetime string\n * @returns {string} Timezone offset like \"-04:00\" or \"+00:00\"\n */\nfunction getTimezoneOffset(isoString) {\n    if (!isoString || typeof isoString !== 'string') {\n        return '+00:00'; // Default to UTC\n    }\n    \n    // Check if timezone is already in the string\n    const tzMatch = isoString.match(/([+-]\\d{2}):(\\d{2})$/);\n    if (tzMatch) {\n        // Return with colon separator\n        return `${tzMatch[1]}:${tzMatch[2]}`;\n    }\n    \n    // Check for Z (UTC)\n    if (isoString.endsWith('Z')) {\n        return '+00:00';\n    }\n    \n    // If no timezone, parse the date and determine timezone\n    try {\n        // Try to parse as UTC first\n        let momentObj = moment.utc(isoString);\n        \n        if (!momentObj.isValid()) {\n            // Try parsing as local time\n            momentObj = moment(isoString);\n        }\n        \n        if (momentObj.isValid()) {\n            // Convert to Eastern timezone to get the offset\n            const easternMoment = momentObj.tz('America/New_York');\n            const offsetMinutes = easternMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            \n            return `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        }\n    } catch (error) {\n        node.warn(`[normalizeTimeFormat] Error determining timezone for ${isoString}: ${error.message}`);\n    }\n    \n    // Default to UTC if we can't determine\n    return '+00:00';\n}\n\n/**\n * Convert ISO datetime to convertedDateTime object\n * Preserves the time value and only adds the timezone offset (does not convert timezone)\n * @param {string} isoString - ISO datetime string\n * @param {string} [dateString] - Optional date string (if already separated)\n * @returns {object} { convertedDate: string, convertedTime: string }\n */\nfunction convertISOToDateTime(isoString, dateString = null) {\n    if (!isoString || typeof isoString !== 'string') {\n        return null;\n    }\n    \n    try {\n        // Extract date and time portions directly from the ISO string\n        const dateMatch = isoString.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n        const timeMatch = isoString.match(/T(\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?)/);\n        \n        if (!dateMatch || !timeMatch) {\n            node.warn(`[normalizeTimeFormat] Could not parse ISO string: ${isoString}`);\n            return null;\n        }\n        \n        // Extract date (YYYY-MM-DD)\n        const convertedDate = dateMatch[1];\n        \n        // Extract time portion (preserve as-is, don't convert)\n        let timePortion = timeMatch[1];\n        \n        // Ensure milliseconds are present (add .000 if missing)\n        if (!timePortion.includes('.')) {\n            timePortion += '.000';\n        }\n        \n        // Check if timezone offset is already in the string\n        const tzMatch = isoString.match(/([+-]\\d{2}):(\\d{2})$/);\n        let offset;\n        \n        if (tzMatch) {\n            // Use the existing timezone offset\n            offset = `${tzMatch[1]}:${tzMatch[2]}`;\n        } else if (isoString.endsWith('Z')) {\n            // UTC - but we need to determine Eastern timezone offset for this date\n            const dateMoment = moment.tz(convertedDate + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        } else {\n            // No timezone specified - determine Eastern timezone offset for this date\n            // Parse the date to determine if it's DST or not\n            const dateMoment = moment.tz(convertedDate + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        }\n        \n        const convertedTime = `${timePortion}${offset}`;\n        \n        // Create full ISO8601 string: YYYY-MM-DDTHH:mm:ss.SSS-04:00\n        const convertedDateTime = `${convertedDate}T${convertedTime}`;\n        \n        return {\n            convertedDate,\n            convertedTime,\n            convertedDateTime\n        };\n        \n    } catch (error) {\n        node.warn(`[normalizeTimeFormat] Error converting ISO: ${isoString}, error: ${error.message}`);\n        return null;\n    }\n}\n\n/**\n * Process an object and return convertedEntry object\n * @param {object} obj - Object to process\n * @returns {object} convertedEntry object with convertedDate, convertedTime, and convertedDateTime\n */\nfunction processObject(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return null;\n    }\n    \n    // Look for time field (apptTime, time, or end_time)\n    const timeField = obj.apptTime || obj.time || obj.end_time;\n    const dateField = obj.apptDate || obj.date;\n    \n    if (!timeField) {\n        return null;\n    }\n    \n    // Check if it's already in correct format (12-hour with separate date)\n    if (is12HourFormat(timeField) && dateField) {\n        // Already in correct format - use as-is\n        // Create ISO8601 string by parsing the 12-hour time and date\n        try {\n            const combinedString = `${dateField} ${timeField}`;\n            const parsedMoment = moment(combinedString, 'YYYY-MM-DD h:mm A');\n            \n            if (parsedMoment.isValid()) {\n                // Determine timezone offset for this date\n                const dateMoment = moment.tz(dateField + 'T12:00:00', 'America/New_York');\n                const offsetMinutes = dateMoment.utcOffset();\n                const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n                const offsetMins = Math.abs(offsetMinutes) % 60;\n                const sign = offsetMinutes >= 0 ? '+' : '-';\n                const offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n                \n                // Format time as 24-hour with milliseconds\n                const time24Hour = parsedMoment.format('HH:mm:ss') + '.000';\n                const convertedDateTime = `${dateField}T${time24Hour}${offset}`;\n                \n                return {\n                    convertedDate: dateField,\n                    convertedTime: timeField,\n                    convertedDateTime: convertedDateTime\n                };\n            }\n        } catch (error) {\n            node.warn(`[normalizeTimeFormat] Error parsing 12-hour format: ${error.message}`);\n        }\n        \n        // Fallback if parsing fails\n        return {\n            convertedDate: dateField,\n            convertedTime: timeField,\n            convertedDateTime: null\n        };\n    } else if (is24HourFormat(timeField) && dateField) {\n        // 24-hour format (HH:MM) with separate date - convert it\n        // Assumes America/New_York timezone, does not adjust the date\n        try {\n            // Validate date format (YYYY-MM-DD)\n            if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(dateField)) {\n                node.warn(`[normalizeTimeFormat] Invalid date format: ${dateField}`);\n                return {\n                    convertedDate: dateField,\n                    convertedTime: timeField,\n                    convertedDateTime: null\n                };\n            }\n            \n            // Determine timezone offset for America/New_York (handles DST automatically)\n            // Date is preserved as-is, only used to determine correct offset\n            const dateMoment = moment.tz(dateField + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            const offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n            \n            // Format time as HH:mm:ss.000 with timezone offset (date unchanged)\n            const timeWithSeconds = timeField + ':00.000';\n            const convertedTime = `${timeWithSeconds}${offset}`;\n            const convertedDateTime = `${dateField}T${convertedTime}`;\n            \n            // Convert to 12-hour format for convertedTime (to match expected output)\n            const parsedMoment = moment(`${dateField} ${timeField}`, 'YYYY-MM-DD HH:mm');\n            const time12Hour = parsedMoment.isValid() ? parsedMoment.format('h:mm A') : timeField;\n            \n            return {\n                convertedDate: dateField, // Date preserved as-is\n                convertedTime: time12Hour,\n                convertedDateTime: convertedDateTime\n            };\n        } catch (error) {\n            node.warn(`[normalizeTimeFormat] Error parsing 24-hour format: ${error.message}`);\n            return {\n                convertedDate: dateField,\n                convertedTime: timeField,\n                convertedDateTime: null\n            };\n        }\n    } else if (isISOFormat(timeField)) {\n        // ISO format - convert it\n        const converted = convertISOToDateTime(timeField, dateField);\n        return converted;\n    } else {\n        // Unknown format - try to use as-is\n        node.warn(`[normalizeTimeFormat] Unknown time format: ${timeField}`);\n        return {\n            convertedDate: dateField || null,\n            convertedTime: timeField,\n            convertedDateTime: null\n        };\n    }\n}\n\n// ============================================================================\n// 🚀 MAIN EXECUTION\n// ============================================================================\n\ntry {\n    const payload = msg.payload;\n    \n    if (!payload) {\n        node.log('[normalizeTimeFormat] No payload to process');\n        return msg;\n    }\n    \n    // Process the payload object to create convertedEntry\n    let convertedEntry = null;\n    \n    if (typeof payload === 'string') {\n        // Single time string - try to convert\n        convertedEntry = convertISOToDateTime(payload);\n        node.log(`[normalizeTimeFormat] Processed single time string`);\n    } else if (typeof payload === 'object') {\n        // Object - process it\n        convertedEntry = processObject(payload);\n        node.log('[normalizeTimeFormat] Processed object');\n    }\n    \n    // Set msg.convertedEntry if we have a result\n    if (convertedEntry) {\n        msg.convertedEntry = convertedEntry;\n        \n        // Log example conversion for debugging\n        node.log(`[normalizeTimeFormat] convertedDate=${convertedEntry.convertedDate}, convertedTime=${convertedEntry.convertedTime}, convertedDateTime=${convertedEntry.convertedDateTime}`);\n    } else {\n        node.warn('[normalizeTimeFormat] No convertedEntry created - check input format');\n    }\n    \n    // Keep original payload intact\n    // msg.payload remains unchanged\n    \n    return msg;\n    \n} catch (error) {\n    node.error('[normalizeTimeFormat] Error: ' + error.message, msg);\n    \n    msg.payload = {\n        error: error.message,\n        originalPayload: msg.payload\n    };\n    \n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "moment",
                "module": "moment-timezone"
            }
        ],
        "x": 800,
        "y": 1480,
        "wires": [
            [
                "1476be69d5af1e85",
                "c56b15f387d9cb2a"
            ]
        ]
    },
    {
        "id": "5a0c4c38c8525ba3",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "convertGroupedTimeFormat",
        "func": "// Node-RED Function Node - Convert Time Format and Timezone for Grouped Appointments\n// This code is designed to run inside a Node-RED Function node\n// Converts between 12-hour and 24-hour formats and between timezones with DST handling\n// Works with the grouped appointments structure from nodeFilterGroupedAppts.js\n// Uses moment-timezone for reliable timezone and DST conversions\n\n/**\n * ============================================================================\n * CONVERT GROUPED TIME FORMAT AND TIMEZONE - Node-RED Function\n * ============================================================================\n * Flexible time conversion function for grouped appointments that can:\n * - Convert between 12-hour (e.g., \"9:00 PM\") and 24-hour (e.g., \"21:00\") formats\n * - Convert between timezones (e.g., UTC to EST/EDT) with automatic DST handling\n * - Handle ISO datetime strings with timezone information\n * \n * Configuration (via msg properties or environment variables):\n * - msg.timeFormat: \"12hour\" or \"24hour\" (output format, default: \"12hour\")\n * - msg.fromTimezone: Source timezone (e.g., \"UTC\", \"America/New_York\", default: auto-detect)\n * - msg.toTimezone: Target timezone (e.g., \"America/New_York\", \"UTC\", default: \"America/New_York\")\n * - msg.dateFormat: Date format string (optional, default: \"YYYY-MM-DD\")\n * - msg.timeFormatString: Custom time format string (optional, overrides timeFormat)\n * \n * Environment variables (fallback if msg properties not set):\n * - timeFormat: \"12hour\" or \"24hour\"\n * - fromTimezone: Source timezone\n * - toTimezone: Target timezone\n * \n * Expected msg properties:\n * - msg.payload.groups: Array of appointment groups\n *   - Each group contains an appointments array:\n *     - { appointments: [{ time: \"2026-04-14T15:00:00.000Z\", end_time: \"...\", operatory_id: 123 }] }\n * - msg.payload.totalGroups: Number of groups (optional)\n * \n * Output msg properties:\n * - msg.payload.groups: Array of appointment groups with converted times\n * - msg.payload.totalGroups: Number of groups (preserved)\n * - msg.conversionInfo: Metadata about the conversion performed\n * \n * Setup tab: Declare moment-timezone dependency:\n *   const moment = require('moment-timezone');\n */\n\n// ============================================================================\n// 🔧 CONFIGURATION\n// ============================================================================\n\n// Get configuration from msg properties or environment variables\nconst config = {\n    // Output format: \"12hour\" or \"24hour\"\n    timeFormat: msg.timeFormat || env.get(\"timeFormat\") || \"12hour\",\n    \n    // Source timezone (null = auto-detect from input)\n    fromTimezone: msg.fromTimezone || env.get(\"fromTimezone\") || null,\n    \n    // Target timezone\n    toTimezone: msg.toTimezone || env.get(\"toTimezone\") || \"America/New_York\",\n    \n    // Date format (optional)\n    dateFormat: msg.dateFormat || env.get(\"dateFormat\") || \"YYYY-MM-DD\",\n    \n    // Custom time format string (optional, overrides timeFormat)\n    timeFormatString: msg.timeFormatString || env.get(\"timeFormatString\") || null\n};\n\n// Validate timeFormat\nif (config.timeFormat !== \"12hour\" && config.timeFormat !== \"24hour\") {\n    node.warn(`[convertGroupedTimeFormat] Invalid timeFormat: ${config.timeFormat}. Using default: 12hour`);\n    config.timeFormat = \"12hour\";\n}\n\n// ============================================================================\n// 🔧 UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Detect the format of a time string\n * @param {string} timeString - Time string to analyze\n * @returns {object} { format: \"iso\"|\"12hour\"|\"24hour\", hasDate: boolean }\n */\nfunction detectTimeFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return { format: null, hasDate: false };\n    }\n    \n    // Check for ISO format (contains T and timezone info)\n    if (timeString.includes('T') && (timeString.includes('Z') || timeString.match(/[+-]\\d{2}:\\d{2}$/))) {\n        return { format: \"iso\", hasDate: true };\n    }\n    \n    // Check for ISO format without timezone (contains T)\n    if (timeString.includes('T')) {\n        return { format: \"iso\", hasDate: true };\n    }\n    \n    // Check for 12-hour format (contains AM/PM)\n    if (timeString.match(/\\d{1,2}:\\d{2}\\s*(AM|PM)/i)) {\n        return { format: \"12hour\", hasDate: false };\n    }\n    \n    // Check for 24-hour format (HH:MM or HH:MM:SS)\n    if (timeString.match(/^\\d{1,2}:\\d{2}(:\\d{2})?$/)) {\n        return { format: \"24hour\", hasDate: false };\n    }\n    \n    // Default to ISO if we can't determine\n    return { format: \"iso\", hasDate: true };\n}\n\n/**\n * Parse a time string into a moment object\n * @param {string} timeString - Time string to parse\n * @param {string} dateString - Optional date string (YYYY-MM-DD)\n * @param {string} fromTimezone - Source timezone (null = auto-detect)\n * @returns {object} moment object or null if parsing fails\n */\nfunction parseTimeString(timeString, dateString, fromTimezone) {\n    if (!timeString) {\n        return null;\n    }\n    \n    const formatInfo = detectTimeFormat(timeString);\n    let momentObj = null;\n    \n    try {\n        if (formatInfo.format === \"iso\") {\n            // ISO format - parse with moment\n            momentObj = moment(timeString);\n            \n            // If fromTimezone is specified, treat as that timezone\n            if (fromTimezone && momentObj.isValid()) {\n                momentObj = moment.tz(timeString, fromTimezone);\n            } else if (momentObj.isValid()) {\n                // Try to preserve timezone if present, otherwise assume UTC\n                if (!timeString.includes('Z') && !timeString.match(/[+-]\\d{2}:\\d{2}$/)) {\n                    momentObj = moment.utc(timeString);\n                }\n            }\n        } else if (formatInfo.format === \"12hour\") {\n            // 12-hour format - need date string\n            if (!dateString) {\n                node.warn(`[convertGroupedTimeFormat] 12-hour time format requires date. Time: ${timeString}`);\n                return null;\n            }\n            \n            const combinedString = `${dateString} ${timeString}`;\n            const format = `${config.dateFormat} h:mm A`;\n            momentObj = moment(combinedString, format);\n            \n            // Apply source timezone if specified\n            if (fromTimezone && momentObj.isValid()) {\n                momentObj = moment.tz(combinedString, format, fromTimezone);\n            }\n        } else if (formatInfo.format === \"24hour\") {\n            // 24-hour format - need date string\n            if (!dateString) {\n                node.warn(`[convertGroupedTimeFormat] 24-hour time format requires date. Time: ${timeString}`);\n                return null;\n            }\n            \n            const combinedString = `${dateString} ${timeString}`;\n            const format = `${config.dateFormat} HH:mm`;\n            momentObj = moment(combinedString, format);\n            \n            // Apply source timezone if specified\n            if (fromTimezone && momentObj.isValid()) {\n                momentObj = moment.tz(combinedString, format, fromTimezone);\n            }\n        }\n        \n        if (!momentObj || !momentObj.isValid()) {\n            node.warn(`[convertGroupedTimeFormat] Could not parse time: ${timeString}`);\n            return null;\n        }\n        \n        return momentObj;\n        \n    } catch (error) {\n        node.warn(`[convertGroupedTimeFormat] Error parsing time ${timeString}: ${error.message}`);\n        return null;\n    }\n}\n\n/**\n * Format a moment object to the desired output format\n * @param {object} momentObj - moment object to format\n * @returns {object} { time: string, date: string }\n */\nfunction formatMoment(momentObj) {\n    if (!momentObj || !momentObj.isValid()) {\n        return { time: null, date: null };\n    }\n    \n    // Convert to target timezone\n    const convertedMoment = momentObj.tz(config.toTimezone);\n    \n    // Format date\n    const date = convertedMoment.format(config.dateFormat);\n    \n    // Format time based on configuration\n    let time;\n    if (config.timeFormatString) {\n        // Use custom format string\n        time = convertedMoment.format(config.timeFormatString);\n    } else if (config.timeFormat === \"12hour\") {\n        // 12-hour format: \"9:00 PM\"\n        time = convertedMoment.format(\"h:mm A\");\n    } else {\n        // 24-hour format: \"21:00\"\n        time = convertedMoment.format(\"HH:mm\");\n    }\n    \n    return { time, date };\n}\n\n/**\n * Convert a time string to the desired format and timezone\n * @param {string} timeString - Time string to convert\n * @param {string} dateString - Optional date string (for non-ISO formats)\n * @returns {object} { time: string, date: string }\n */\nfunction convertTime(timeString, dateString) {\n    if (!timeString) {\n        return { time: null, date: null };\n    }\n    \n    // Parse the input time\n    const momentObj = parseTimeString(timeString, dateString, config.fromTimezone);\n    \n    if (!momentObj) {\n        // Return original if we can't parse\n        return { time: timeString, date: dateString || null };\n    }\n    \n    // Format to desired output\n    const formatted = formatMoment(momentObj);\n    \n    return {\n        time: formatted.time,\n        date: formatted.date\n    };\n}\n\n// ============================================================================\n// 🚀 MAIN EXECUTION\n// ============================================================================\n\ntry {\n    // Get payload structure\n    const payload = msg.payload;\n    \n    // Validate payload structure\n    if (!payload || typeof payload !== 'object') {\n        throw new Error('Payload must be an object. Received: ' + typeof payload);\n    }\n    \n    // Get groups array\n    const groups = payload.groups;\n    \n    if (!Array.isArray(groups)) {\n        throw new Error('payload.groups must be an array. Received: ' + typeof groups);\n    }\n    \n    if (groups.length === 0) {\n        node.log('[convertGroupedTimeFormat] No groups to convert');\n        return msg;\n    }\n    \n    node.log(`[convertGroupedTimeFormat] Converting times in ${groups.length} groups`);\n    node.log(`[convertGroupedTimeFormat] Config: format=${config.timeFormat}, from=${config.fromTimezone || 'auto'}, to=${config.toTimezone}`);\n    \n    let totalAppointmentsConverted = 0;\n    let totalAppointmentsProcessed = 0;\n    \n    // Convert each group's appointments\n    const convertedGroups = groups.map((group, groupIndex) => {\n        // Create a copy of the group\n        const convertedGroup = { ...group };\n        \n        // Check if group has appointments array\n        if (!Array.isArray(group.appointments)) {\n            node.warn(`[convertGroupedTimeFormat] Group ${groupIndex} does not have appointments array`);\n            return convertedGroup;\n        }\n        \n        // Convert each appointment in the group\n        const convertedAppointments = group.appointments.map((appointment, apptIndex) => {\n            const convertedAppointment = { ...appointment }; // Create a copy\n            totalAppointmentsProcessed++;\n            \n            // Extract date from ISO time if available (for non-ISO formats)\n            let appointmentDate = null;\n            if (appointment.time && appointment.time.includes('T')) {\n                const dateMatch = appointment.time.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n                if (dateMatch) {\n                    appointmentDate = dateMatch[1];\n                }\n            }\n            \n            // Convert time field\n            if (appointment.time) {\n                const originalTime = appointment.time;\n                const converted = convertTime(appointment.time, appointmentDate);\n                convertedAppointment.time = converted.time;\n                \n                // Update date if we got a new one\n                if (converted.date) {\n                    convertedAppointment.date = converted.date;\n                }\n                \n                // Log first few conversions for debugging\n                if (groupIndex < 2 && apptIndex < 2) {\n                    node.log(`[convertGroupedTimeFormat] Group ${groupIndex}, Appointment ${apptIndex}: ${originalTime} -> ${convertedAppointment.time} (${config.toTimezone})`);\n                }\n                \n                if (convertedAppointment.time !== originalTime) {\n                    totalAppointmentsConverted++;\n                }\n            } else {\n                node.warn(`[convertGroupedTimeFormat] Group ${groupIndex}, Appointment ${apptIndex} missing 'time' field`);\n            }\n            \n            // Convert end_time field\n            if (appointment.end_time) {\n                const converted = convertTime(appointment.end_time, appointmentDate);\n                convertedAppointment.end_time = converted.time;\n            } else if (appointment.time) {\n                // If no end_time but has time, use the same converted time\n                convertedAppointment.end_time = convertedAppointment.time;\n            }\n            \n            return convertedAppointment;\n        });\n        \n        // Update the group with converted appointments\n        convertedGroup.appointments = convertedAppointments;\n        \n        return convertedGroup;\n    });\n    \n    node.log(`[convertGroupedTimeFormat] Successfully converted ${totalAppointmentsConverted} of ${totalAppointmentsProcessed} appointment times`);\n    \n    // Update payload with converted groups\n    msg.payload = {\n        ...payload, // Preserve other payload properties (like totalGroups, providerInfo, etc.)\n        groups: convertedGroups\n    };\n    \n    // Add metadata about conversion\n    msg.conversionInfo = {\n        totalGroups: convertedGroups.length,\n        totalAppointmentsProcessed: totalAppointmentsProcessed,\n        totalAppointmentsConverted: totalAppointmentsConverted,\n        timeFormat: config.timeFormat,\n        fromTimezone: config.fromTimezone || \"auto-detected\",\n        toTimezone: config.toTimezone,\n        dateFormat: config.dateFormat\n    };\n    \n    return msg;\n    \n} catch (error) {\n    node.error('[convertGroupedTimeFormat] Error: ' + error.message, msg);\n    \n    msg.payload = {\n        error: error.message,\n        originalPayload: msg.payload,\n        config: config\n    };\n    \n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "moment",
                "module": "moment-timezone"
            }
        ],
        "x": 1420,
        "y": 1180,
        "wires": [
            [
                "e211e5722f86e26b",
                "c98fb9e6c18da833",
                "dbaecfb7ced92ed9"
            ]
        ]
    },
    {
        "id": "abd2a679ee994abc",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "BadFormat",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.patientId",
                "v": "432833620",
                "vt": "str"
            },
            {
                "p": "payload.apptTime",
                "v": "2026-05-13T08:00:00",
                "vt": "str"
            },
            {
                "p": "payload.operatoryId",
                "v": "24843",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 300,
        "y": 1400,
        "wires": [
            []
        ]
    },
    {
        "id": "14e9b9f9e6b846fb",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "",
        "props": [
            {
                "p": "payload.uui",
                "v": "�\b,\u0007\ti8�g765313363-000000000001105456-SR-000-000000000000DEN130-248B8ED6|333725|421458314VO|5214da68-3794-4d42-be9c-7d5df787ab0b|FSV",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 310,
        "y": 1920,
        "wires": [
            [
                "607df74a9384e68d"
            ]
        ]
    },
    {
        "id": "8c230b9d2435e680",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "Location Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1960,
        "wires": []
    },
    {
        "id": "3ba1fad23a5cb964",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 1960,
        "wires": []
    },
    {
        "id": "2334696f7e7a1b88",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "47b76f2157d33f68",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 3000,
        "wires": [
            [
                "3e3ef37154695dd1"
            ]
        ]
    },
    {
        "id": "b19458dc88b6af84",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "47b76f2157d33f68",
        "name": "debug 61",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 560,
        "y": 3000,
        "wires": []
    },
    {
        "id": "112ffa2fe18b9448",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "a372f53aad09888a",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 820,
        "y": 3000,
        "wires": [
            [
                "da286309356ac2fe"
            ]
        ]
    },
    {
        "id": "62dd58bba415f00d",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "a372f53aad09888a",
        "name": "debug 62",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 3000,
        "wires": []
    },
    {
        "id": "31b309561adc169e",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "ParseUui",
        "rules": [
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(payload.uui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 2040,
        "y": 220,
        "wires": [
            [
                "dbfdafad659a5e4a"
            ]
        ]
    },
    {
        "id": "7356633aed44023a",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "ParseUui",
        "rules": [
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(payload.uui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 2480,
        "y": 1700,
        "wires": [
            []
        ]
    },
    {
        "id": "6d8df77c8ad35b6b",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "b2d67743184cc26e",
        "name": "ParseUui",
        "rules": [
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(payload.uui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 2440,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "8a35fb512ca3562c",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "Parsed Create",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 560,
        "y": 1520,
        "wires": []
    },
    {
        "id": "58b46383a7cab2ca",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "",
        "url": "/chord/getLocation",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 1960,
        "wires": [
            [
                "607df74a9384e68d"
            ]
        ]
    },
    {
        "id": "e926510bf2efba77",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "Ingress GetLocation",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 560,
        "y": 1920,
        "wires": []
    },
    {
        "id": "4101412b851fce41",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "Parsed Location",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 2000,
        "wires": []
    },
    {
        "id": "d40e6e5eba28dffe",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "Parsed Grouped",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 1260,
        "wires": []
    },
    {
        "id": "b25b992651ad9d6b",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "Parsed Appt",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 1040,
        "wires": []
    },
    {
        "id": "6e8029b299e0062a",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "Parsed PatientAppts",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 800,
        "wires": []
    },
    {
        "id": "7b1422ce1e8ee8f0",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "Parsed PatientByPhone",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 400,
        "wires": []
    },
    {
        "id": "fcc6bfb2aea05f82",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "",
        "rules": [
            {
                "t": "delete",
                "p": "payload.institution_id",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.country_code",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.created_at",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.updated_at",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.foreign_id",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.foreign_id_type",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.last_sync_time",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.insert_appt_client",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.map_by_operatory",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payloadpayload.appt_types_map_by_operatory",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.set_availability_by_operatory",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.inactive",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.wlogo",
                "pt": "msg"
            },
            {
                "t": "delete",
                "p": "payload.weight",
                "pt": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 960,
        "y": 1960,
        "wires": [
            [
                "3ba1fad23a5cb964",
                "8c230b9d2435e680"
            ]
        ]
    },
    {
        "id": "63626ca29ccfda8e",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "fullLocation",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 2000,
        "wires": []
    },
    {
        "id": "08b04d2fa7ec4bba",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "fa6c90989b81f095",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 280,
        "y": 3420,
        "wires": [
            [
                "898a645711dd0925"
            ]
        ]
    },
    {
        "id": "b7f02451dfdd1e3c",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "fa6c90989b81f095",
        "name": "debug 60",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 3420,
        "wires": []
    },
    {
        "id": "6f6cefdc8bf1a800",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "fa6c90989b81f095",
        "name": "",
        "url": "/chord/getPayments",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 280,
        "y": 3480,
        "wires": [
            [
                "898a645711dd0925"
            ]
        ]
    },
    {
        "id": "7582f8f3cb420cbc",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "new",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.patientId",
                "v": "435186661",
                "vt": "str"
            },
            {
                "p": "payload.apptTime",
                "v": "15:15",
                "vt": "str"
            },
            {
                "p": "payload.operatoryId",
                "v": "24844",
                "vt": "str"
            },
            {
                "p": "payload.apptDate",
                "v": "2026-05-14",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u0007\u0005i8l2765305129-000000000001105456-SR-000-000000000000DEN140-5AA00C14|333725|421458314VO|6733e082-0129-4e68-97dc-bd8b71aa02a6|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 130,
        "y": 1440,
        "wires": [
            [
                "5d0d05d9d9b8e123"
            ]
        ]
    },
    {
        "id": "3d1fb48e2d0ea29e",
        "type": "inject",
        "z": "cb091dda25252c01",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "120",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 770,
        "y": 80,
        "wires": [
            [
                "c69245590dbba11e"
            ]
        ]
    },
    {
        "id": "c69245590dbba11e",
        "type": "function",
        "z": "cb091dda25252c01",
        "name": "Authenticate",
        "func": "// Node-RED Function Node - Scheduled Authentication\n// This code is designed to run inside a Node-RED Function node\n// Configure this node to run on a schedule (e.g., every 5 minutes using an inject node with repeat)\n// Authenticates with NexHealth API and stores the bearer token in flow context\n// Other nodes can use this token without re-authenticating\n// \n// Setup: Connect an inject node with \"Repeat\" set to \"interval\" and \"every\" set to \"5 minutes\"\n//        This will ensure the token is checked and renewed automatically\n\n/* global fetch, node, msg, flow */\n\n// Get API key from environment\nconst apiKey = env.get(\"apiKey\");\n\n// Token expiration time in milliseconds (default: 1 hour = 3600000ms)\n// NexHealth tokens typically expire after some time, adjust if needed\nconst TOKEN_EXPIRATION_MS = 3600000; // 1 hour\n\n// Buffer time before expiration to renew token (default: 10 minutes = 600000ms)\n// This ensures we renew the token before it expires\nconst RENEWAL_BUFFER_MS = 600000; // 10 minutes\n\nasync function checkAndRenewToken() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        // Check if we have a token in flow context\n        const storedToken = flow.get(\"nexhealth_auth_token\");\n        const tokenTimestamp = flow.get(\"nexhealth_auth_token_timestamp\");\n\n        let needsRenewal = false;\n\n        // Check if token exists and is still valid\n        if (storedToken && tokenTimestamp) {\n            const now = Date.now();\n            const tokenAge = now - tokenTimestamp;\n            const timeUntilExpiration = TOKEN_EXPIRATION_MS - tokenAge;\n\n            // Check if token is expired or will expire soon (within renewal buffer)\n            if (tokenAge >= TOKEN_EXPIRATION_MS) {\n                node.warn('[authenticate] Token expired (age: ' + Math.round(tokenAge / 1000) + 's), renewing...');\n                needsRenewal = true;\n            } else if (timeUntilExpiration <= RENEWAL_BUFFER_MS) {\n                node.warn('[authenticate] Token expires soon (' + Math.round(timeUntilExpiration / 1000) + 's), renewing proactively...');\n                needsRenewal = true;\n            } else {\n                node.warn('[authenticate] Token is valid (expires in ' + Math.round(timeUntilExpiration / 1000) + 's)');\n                // Token is still valid, no need to renew\n                msg.payload = {\n                    success: true,\n                    token: storedToken,\n                    cached: true,\n                    tokenAge: tokenAge,\n                    expiresIn: timeUntilExpiration\n                };\n                return msg;\n            }\n        } else {\n            // No token exists, need to authenticate\n            node.warn('[authenticate] No token found, authenticating...');\n            needsRenewal = true;\n        }\n\n        // Authenticate to get a new token\n        if (needsRenewal) {\n            node.warn('[authenticate] Authenticating with NexHealth API...');\n            const requestOptions = {\n                method: \"POST\",\n                headers: {\n                    \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                    \"Authorization\": apiKey\n                },\n                redirect: \"follow\"\n            };\n\n            const authResponse = await fetch(\"https://nexhealth.info/authenticates\", requestOptions);\n\n            // Check for HTTP errors\n            if (!authResponse.ok) {\n                const errorText = await authResponse.text().catch(() => 'Unable to read error response');\n                throw new Error(`Authentication failed with status ${authResponse.status}: ${errorText}`);\n            }\n\n            // Parse and validate authentication response\n            let authResult;\n            try {\n                authResult = await authResponse.json();\n            } catch (parseError) {\n                throw new Error(`Failed to parse authentication response: ${parseError.message}`);\n            }\n\n            node.warn('[authenticate] Auth response received');\n\n            if (!authResult.data || !authResult.data.token) {\n                throw new Error('Authentication token not found in response. Response structure may have changed.');\n            }\n\n            const authToken = authResult.data.token;\n\n            // Store token and timestamp in flow context\n            flow.set(\"nexhealth_auth_token\", authToken);\n            flow.set(\"nexhealth_auth_token_timestamp\", Date.now());\n\n            node.log('[authenticate] Token stored in flow context (valid for ' + Math.round(TOKEN_EXPIRATION_MS / 1000) + 's)');\n\n            // Return token in message\n            msg.payload = {\n                success: true,\n                token: authToken,\n                cached: false,\n                tokenAge: 0,\n                expiresIn: TOKEN_EXPIRATION_MS\n            };\n\n            return msg;\n        }\n\n\n    } catch (error) {\n        node.error('[authenticate] Error authenticating: ' + error.message, msg);\n\n        // Clear any invalid tokens\n        flow.set(\"nexhealth_auth_token\", null);\n        flow.set(\"nexhealth_auth_token_timestamp\", null);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during authentication',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn checkAndRenewToken();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 970,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "4838d0bef9c86f85",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "getPatientByEmail-NA",
        "func": "// Node-RED Function Node - Get Patient By Email\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst locationId = msg.session.locationId || msg.payload.locationId || env.get(\"locationId\");\nconst subdomain = msg.payload.subdomain || msg.subdomain || \"cdm\";\nconst perPage = msg.payload.perPage || msg.payload.per_page || 200;\nconst location_strict = msg.payload.locationStrict || false;\n\nconst requestEndpoint = \"https://nexhealth.info/patients\";\n\nconst email = msg.payload.email || msg.email;\n\nasync function getPatientByEmail() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!email) {\n            throw new Error('Email is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n                // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters to search by email\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`,\n            `email=${encodeURIComponent(email)}`,\n            `per_page=${encodeURIComponent(perPage)}`,\n            `location_strict=${encodeURIComponent(location_strict)}`\n        ];\n\n        // Build the full URL\n        const url = `${requestEndpoint}?${queryParts.join('&')}`;\n\n        const patientRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn(`Searching for patient with email: ${email}...`);\n        const patientResponse = await fetch(url, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get patient by email failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient response: ${parseError.message}`);\n        }\n\n        node.warn('Patient search completed');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Check if any patients were found\n        const patients = Array.isArray(result.data) ? result.data : [result.data];\n\n        if (patients.length === 0) {\n            node.warn(`No patient found with email: ${email}`);\n            msg.payload = {\n                success: true,\n                message: 'No patient found with this email',\n                found: false,\n                email: email,\n                patient: null\n            };\n        } else {\n            node.warn(`Found ${patients.length} patient(s) with email: ${email}`);\n\n            // If multiple patients found, return the first one but include count\n            msg.payload = {\n                success: true,\n                message: patients.length === 1 ? 'Patient found' : `Found ${patients.length} patients`,\n                found: true,\n                count: patients.length,\n                patient: patients[0],\n                allPatients: patients.length > 1 ? patients : undefined\n            };\n\n            // Set payload to just the patient data for easier downstream processing\n            msg.payload = patients;\n        }\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patient by email: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while searching for patient',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getPatientByEmail();\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 960,
        "y": 180,
        "wires": [
            [
                "4625dd1161a71643",
                "4ae654ff0152fe6b"
            ]
        ]
    },
    {
        "id": "83dede7b863766d4",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "getPatientAppts-NA",
        "func": "// Node-RED Function Node - Get Patient Appointments\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst subdomain = msg.payload.subdomain || msg.subdomain || \"cdm\";\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst patientId = msg.payload.patientId;\nconst cancelled = msg.payload.cancelled !== undefined ? msg.payload.cancelled : false;\n\n// Helper function to format date as YYYY-MM-DD\nconst formatDate = (date) => {\n    const d = new Date(date);\n    const year = d.getFullYear();\n    const month = String(d.getMonth() + 1).padStart(2, '0');\n    const day = String(d.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n};\n\n// Date range parameters (default to today and ~14 months from today in YYYY-MM-DD format)\nconst startDate = msg.payload.startDate || msg.startDate || formatDate(new Date());\nconst endDate = msg.payload.endDate || msg.endDate || formatDate(new Date(Date.now() + 425 * 24 * 60 * 60 * 1000));\n\n// Provider IDs filter - can be array or single value\n// Get from msg.payload.providerIds, msg.providerIds, or env variable\nlet providerIds = msg.payload.providerIds || msg.providerIds;\n\nif (!providerIds && providerId) {\n    providerIds = [providerId];\n}\nif (!Array.isArray(providerIds) && providerIds) {\n    providerIds = [providerIds];\n}\nif (!providerIds) {\n    providerIds = null; // Don't send provider filter if not specified\n}\n\nasync function getPatientAppointments() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Validate date formats\n        const startDateObj = new Date(startDate);\n        const endDateObj = new Date(endDate);\n        if (isNaN(startDateObj.getTime())) {\n            throw new Error('Invalid start date format. Expected YYYY-MM-DD format.');\n        }\n        if (isNaN(endDateObj.getTime())) {\n            throw new Error('Invalid end date format. Expected YYYY-MM-DD format.');\n        }\n\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters manually to match Postman format\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `start=${encodeURIComponent(startDate)}`,\n            `end=${encodeURIComponent(endDate)}`,\n            `cancelled=${encodeURIComponent(cancelled)}`,\n            `patient_ids[]=${encodeURIComponent(patientId)}`,\n            `location_id=${encodeURIComponent(locationId)}`\n        ];\n\n        // Add provider IDs to query params (optional - only if specified)\n        if (providerIds && Array.isArray(providerIds)) {\n            providerIds.forEach(id => {\n                queryParts.push(`provider_ids[]=${encodeURIComponent(id)}`);\n            });\n        }\n\n        // Build the full URL with query parameters\n        const url = `https://nexhealth.info/appointments?${queryParts.join('&')}`;\n\n        const apptRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching patient appointments...');\n        const apptResponse = await fetch(url, apptRequestOptions);\n\n        // Check for HTTP errors\n        if (!apptResponse.ok) {\n            const errorText = await apptResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointments failed with status ${apptResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate appointments response\n        let result;\n        try {\n            result = await apptResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointments response: ${parseError.message}`);\n        }\n\n        node.warn('Appointments retrieved successfully');\n        node.warn(result);\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        const appointments = result.data;\n        const count = Array.isArray(appointments) ? appointments.length : 0;\n        node.warn(`Found ${count} appointment(s)`);\n\n        // Set the payload with results (just the appointments array)\n        msg.payload = appointments;\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patient appointments: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while retrieving appointments',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getPatientAppointments();\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 920,
        "y": 720,
        "wires": [
            [
                "266937cfdb2f8b33"
            ]
        ]
    },
    {
        "id": "4d74ba579ef66846",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "getApptSlots-NA",
        "func": "// Node-RED Function Node - Get Appointment Slots\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch, node, msg, flow */\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n/*\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n*/\n\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst startDate = msg.startDate || \"2026-05-13\";\nconst days = msg.days || 30;\n\nconst maxSlots = msg.maxSlots || env.get(\"maxApptSlots\") || 50;\nconst apptTypeId = msg.payload.apptType || \"\";\n\nasync function getAppointmentSlots() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!startDate) {\n            throw new Error('Start date is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        if (!days || days < 1) {\n            throw new Error('Days must be a positive number');\n        }\n\n        // Validate maxSlots parameter (optional - null/0 means return all)\n        if (maxSlots !== null && maxSlots !== 0 && maxSlots < 1) {\n            throw new Error('maxSlots must be null, 0, or a positive number');\n        }\n\n        // Validate startDate format (YYYY-MM-DD)\n        const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n        if (!dateRegex.test(startDate)) {\n            throw new Error('Invalid start date format. Expected YYYY-MM-DD format.');\n        }\n\n        const dateObj = new Date(startDate);\n        if (isNaN(dateObj.getTime())) {\n            throw new Error('Invalid start date. Please provide a valid date.');\n        }\n\n                // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Now make the second request with the auth token\n        const apptRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching appointment slots...');\n        const slotsResponse = await fetch(\"https://nexhealth.info/appointment_slots?subdomain=cdm&lids[]=\" + locationId + \"&pids[]=\" + providerId + \"&start_date=\" + startDate + \"&days=\" + days + \"&location_id=\" + locationId, apptRequestOptions);\n        \n        // Check for HTTP errors\n        if (!slotsResponse.ok) {\n            const errorText = await slotsResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointment slots failed with status ${slotsResponse.status}: ${errorText}`);\n        }\n        \n        // Parse and validate slots response\n        let result;\n        try {\n            result = await slotsResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment slots response: ${parseError.message}`);\n        }\n        \n        node.warn('Appointment slots response received');\n        \n        // Validate response structure\n        if (!result.data) {\n            throw new Error('No data found in appointment slots response');\n        }\n\n        if (!Array.isArray(result.data) || result.data.length === 0) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified criteria',\n                data: []\n            };\n            return msg;\n        }\n\n        if (!result.data[0].slots) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified provider',\n                data: []\n            };\n            return msg;\n        }\n        \n        const allSlots = result.data[0].slots;\n        \n        // Apply maxSlots limit if specified (null or 0 means return all)\n        let apptSlots;\n        let limitMessage = '';\n        \n        if (maxSlots === null || maxSlots === 0) {\n            apptSlots = allSlots;\n            limitMessage = 'all';\n        } else {\n            apptSlots = allSlots.slice(0, maxSlots);\n            limitMessage = maxSlots === apptSlots.length ? `first ${maxSlots}` : `all ${apptSlots.length}`;\n        }\n        \n        node.warn(`Returning ${limitMessage} appointment slots`);\n        \n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: `Found ${allSlots.length} appointment slots, returning ${apptSlots.length}`,\n            totalSlots: allSlots.length,\n            returnedSlots: apptSlots.length,\n            maxSlotsLimit: maxSlots || 'unlimited',\n            appointment_type_id: apptTypeId || \"\",\n            data: apptSlots\n        };\n        \n        // KGK 2025-11-18 reduce payload to just apptSlots array\n        msg.payload = msg.payload.data;\n\n        return msg;\n        \n    } catch (error) {\n        node.error('Error getting appointment slots: ' + error.message, msg);\n        \n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching appointment slots',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n        \n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAppointmentSlots();\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 910,
        "y": 1000,
        "wires": [
            [
                "8e83fa56678a1331",
                "56ee0b68b8b48848"
            ]
        ]
    },
    {
        "id": "ed3fd28e71f9da76",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "getApptSlotsMultOverlap-NA",
        "func": "// Node-RED Function Node - Get Appointment Slots\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch, node, msg, flow */\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n/*\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n*/\n\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\n\nconst startDate = msg.startDate || \"2026-05-13\";\nconst days = msg.days || 30;\n\nconst maxSlots = msg.maxSlots || env.get(\"maxApptSlotsOverlapping\") || 100;\nconst apptTypeId = msg.payload.apptType || \"\";\n\nasync function getAppointmentSlots() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!startDate) {\n            throw new Error('Start date is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        if (!days || days < 1) {\n            throw new Error('Days must be a positive number');\n        }\n\n        // Validate maxSlots parameter (optional - null/0 means return all)\n        if (maxSlots !== null && maxSlots !== 0 && maxSlots < 1) {\n            throw new Error('maxSlots must be null, 0, or a positive number');\n        }\n\n        // Validate startDate format (YYYY-MM-DD)\n        const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n        if (!dateRegex.test(startDate)) {\n            throw new Error('Invalid start date format. Expected YYYY-MM-DD format.');\n        }\n\n        const dateObj = new Date(startDate);\n        if (isNaN(dateObj.getTime())) {\n            throw new Error('Invalid start date. Please provide a valid date.');\n        }\n\n                // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Now make the second request with the auth token\n        const apptRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching appointment slots...');\n        const slotsResponse = await fetch(\"https://nexhealth.info/appointment_slots?subdomain=cdm&lids[]=\" + locationId +\n            \"&pids[]=\" + providerId +\n            \"&start_date=\" + startDate +\n            \"&days=\" + days +\n            \"&location_id=\" + locationId +\n            \"&overlapping_operatory_slots=true\" +\n            \"&appointment_type_id=\" + apptTypeId, apptRequestOptions);\n\n            \n        // Check for HTTP errors\n        if (!slotsResponse.ok) {\n            const errorText = await slotsResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointment slots failed with status ${slotsResponse.status}: ${errorText}`);\n        }\n        \n        // Parse and validate slots response\n        let result;\n        try {\n            result = await slotsResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment slots response: ${parseError.message}`);\n        }\n        \n        node.warn('Appointment slots response received');\n        \n        // Validate response structure\n        if (!result.data) {\n            throw new Error('No data found in appointment slots response');\n        }\n\n        if (!Array.isArray(result.data) || result.data.length === 0) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified criteria',\n                data: []\n            };\n            return msg;\n        }\n\n        if (!result.data[0].slots) {\n            msg.payload = {\n                success: true,\n                message: 'No appointment slots available for the specified provider',\n                data: []\n            };\n            return msg;\n        }\n        \n        const allSlots = result.data[0].slots;\n        \n        // Apply maxSlots limit if specified (null or 0 means return all)\n        let apptSlots;\n        let limitMessage = '';\n        \n        if (maxSlots === null || maxSlots === 0) {\n            apptSlots = allSlots;\n            limitMessage = 'all';\n        } else {\n            apptSlots = allSlots.slice(0, maxSlots);\n            limitMessage = maxSlots === apptSlots.length ? `first ${maxSlots}` : `all ${apptSlots.length}`;\n        }\n        \n        node.warn(`Returning ${limitMessage} appointment slots`);\n        \n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: `Found ${allSlots.length} appointment slots, returning ${apptSlots.length}`,\n            totalSlots: allSlots.length,\n            returnedSlots: apptSlots.length,\n            maxSlotsLimit: maxSlots || 'unlimited',\n            data: apptSlots\n        };\n        \n        // KGK 2025-11-18 reduce payload to just apptSlots array\n        msg.payload = msg.payload.data;\n\n        return msg;\n        \n    } catch (error) {\n        node.error('Error getting appointment slots: ' + error.message, msg);\n        \n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching appointment slots',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n        \n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAppointmentSlots();\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 1040,
        "y": 1260,
        "wires": [
            [
                "6da3bdc196eaabe5",
                "de66f77742809b64"
            ]
        ]
    },
    {
        "id": "c56b15f387d9cb2a",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "createAppt-NA",
        "func": "// Node-RED Function Node - Create Appointment\n// This code is designed to run inside a Node-RED Function node\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n/* global fetch, node, msg, flow */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n/*\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n*/\n\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst patientId = msg.payload.patientId;\n\nconst startTime = msg.convertedEntry.convertedDateTime;\nconst operatoryId = msg.payload.operatoryId;\nconst note = \"Schedule by AI\";\n\nasync function createAppointment() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!startTime) {\n            throw new Error('Start time is required');\n        }\n\n        if (!operatoryId) {\n            throw new Error('Operatory ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Validate startTime format (ISO 8601)\n        const dateObj = new Date(startTime);\n        if (isNaN(dateObj.getTime())) {\n            throw new Error('Invalid start time format. Expected ISO 8601 format.');\n        }\n\n        // Get authentication token from flow context (managed by scheduled authentication node)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n        node.warn(startTime);\n        // Now create the appointment with the auth token\n        const raw = JSON.stringify({\n            \"appt\": {\n                \"patient_id\": patientId,\n                \"provider_id\": providerId,\n                \"start_time\": startTime,\n                \"operatory_id\": operatoryId,\n                \"note\": note\n            },\n            \"appointments_per_timeslot\": 1\n        });\n\n        const apptRequestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Creating appointment...');\n        const apptResponse = await fetch(\"https://nexhealth.info/appointments?subdomain=cdm&location_id=\" + locationId + \"&notify_patient=false\", apptRequestOptions);\n\n        // Check for HTTP errors\n        if (!apptResponse.ok) {\n            const errorText = await apptResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Create appointment failed with status ${apptResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate appointment response\n        let result;\n        try {\n            result = await apptResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment creation response: ${parseError.message}`);\n        }\n\n        node.warn('Appointment created successfully');\n\n        // Validate that appointment was created successfully\n        if (!result.data || !result.data.appt || !result.data.appt.id) {\n            throw new Error('Appointment creation may not have been successful. No appointment ID returned.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Appointment created successfully',\n            appointmentId: result.data.appt.id,\n            data: result\n        };\n        msg.payload = msg.payload.data.data.appt\n        return msg;\n\n    } catch (error) {\n        node.error('Error creating appointment: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during appointment creation',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn createAppointment();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 1060,
        "y": 1480,
        "wires": [
            [
                "fc6a683eed0b6de7",
                "5f5550a84835b02c"
            ]
        ]
    },
    {
        "id": "b01dca98098a4293",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "getLocation-NA",
        "func": "// Node-RED Function Node - Get Location\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch, node, msg, flow */\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\n\n/**\n * ============================================================================\n * GET LOCATION - Node-RED Function\n * ============================================================================\n * Fetches location information from NexHealth API by location ID.\n * \n * Expected msg properties:\n * - msg.payload.locationId: Location ID to fetch (required)\n * \n * Environment variables (fallback if msg properties not set):\n * - apiKey: NexHealth API key (required)\n * - locationId: Location ID (optional, can be provided in msg.payload)\n * \n * Output msg properties:\n * - msg.payload: Location data object\n * \n * Example usage:\n *   msg.payload = { locationId: 77523 };\n */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n//const locationId = msg.payload.locationId || env.get(\"locationId\");\nconst locationId = msg.session.locationId;\n\nasync function getLocation() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Validate locationId is a number or numeric string\n        const locationIdNum = Number(locationId);\n        if (isNaN(locationIdNum) || locationIdNum <= 0) {\n            throw new Error('Location ID must be a positive number');\n        }\n\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Now make the request to get location with the auth token\n        const locationRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn(`[getLocation] Fetching location ${locationId}...`);\n        const locationResponse = await fetch(`https://nexhealth.info/locations/${locationId}`, locationRequestOptions);\n\n        // Check for HTTP errors\n        if (!locationResponse.ok) {\n            const errorText = await locationResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get location failed with status ${locationResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate location response\n        let result;\n        try {\n            result = await locationResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse location response: ${parseError.message}`);\n        }\n\n        node.warn('[getLocation] Location response received');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('No data found in location response');\n        }\n\n        // Set the payload with location data\n        msg.payload = result.data;\n\n        node.log(`[getLocation] Successfully retrieved location ${locationId}`);\n\n        return msg;\n\n    } catch (error) {\n        node.error('[getLocation] Error getting location: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching location',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getLocation();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 840,
        "y": 2000,
        "wires": [
            [
                "63626ca29ccfda8e",
                "fcc6bfb2aea05f82"
            ]
        ]
    },
    {
        "id": "9c203c1f6522a682",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "5c665bc565f3fd82",
        "name": "cancelAppt-NA",
        "func": "// Node-RED Function Node - Cancel Appointment\n// This code is designed to run inside a Node-RED Function node\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n/* global fetch, node, msg, flow */\n\n// Get parameters from msg object or use defaults\nconst apptId = msg.payload.appointmentId;\n\nasync function cancelAppointment() {\n    try {\n        // Input validation\n        if (!apptId) {\n            throw new Error('Appointment ID is required');\n        }\n\n        // Get authentication token from flow context (managed by scheduled authentication node)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Now cancel the appointment with the auth token\n        const raw = JSON.stringify({\n            \"appt\": {\n                \"confirmed\": false,\n                \"cancelled\": true\n            }\n        });\n\n        const cancelRequestOptions = {\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Cancelling appointment...');\n        const cancelResponse = await fetch(\"https://nexhealth.info/appointments/\" + apptId + \"?subdomain=cdm\", cancelRequestOptions);\n\n        // Check for HTTP errors\n        if (!cancelResponse.ok) {\n            const errorText = await cancelResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Cancel appointment failed with status ${cancelResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate cancellation response\n        let result;\n        try {\n            result = await cancelResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse cancellation response: ${parseError.message}`);\n        }\n\n        node.warn('Appointment cancelled successfully');\n\n        // Validate the cancellation was successful\n        if (result.data && result.data.cancelled === false) {\n            throw new Error('Appointment cancellation may not have been successful. Please verify.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Appointment cancelled successfully',\n            data: result\n        };\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error cancelling appointment: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during appointment cancellation',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn cancelAppointment();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 620,
        "y": 2240,
        "wires": [
            [
                "3132feabace0025f",
                "e2eb2833bb803f91",
                "ecd53087f3ee7fa5"
            ]
        ]
    },
    {
        "id": "4cd7185e1650fa8a",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "baaf85afce595f5f",
        "name": "confirmAppt-NA",
        "func": "// Node-RED Function Node - Confirm Appointment\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n/* global fetch, node, msg, flow */\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst subdomain = msg.payload.subdomain || msg.subdomain || \"cdm\";\n\nconst apptId = msg.payload.appointmentId;\n\nasync function confirmAppointment() {\n    try {\n        // Input validation\n        if (!apptId) {\n            throw new Error('Appointment ID is required');\n        }\n\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Now confirm the appointment with the auth token\n        const raw = JSON.stringify({\n            \"appt\": {\n                \"confirmed\": true,\n                \"cancelled\": false\n            }\n        });\n\n        const confirmRequestOptions = {\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Confirming appointment...');\n        const confirmResponse = await fetch(\"https://nexhealth.info/appointments/\" + apptId + \"?subdomain=\" + subdomain, confirmRequestOptions);\n\n        // Check for HTTP errors\n        if (!confirmResponse.ok) {\n            const errorText = await confirmResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Confirm appointment failed with status ${confirmResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate confirmation response\n        let result;\n        try {\n            result = await confirmResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse confirmation response: ${parseError.message}`);\n        }\n\n        node.warn('Appointment confirmed successfully');\n        node.warn(result);\n\n        // Validate the confirmation was successful\n        if (result.data && result.data.confirmed === false) {\n            throw new Error('Appointment confirmation may not have been successful. Please verify.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Appointment confirmed successfully',\n            data: result\n        };\n\n        msg.payload = msg.payload.data.data.appt;\n\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error confirming appointment: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during appointment confirmation',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn confirmAppointment();\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 600,
        "y": 2420,
        "wires": [
            [
                "26a444411f61c09f",
                "8bf1658aceca2d71"
            ]
        ]
    },
    {
        "id": "ecc65b4adf9b677d",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "createPatient-NA",
        "func": "// Node-RED Function Node - Create Patient\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n/*\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n*/\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\n//const patientId = msg.payload.patientId || env.get(\"patientId\");\n\nconst firstName = msg.payload.firstName || msg.firstName;\nconst lastName = msg.payload.lastName || msg.lastName;\nconst phoneNumber = msg.payload.phoneNumber || msg.phoneNumber;\nconst birthDate = msg.payload.birthDate;\nconst subdomain = msg.subdomain || \"cdm\";\nconst email = \"aiTest@intelepeer.com\";\nconst insuranceName = msg.payload.insurance || \"\";\n\n\nasync function createPatient() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!firstName) {\n            throw new Error('First name is required');\n        }\n\n        if (!lastName) {\n            throw new Error('Last name is required');\n        }\n\n        if (!phoneNumber) {\n            throw new Error('Phone number is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        // Validate date of birth format if provided\n        if (!birthDate) {\n            throw new Error('Date of birth is required. Expected YYYY-MM-DD format.');\n        }\n\n\n                // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Now create the patient with the auth token\n        const patientData = {\n            \"provider\": {\n                \"provider_id\": providerId\n            },\n            \"patient\": {\n                \"first_name\": firstName,\n                \"last_name\": lastName,\n                \"email\": email,\n                \"bio\": {\n                    \"phone_number\": phoneNumber,\n                    \"date_of_birth\": birthDate,\n                    \"insurance_name\": insuranceName\n                }\n            }\n        };\n\n        const raw = JSON.stringify(patientData);\n\n        const patientRequestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Creating patient...');\n        const patientResponse = await fetch(\"https://nexhealth.info/patients?subdomain=\" + subdomain + \"&location_id=\" + locationId, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Create patient failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient creation response: ${parseError.message}`);\n        }\n\n        node.warn('Patient created successfully');\n        node.warn(result);\n\n\n        // Set the payload with results\n        msg.payload = result.data.user;\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error creating patient: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during patient creation',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn createPatient();\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 910,
        "y": 2540,
        "wires": [
            [
                "9463e8541c653c27",
                "cfb61a13bb81723c"
            ]
        ]
    },
    {
        "id": "3e3ef37154695dd1",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "47b76f2157d33f68",
        "name": "getApptTypes-NA",
        "func": "// Node-RED Function Node - Get Appointment Types\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch, node, msg, flow */\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\n\n/**\n * ============================================================================\n * GET APPOINTMENT TYPES - Node-RED Function\n * ============================================================================\n * Fetches appointment types from NexHealth API for a specific location.\n * \n * Expected msg properties:\n * - msg.payload.locationId: Location ID (required)\n * - msg.payload.subdomain: Subdomain (optional, default: 'cdm')\n * - msg.payload.includes: Array of include parameters (optional, e.g., ['descriptors'])\n * \n * Environment variables (fallback if msg properties not set):\n * - apiKey: NexHealth API key (required)\n * - locationId: Location ID (optional, can be provided in msg.payload)\n * - subdomain: Subdomain (optional, default: 'cdm')\n * \n * Output msg properties:\n * - msg.payload: Appointment types data array\n * \n * Example usage:\n *   msg.payload = { \n *     locationId: 77523,\n *     subdomain: 'cdm',\n *     includes: ['descriptors']\n *   };\n */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\nconst subdomain = msg.payload.subdomain || env.get(\"subdomain\") || \"cdm\";\nconst includes = msg.payload.includes || msg.payload.include || [];\n\nasync function getAppointmentTypes() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Validate locationId is a number or numeric string\n        const locationIdNum = Number(locationId);\n        if (isNaN(locationIdNum) || locationIdNum <= 0) {\n            throw new Error('Location ID must be a positive number');\n        }\n\n        // Validate subdomain\n        if (!subdomain || typeof subdomain !== 'string') {\n            throw new Error('Subdomain must be a non-empty string');\n        }\n\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters\n        const queryParams = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`\n        ];\n\n        // Add include parameters if provided\n        if (Array.isArray(includes) && includes.length > 0) {\n            includes.forEach(include => {\n                queryParams.push(`include[]=${encodeURIComponent(include)}`);\n            });\n        }\n\n        const queryString = queryParams.join('&');\n\n        // Now make the request to get appointment types with the auth token\n        const apptTypesRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        const url = `https://nexhealth.info/appointment_types?${queryString}`;\n        node.warn(`[getApptTypes] Fetching appointment types for location ${locationId}...`);\n        const apptTypesResponse = await fetch(url, apptTypesRequestOptions);\n\n        // Check for HTTP errors\n        if (!apptTypesResponse.ok) {\n            const errorText = await apptTypesResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointment types failed with status ${apptTypesResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate appointment types response\n        let result;\n        try {\n            result = await apptTypesResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment types response: ${parseError.message}`);\n        }\n\n        node.warn('[getApptTypes] Appointment types response received');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('No data found in appointment types response');\n        }\n\n        // Set the payload with appointment types data\n        msg.payload = result.data;\n\n        node.log(`[getApptTypes] Successfully retrieved ${Array.isArray(result.data) ? result.data.length : 'appointment types'} for location ${locationId}`);\n\n        return msg;\n\n    } catch (error) {\n        node.error('[getApptTypes] Error getting appointment types: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching appointment types',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAppointmentTypes();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 370,
        "y": 3000,
        "wires": [
            [
                "b19458dc88b6af84"
            ]
        ]
    },
    {
        "id": "da286309356ac2fe",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "a372f53aad09888a",
        "name": "getInsurance-NA",
        "func": "// Node-RED Function Node - Get Insurance Plans\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch, node, msg, flow */\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\n\n/**\n * ============================================================================\n * GET INSURANCE PLANS - Node-RED Function\n * ============================================================================\n * Fetches insurance plans from NexHealth API.\n * \n * Expected msg properties:\n * - msg.payload.subdomain: Subdomain (optional, default: 'cdm')\n * - msg.payload.perPage: Number of results per page (optional, default: 500)\n * - msg.payload.includeDeleted: Whether to include deleted plans (optional, default: false)\n * \n * Environment variables (fallback if msg properties not set):\n * - apiKey: NexHealth API key (required)\n * - subdomain: Subdomain (optional, default: 'cdm')\n * \n * Output msg properties:\n * - msg.payload: Insurance plans data array\n * \n * Example usage:\n *   msg.payload = { \n *     subdomain: 'cdm',\n *     perPage: 500,\n *     includeDeleted: false\n *   };\n */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst subdomain = msg.payload.subdomain || env.get(\"subdomain\") || \"cdm\";\nconst perPage = msg.payload.perPage || msg.payload.per_page || 500;\nconst includeDeleted = msg.payload.includeDeleted !== undefined ? msg.payload.includeDeleted : (msg.payload.include_deleted !== undefined ? msg.payload.include_deleted : false);\n\nasync function getInsurancePlans() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        // Validate subdomain\n        if (!subdomain || typeof subdomain !== 'string') {\n            throw new Error('Subdomain must be a non-empty string');\n        }\n\n        // Validate perPage\n        const perPageNum = Number(perPage);\n        if (isNaN(perPageNum) || perPageNum <= 0) {\n            throw new Error('perPage must be a positive number');\n        }\n\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters\n        const queryParams = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `per_page=${encodeURIComponent(perPageNum)}`,\n            `include_deleted=${includeDeleted ? 'true' : 'false'}`\n        ];\n\n        const queryString = queryParams.join('&');\n\n        // Now make the request to get insurance plans with the auth token\n        const insuranceRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        const url = `https://nexhealth.info/insurance_plans?${queryString}`;\n        node.warn(`[getInsurance] Fetching insurance plans for subdomain ${subdomain}...`);\n        const insuranceResponse = await fetch(url, insuranceRequestOptions);\n\n        // Check for HTTP errors\n        if (!insuranceResponse.ok) {\n            const errorText = await insuranceResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get insurance plans failed with status ${insuranceResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate insurance plans response\n        let result;\n        try {\n            result = await insuranceResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse insurance plans response: ${parseError.message}`);\n        }\n\n        node.warn('[getInsurance] Insurance plans response received');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('No data found in insurance plans response');\n        }\n\n        // Set the payload with insurance plans data\n        msg.payload = result.data;\n\n        node.log(`[getInsurance] Successfully retrieved ${Array.isArray(result.data) ? result.data.length : 'insurance plans'} for subdomain ${subdomain}`);\n\n        return msg;\n\n    } catch (error) {\n        node.error('[getInsurance] Error getting insurance plans: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching insurance plans',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getInsurancePlans();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 1010,
        "y": 3000,
        "wires": [
            [
                "62dd58bba415f00d"
            ]
        ]
    },
    {
        "id": "f35fb5671e7b3223",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "e1a21f43e6e5d2bd",
        "name": "function 23",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 1010,
        "y": 3160,
        "wires": [
            []
        ]
    },
    {
        "id": "898a645711dd0925",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "fa6c90989b81f095",
        "name": "getPayments-NA",
        "func": "// Node-RED Function Node - Get Payments\n// This code is designed to run inside a Node-RED Function node\n// Node-RED provides fetch globally, no need to require it\n\n/* global fetch, node, msg, flow */\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n\n\n/**\n * ============================================================================\n * GET PAYMENTS - Node-RED Function\n * ============================================================================\n * Fetches payment information from NexHealth API for a patient.\n * \n * Expected msg properties:\n * - msg.payload.patientId: Patient ID to fetch payments for (required)\n * - msg.payload.locationId: Location ID (required)\n * - msg.payload.providerId: Provider ID (optional)\n * - msg.payload.subdomain: Subdomain (optional, default: 'cdm')\n * - msg.payload.includeDeleted: Include deleted payments (optional, default: false)\n * - msg.payload.perPage: Number of results per page (optional, default: 30)\n * \n * Environment variables (fallback if msg properties not set):\n * - apiKey: NexHealth API key (required)\n * - locationId: Location ID (optional, can be provided in msg.payload)\n * \n * Output msg properties:\n * - msg.payload: Payments data array or error object\n * \n * Example usage:\n *   msg.payload = { \n *     patientId: 432833620,\n *     locationId: 77523,\n *     providerId: 223076809,\n *     subdomain: 'cdm',\n *     includeDeleted: false,\n *     perPage: 30\n *   };\n */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst patientId = msg.payload.patientId || env.get(\"patientId\");\nconst locationId = msg.payload.locationId || msg.session.locationId || env.get(\"locationId\");\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst subdomain = msg.payload.subdomain || msg.subdomain || 'cdm';\nconst includeDeleted = msg.payload.includeDeleted !== undefined ? msg.payload.includeDeleted : false;\nconst perPage = msg.payload.perPage || 30;\n\nasync function getPayments() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`,\n            `patient_id=${encodeURIComponent(patientId)}`,\n            `include_deleted=${includeDeleted}`,\n            `per_page=${perPage}`\n        ];\n\n        // Add provider ID if provided\n        if (providerId) {\n            queryParts.push(`provider_id=${encodeURIComponent(providerId)}`);\n        }\n\n        // Build the full URL\n        const url = `https://nexhealth.info/payments?${queryParts.join('&')}`;\n\n        const paymentsRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": `Bearer ${authToken}`\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn(`[getPayments] Fetching payments for patient ${patientId}...`);\n        const paymentsResponse = await fetch(url, paymentsRequestOptions);\n\n        // Check for HTTP errors\n        if (!paymentsResponse.ok) {\n            const errorText = await paymentsResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get payments failed with status ${paymentsResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate payments response\n        let result;\n        try {\n            result = await paymentsResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse payments response: ${parseError.message}`);\n        }\n\n        node.warn('[getPayments] Payments response received');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Set the payload with payments data\n        msg.payload = {\n            success: true,\n            message: 'Payments retrieved successfully',\n            payments: Array.isArray(result.data) ? result.data : [result.data],\n            count: Array.isArray(result.data) ? result.data.length : 1,\n            fullResponse: result\n        };\n\n        // Set payload to just the payments array for easier downstream processing\n        msg.payload = Array.isArray(result.data) ? result.data : [result.data];\n\n        node.log(`[getPayments] Successfully retrieved ${msg.payload.length} payment(s)`);\n\n        return msg;\n\n    } catch (error) {\n        node.error('[getPayments] Error getting payments: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while fetching payments',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getPayments();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 550,
        "y": 3420,
        "wires": [
            [
                "b7f02451dfdd1e3c",
                "6cbbc4eeb860682c"
            ]
        ]
    },
    {
        "id": "6cbbc4eeb860682c",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "fa6c90989b81f095",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 910,
        "y": 3420,
        "wires": []
    },
    {
        "id": "dbfdafad659a5e4a",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "f9ed3759d3ab4cf8",
        "name": "getPatient-NA",
        "func": "// Node-RED Function Node - Get Patient Appointments\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n\nconst patientId = msg.payload.patientId || env.get(\"patientId\");\n\n\n\nconst authEndpoint = \"https://nexhealth.info/authenticates\";\nconst requestEndpoint = \"https://nexhealth.info/patients/\";\n\nconst phoneNum = msg.payload.phoneNum || \"3218675309\";\nconst subdomain = msg.subdomain || 'cdm';\n\n\n\n// Optional provider IDs filter (can be array or single value)\nconst providerIds = msg.providerIds || msg.providerId ? [msg.providerId] : [421458314];\n\nasync function getPatient() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // First, authenticate to get the token\n        node.warn('Authenticating...');\n        const requestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": apiKey\n            },\n            redirect: \"follow\"\n        };\n\n        const authResponse = await fetch(authEndpoint, requestOptions);\n\n        // Check for HTTP errors\n        if (!authResponse.ok) {\n            const errorText = await authResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Authentication failed with status ${authResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate authentication response\n        let authResult;\n        try {\n            authResult = await authResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse authentication response: ${parseError.message}`);\n        }\n\n        node.warn('Auth response received');\n\n        if (!authResult.data || !authResult.data.token) {\n            throw new Error('Authentication token not found in response. Response structure may have changed.');\n        }\n\n        const authToken = authResult.data.token;\n\n        // Build query parameters manually (patientId goes in the URL path, not query params)\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`,\n            `phone_number=${encodeURIComponent(phoneNum)}`\n        ];\n\n        // Add provider IDs to query params if needed (optional - may not be needed for patient endpoint)\n        if (Array.isArray(providerIds)) {\n            providerIds.forEach(id => {\n                queryParts.push(`provider_ids[]=${encodeURIComponent(id)}`);\n            });\n        } else if (providerIds) {\n            queryParts.push(`provider_ids[]=${encodeURIComponent(providerIds)}`);\n        }\n\n        // Build the full URL with patientId in the path\n        const url = `${requestEndpoint}${patientId}?${queryParts.join('&')}`;\n\n        const patientRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn('Fetching patient...');\n        const patientResponse = await fetch(url, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get patient failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient response: ${parseError.message}`);\n        }\n\n        node.warn('Patient retrieved successfully');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Patient retrieved successfully',\n            patient: result.data,\n            fullResponse: result\n        };\n        msg.payload = msg.payload.patient;\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patient: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while retrieving patient',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getPatient();\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 2320,
        "y": 180,
        "wires": [
            [
                "c74d3d53b0323805",
                "e4399373da2f9f5e",
                "53b8941e29e2db6f"
            ]
        ]
    },
    {
        "id": "77fe085b21a772eb",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "",
        "props": [
            {
                "p": "OGpatientId",
                "v": "427698262",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.phoneNumber",
                "v": "+12132791621",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u00075i9��765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 410,
        "y": 380,
        "wires": [
            [
                "9680fe37f534791c"
            ]
        ]
    },
    {
        "id": "7eb21a1ba101e779",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "getPatientByEmailCombined-NA",
        "func": "// Node-RED Function Node - Get Patient By Email (Combined - New and Existing Patients)\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst locationId = msg.session.locationId || msg.payload.locationId || env.get(\"locationId\");\nconst subdomain = msg.payload.subdomain || msg.subdomain || \"cdm\";\nconst perPage = msg.payload.perPage || msg.payload.per_page || 200;\nconst location_strict = msg.payload.locationStrict || true;\n\nconst requestEndpoint = \"https://nexhealth.info/patients\";\n\nconst email = msg.payload.email || msg.email;\n\n/**\n * Fetches patients by email with a specific new_patient filter\n * @param {boolean} newPatient - Filter for new_patient (true or false)\n * @returns {Promise<Array>} Array of patients\n */\nasync function getPatientsByEmailAndNewPatientStatus(newPatient) {\n    try {\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters to search by email and new_patient status\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`,\n            `email=${encodeURIComponent(email)}`,\n            `new_patient=${encodeURIComponent(newPatient)}`,\n            `per_page=${encodeURIComponent(perPage)}`,\n            `location_strict=${encodeURIComponent(location_strict)}`\n        ];\n\n        // Build the full URL\n        const url = `${requestEndpoint}?${queryParts.join('&')}`;\n\n        const patientRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn(`Searching for patients with email: ${email}, new_patient: ${newPatient}...`);\n        const patientResponse = await fetch(url, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get patient by email failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient response: ${parseError.message}`);\n        }\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Return array of patients (handle both single object and array responses)\n        const patients = Array.isArray(result.data) ? result.data : [result.data];\n        node.warn(`Found ${patients.length} patient(s) with email: ${email}, new_patient: ${newPatient}`);\n        \n        return patients;\n\n    } catch (error) {\n        node.error(`Error getting patients with new_patient=${newPatient}: ${error.message}`, msg);\n        // Return empty array on error so we can still combine results\n        return [];\n    }\n}\n\nasync function getAllPatientsByEmail() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!email) {\n            throw new Error('Email is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        node.warn(`Fetching all patients with email: ${email} (both new and existing)...`);\n\n        // Make both API calls concurrently using Promise.all\n        const [newPatients, existingPatients] = await Promise.all([\n            getPatientsByEmailAndNewPatientStatus(true),\n            getPatientsByEmailAndNewPatientStatus(false)\n        ]);\n\n        // Combine the results\n        const allPatients = [...newPatients, ...existingPatients];\n\n        node.warn(`Total patients found: ${allPatients.length} (${newPatients.length} new, ${existingPatients.length} existing)`);\n\n        if (allPatients.length === 0) {\n            // Store detailed info before setting payload\n            msg.patientInfo = {\n                success: true,\n                message: 'No patients found with this email',\n                found: false,\n                email: email,\n                patients: [],\n                newPatients: [],\n                existingPatients: [],\n                totalCount: 0\n            };\n            msg.payload = [];\n        } else {\n            // Store detailed info before setting payload\n            msg.patientInfo = {\n                success: true,\n                message: `Found ${allPatients.length} patient(s)`,\n                found: true,\n                email: email,\n                patients: allPatients,\n                newPatients: newPatients,\n                existingPatients: existingPatients,\n                totalCount: allPatients.length,\n                newPatientCount: newPatients.length,\n                existingPatientCount: existingPatients.length\n            };\n\n            // Set payload to just the patient data array for easier downstream processing\n            msg.payload = allPatients;\n        }\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patients by email: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while searching for patients',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAllPatientsByEmail();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 920,
        "y": 280,
        "wires": [
            [
                "12fab74e303e40ca",
                "0e6e750bd7305240",
                "4625dd1161a71643"
            ]
        ]
    },
    {
        "id": "12fab74e303e40ca",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "getPatientByEmailCombined Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 280,
        "wires": []
    },
    {
        "id": "6005bfd25271cf84",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "getPatientByPhoneCombined-NA",
        "func": "// Node-RED Function Node - Get Patient By Phone Number (Combined - New and Existing Patients)\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n//const locationId = msg.payload.locationId || env.get(\"locationId\");\nconst locationId = msg.session.locationId;\n\nconst rawPhoneNumber = msg.payload.phoneNumber || msg.phoneNumber;\nconst subdomain = msg.payload.subdomain || \"cdm\";\nconst perPage = msg.payload.per_page || 30;\nconst locationStrict = msg.payload.locationStrict || true;\n\n// Helper function to clean phone number - remove +1 or leading 1\nconst cleanPhoneNumber = (phone) => {\n    if (!phone) return phone;\n\n    let cleaned = phone.toString().trim();\n\n    // Remove +1 prefix\n    if (cleaned.startsWith('+1')) {\n        cleaned = cleaned.substring(2);\n    }\n    // Remove leading 1 (but only if the number would still be 10 digits)\n    else if (cleaned.startsWith('1') && cleaned.length === 11) {\n        cleaned = cleaned.substring(1);\n    }\n\n    return cleaned;\n};\n\nconst phoneNumber = cleanPhoneNumber(rawPhoneNumber);\n\nconst requestEndpoint = \"https://nexhealth.info/patients\";\n\n/**\n * Fetches patients by phone number with a specific new_patient filter\n * @param {boolean} newPatient - Filter for new_patient (true or false)\n * @returns {Promise<Array>} Array of patients\n */\nasync function getPatientsByPhoneNumberAndNewPatientStatus(newPatient) {\n    try {\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters to search by phone number and new_patient status\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`,\n            `phone_number=${encodeURIComponent(phoneNumber)}`,\n            `new_patient=${encodeURIComponent(newPatient)}`,\n            `location_strict=${encodeURIComponent(locationStrict)}`,\n            `per_page=${encodeURIComponent(perPage)}`\n        ];\n\n        // Build the full URL\n        const url = `${requestEndpoint}?${queryParts.join('&')}`;\n\n        const patientRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn(`Searching for patients with phone number: ${phoneNumber}, new_patient: ${newPatient}...`);\n        const patientResponse = await fetch(url, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get patient by phone number failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient response: ${parseError.message}`);\n        }\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Return array of patients (handle both single object and array responses)\n        const patients = Array.isArray(result.data) ? result.data : [result.data];\n        node.warn(`Found ${patients.length} patient(s) with phone number: ${phoneNumber}, new_patient: ${newPatient}`);\n        \n        return patients;\n\n    } catch (error) {\n        node.error(`Error getting patients with new_patient=${newPatient}: ${error.message}`, msg);\n        // Return empty array on error so we can still combine results\n        return [];\n    }\n}\n\nasync function getAllPatientsByPhoneNumber() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!phoneNumber) {\n            throw new Error('Phone number is required');\n        }\n\n        // Log phone number cleaning if it was modified\n        if (rawPhoneNumber !== phoneNumber) {\n            node.warn(`Phone number cleaned: ${rawPhoneNumber} → ${phoneNumber}`);\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        node.warn(`Fetching all patients with phone number: ${phoneNumber} (both new and existing)...`);\n\n        // Make both API calls concurrently using Promise.all\n        const [newPatients, existingPatients] = await Promise.all([\n            getPatientsByPhoneNumberAndNewPatientStatus(true),\n            getPatientsByPhoneNumberAndNewPatientStatus(false)\n        ]);\n\n        // Combine the results\n        const allPatients = [...newPatients, ...existingPatients];\n\n        node.warn(`Total patients found: ${allPatients.length} (${newPatients.length} new, ${existingPatients.length} existing)`);\n\n        if (allPatients.length === 0) {\n            // Store detailed info before setting payload\n            msg.patientInfo = {\n                success: true,\n                message: 'No patients found with this phone number',\n                found: false,\n                phoneNumber: phoneNumber,\n                rawPhoneNumber: rawPhoneNumber,\n                patients: [],\n                newPatients: [],\n                existingPatients: [],\n                totalCount: 0\n            };\n            msg.payload = [];\n        } else {\n            // Store detailed info before setting payload\n            msg.patientInfo = {\n                success: true,\n                message: `Found ${allPatients.length} patient(s)`,\n                found: true,\n                phoneNumber: phoneNumber,\n                rawPhoneNumber: rawPhoneNumber,\n                patients: allPatients,\n                newPatients: newPatients,\n                existingPatients: existingPatients,\n                totalCount: allPatients.length,\n                newPatientCount: newPatients.length,\n                existingPatientCount: existingPatients.length\n            };\n\n            // Set payload to just the patient data array for easier downstream processing\n            msg.payload = allPatients;\n        }\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patients by phone number: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while searching for patients',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAllPatientsByPhoneNumber();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 860,
        "y": 480,
        "wires": [
            [
                "e51b295556726df3",
                "93492add994e91e4"
            ]
        ]
    },
    {
        "id": "fe22213d34bf536c",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "getPatientByPhoneCombined Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1190,
        "y": 380,
        "wires": []
    },
    {
        "id": "93492add994e91e4",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "transformPatientList",
        "func": "// Node-RED Function Node - Transform Patient List\n// This code is designed to run inside a Node-RED Function node\n// Takes a combined patient list from msg.payload and transforms each patient object:\n// - Moves bio fields (new_patient, non_patient, phone_number, date_of_birth) and cell_phone_number to parent level\n// - Removes specified fields (created_at, updated_at, name, institution_id, foreign_id, foreign_id_type, bio, last_sync_time, billing_type, chart_id)\n\nfunction transformPatient(patient) {\n    // Create a new object to avoid mutating the original\n    const transformed = { ...patient };\n\n    // Move bio fields up to parent level\n    if (patient.bio) {\n        // Move bio.new_patient if it exists\n        if (patient.bio.hasOwnProperty('new_patient')) {\n            transformed.new_patient = patient.bio.new_patient;\n        }\n\n        // Move bio.non_patient if it exists\n        if (patient.bio.hasOwnProperty('non_patient')) {\n            transformed.non_patient = patient.bio.non_patient;\n        }\n\n        // Move bio.phone_number if it exists\n        if (patient.bio.hasOwnProperty('phone_number')) {\n            transformed.phone_number = patient.bio.phone_number;\n        }\n\n        // Move bio.date_of_birth if it exists\n        if (patient.bio.hasOwnProperty('date_of_birth')) {\n            transformed.date_of_birth = patient.bio.date_of_birth;\n        }\n\n        // Move bio.cell_phone_number if it exists\n        if (patient.bio.hasOwnProperty('cell_phone_number')) {\n            transformed.cell_phone_number = patient.bio.cell_phone_number;\n        }\n    }\n\n    // Move cell_phone_number from parent level if it exists (and wasn't already moved from bio)\n    if (patient.hasOwnProperty('cell_phone_number') && !transformed.hasOwnProperty('cell_phone_number')) {\n        transformed.cell_phone_number = patient.cell_phone_number;\n    }\n\n    // Remove specified fields\n    const fieldsToRemove = [\n        'created_at',\n        'updated_at',\n        'name',\n        'institution_id',\n        'foreign_id',\n        'foreign_id_type',\n        'bio',\n        'last_sync_time',\n        'billing_type',\n        'chart_id'\n    ];\n\n    fieldsToRemove.forEach(field => {\n        delete transformed[field];\n    });\n\n    return transformed;\n}\n\ntry {\n    // Validate that payload exists and is an array\n    if (!msg.payload) {\n        throw new Error('msg.payload is required and must be an array of patients');\n    }\n\n    if (!Array.isArray(msg.payload)) {\n        throw new Error('msg.payload must be an array of patients');\n    }\n\n    node.warn(`Transforming ${msg.payload.length} patient(s)...`);\n\n    // Transform each patient in the array\n    const transformedPatients = msg.payload.map(patient => transformPatient(patient));\n\n    node.warn(`Successfully transformed ${transformedPatients.length} patient(s)`);\n\n    // Update the payload with transformed patients\n    msg.payload = transformedPatients;\n\n    // Preserve patientInfo if it exists (from the combined functions)\n    // The transformed patients are now in msg.payload\n\n    return msg;\n\n} catch (error) {\n    node.error('Error transforming patient list: ' + error.message, msg);\n\n    // Set error payload\n    msg.payload = {\n        success: false,\n        error: error.message || 'Unknown error occurred while transforming patient list',\n        errorType: error.name || 'Error',\n        timestamp: new Date().toISOString()\n    };\n\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 420,
        "wires": [
            [
                "fe22213d34bf536c",
                "182759a7f1d80d75"
            ]
        ]
    },
    {
        "id": "266937cfdb2f8b33",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "ConvertTo12Hr",
        "func": "// Node-RED Function Node - Convert Patient Time to 12-Hour Format\n// This code is designed to run inside a Node-RED Function node\n// Converts time fields from 24-hour format (HH:MM or HH:MM:SS) to 12-hour format (h:mm AM/PM)\n// Processes the patient object from nodeGetPatient.js payload\n\n/**\n * Converts a 24-hour time string to 12-hour format and extracts date if present\n * Handles ISO datetime strings with timezone conversion\n * @param {string} timeString - Time string in 24-hour format (HH:MM or HH:MM:SS) or ISO datetime\n * @param {string} timezoneOffset - Optional timezone offset (e.g., \"-04:00\", \"+05:00\")\n * @param {string} timezone - Optional timezone name (e.g., \"America/New_York\")\n * @returns {object} Object with converted time and extracted date: { time: \"h:mm AM/PM\", date: \"YYYY-MM-DD\" } or original string if conversion fails\n */\nfunction convert24HourTo12Hour(timeString, timezoneOffset = null, timezone = null) {\n    if (!timeString || typeof timeString !== 'string') {\n        return { time: timeString, date: null };\n    }\n\n    // Check if already in 12-hour format (contains AM/PM)\n    if (timeString.match(/\\d{1,2}:\\d{2}\\s*(AM|PM)/i)) {\n        return { time: timeString, date: null }; // Already in 12-hour format, no date extracted\n    }\n\n    // Check if it's an ISO datetime string - handle timezone conversion\n    if (timeString.includes('T')) {\n        try {\n            // Parse the ISO datetime string (this creates a UTC Date object)\n            const dateObj = new Date(timeString);\n            \n            // Check if date is valid\n            if (isNaN(dateObj.getTime())) {\n                // Fallback to simple extraction if Date parsing fails\n                return extractTimeAndDateSimple(timeString);\n            }\n\n            // Determine target timezone\n            let targetTimezone = 'UTC';\n            if (timezone && typeof timezone === 'string') {\n                // Use timezone name if provided (e.g., \"America/New_York\")\n                targetTimezone = timezone;\n            } else if (timezoneOffset) {\n                // If only offset is provided, create a timezone string\n                // Note: This is a simplified approach - for accurate DST handling, use timezone name\n                const offsetMatch = timezoneOffset.match(/([+-])(\\d{2}):(\\d{2})/);\n                if (offsetMatch) {\n                    // For now, we'll use the offset directly but JavaScript Date methods\n                    // will convert to the server's local timezone, so we need to adjust\n                    targetTimezone = null; // Will use manual offset calculation\n                }\n            }\n\n            let localDate = dateObj;\n            let hours, minutes, seconds, year, month, day, dateOnly;\n\n            if (targetTimezone && targetTimezone !== 'UTC' && targetTimezone !== null) {\n                // Use toLocaleString to convert to the specified timezone\n                // This properly handles DST\n                const localString = dateObj.toLocaleString('en-US', {\n                    timeZone: targetTimezone,\n                    year: 'numeric',\n                    month: '2-digit',\n                    day: '2-digit',\n                    hour: '2-digit',\n                    minute: '2-digit',\n                    second: '2-digit',\n                    hour12: false\n                });\n                \n                // Parse the formatted string (format: \"MM/DD/YYYY, HH:mm:ss\")\n                const match = localString.match(/(\\d{2})\\/(\\d{2})\\/(\\d{4}), (\\d{2}):(\\d{2}):(\\d{2})/);\n                if (match) {\n                    month = match[1];\n                    day = match[2];\n                    year = match[3];\n                    hours = parseInt(match[4], 10);\n                    minutes = match[5];\n                    seconds = match[6];\n                    dateOnly = `${year}-${month}-${day}`;\n                } else {\n                    // Fallback to manual calculation\n                    throw new Error('Could not parse locale string');\n                }\n            } else {\n                // Manual offset calculation (fallback)\n                // Get UTC components first\n                let utcHours = dateObj.getUTCHours();\n                let utcMinutes = dateObj.getUTCMinutes();\n                let utcSeconds = dateObj.getUTCSeconds();\n                let utcYear = dateObj.getUTCFullYear();\n                let utcMonth = dateObj.getUTCMonth();\n                let utcDate = dateObj.getUTCDate();\n\n                // Apply timezone offset if provided\n                if (timezoneOffset) {\n                    const offsetMatch = timezoneOffset.match(/([+-])(\\d{2}):(\\d{2})/);\n                    if (offsetMatch) {\n                        const sign = offsetMatch[1] === '+' ? 1 : -1;\n                        const offsetHours = parseInt(offsetMatch[2], 10);\n                        const offsetMinutes = parseInt(offsetMatch[3], 10);\n                        const totalOffsetMinutes = sign * (offsetHours * 60 + offsetMinutes);\n                        \n                        // Convert UTC time to local time by adding the offset\n                        let totalMinutes = utcHours * 60 + utcMinutes + totalOffsetMinutes;\n                        \n                        // Handle day rollover/underflow\n                        let daysAdjustment = 0;\n                        if (totalMinutes < 0) {\n                            daysAdjustment = -1;\n                            totalMinutes += 24 * 60;\n                        } else if (totalMinutes >= 24 * 60) {\n                            daysAdjustment = 1;\n                            totalMinutes -= 24 * 60;\n                        }\n                        \n                        let localHours = Math.floor(totalMinutes / 60);\n                        let localMins = totalMinutes % 60;\n                        \n                        // Adjust date if needed\n                        if (daysAdjustment !== 0) {\n                            const tempDate = new Date(Date.UTC(utcYear, utcMonth, utcDate + daysAdjustment));\n                            utcYear = tempDate.getUTCFullYear();\n                            utcMonth = tempDate.getUTCMonth();\n                            utcDate = tempDate.getUTCDate();\n                        }\n                        \n                        utcHours = localHours;\n                        utcMinutes = localMins;\n                    }\n                }\n\n                // Extract date and time components\n                year = utcYear;\n                month = String(utcMonth + 1).padStart(2, '0');\n                day = String(utcDate).padStart(2, '0');\n                dateOnly = `${year}-${month}-${day}`;\n                hours = utcHours;\n                minutes = String(utcMinutes).padStart(2, '0');\n                seconds = String(utcSeconds).padStart(2, '0');\n            }\n\n            // Convert to 12-hour format\n            let hours12 = hours;\n            let ampm = 'AM';\n\n            if (hours === 0) {\n                hours12 = 12; // Midnight\n            } else if (hours === 12) {\n                ampm = 'PM'; // Noon\n            } else if (hours > 12) {\n                hours12 = hours - 12;\n                ampm = 'PM';\n            }\n\n            // Format: h:mm AM/PM or h:mm:ss AM/PM\n            const time12Hour = `${hours12}:${minutes}:${seconds} ${ampm}`;\n            return { time: time12Hour, date: dateOnly };\n\n        } catch (error) {\n            node.warn(`Error parsing ISO datetime: ${timeString}, error: ${error.message}`);\n            // Fallback to simple extraction\n            return extractTimeAndDateSimple(timeString);\n        }\n    }\n\n    // Handle simple 24-hour format (HH:MM or HH:MM:SS) without date\n    return extractTimeAndDateSimple(timeString);\n}\n\n/**\n * Simple extraction for non-ISO time strings\n * @param {string} timeString - Time string to extract from\n * @returns {object} Object with converted time and date\n */\nfunction extractTimeAndDateSimple(timeString) {\n    let timeOnly = timeString;\n    let dateOnly = null;\n    \n    if (timeString.includes('T')) {\n        // ISO format: extract date portion (YYYY-MM-DD)\n        const dateMatch = timeString.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n        if (dateMatch) {\n            dateOnly = dateMatch[1];\n        }\n        \n        // Extract time portion (HH:MM:SS or HH:MM:SS.SSS)\n        const timeMatch = timeString.match(/T(\\d{2}):(\\d{2})(?::(\\d{2}))?(?:\\.\\d+)?/);\n        if (timeMatch) {\n            timeOnly = `${timeMatch[1]}:${timeMatch[2]}${timeMatch[3] ? ':' + timeMatch[3] : ''}`;\n        } else {\n            return { time: timeString, date: dateOnly };\n        }\n    }\n\n    // Match 24-hour format: HH:MM or HH:MM:SS\n    const timeMatch = timeOnly.match(/^(\\d{1,2}):(\\d{2})(?::(\\d{2}))?$/);\n    if (!timeMatch) {\n        return { time: timeString, date: dateOnly };\n    }\n\n    const hours = parseInt(timeMatch[1], 10);\n    const minutes = timeMatch[2];\n    const seconds = timeMatch[3] || '';\n\n    // Validate hours\n    if (hours < 0 || hours > 23) {\n        return { time: timeString, date: dateOnly };\n    }\n\n    // Convert to 12-hour format\n    let hours12 = hours;\n    let ampm = 'AM';\n\n    if (hours === 0) {\n        hours12 = 12; // Midnight\n    } else if (hours === 12) {\n        ampm = 'PM'; // Noon\n    } else if (hours > 12) {\n        hours12 = hours - 12;\n        ampm = 'PM';\n    }\n\n    // Format: h:mm AM/PM or h:mm:ss AM/PM\n    const time12Hour = `${hours12}:${minutes}${seconds ? ':' + seconds : ''} ${ampm}`;\n    return { time: time12Hour, date: dateOnly };\n}\n\n/**\n * Maps time field names to their corresponding date field names\n * @param {string} timeFieldName - Name of the time field\n * @returns {string} Corresponding date field name\n */\nfunction getDateFieldName(timeFieldName) {\n    const dateFieldMap = {\n        'time': 'date',\n        'start_time': 'start_date',\n        'end_time': 'end_date',\n        'apptTime': 'apptDate',\n        'appointment_time': 'appointment_date'\n    };\n    return dateFieldMap[timeFieldName] || timeFieldName.replace('_time', '_date').replace('Time', 'Date');\n}\n\n/**\n * Recursively processes an object to convert time fields and add date properties\n * @param {object} obj - Object to process\n * @param {array} timeFields - Array of field names that contain time values\n * @param {string} timezoneOffset - Timezone offset from parent context (e.g., \"-04:00\")\n * @param {string} timezone - Timezone name from parent context (e.g., \"America/New_York\")\n * @returns {object} Processed object with converted times and added date fields\n */\nfunction processObject(obj, timeFields = ['time', 'start_time', 'end_time', 'apptTime', 'appointment_time'], timezoneOffset = null, timezone = null) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n        return obj.map(item => processObject(item, timeFields, timezoneOffset, timezone));\n    }\n\n    // Create a copy to avoid mutating the original\n    const processed = { ...obj };\n\n    // Check for timezone information in the object - prioritize object's own timezone fields\n    // This ensures each appointment uses its own timezone, not a parent context\n    const objTimezone = processed.timezone || timezone;\n    const objTimezoneOffset = processed.timezone_offset || processed.timezoneOffset || timezoneOffset;\n\n    // Process each property\n    for (const key in processed) {\n        if (processed.hasOwnProperty(key)) {\n            const value = processed[key];\n\n            // Check if this is a time field that needs conversion\n            if (timeFields.includes(key) && typeof value === 'string') {\n                // Use the object's timezone if available, otherwise fall back to parent context\n                const timezoneToUse = objTimezone || timezone;\n                const offsetToUse = objTimezoneOffset || timezoneOffset;\n                \n                const converted = convert24HourTo12Hour(value, offsetToUse, timezoneToUse);\n                \n                // Update the time field with converted time\n                processed[key] = converted.time;\n                \n                // Add date field if date was extracted and doesn't already exist\n                if (converted.date) {\n                    const dateFieldName = getDateFieldName(key);\n                    // Only add date field if it doesn't already exist\n                    if (!processed.hasOwnProperty(dateFieldName)) {\n                        processed[dateFieldName] = converted.date;\n                    }\n                }\n            }\n            // Recursively process nested objects and arrays\n            // Pass down the object's timezone so nested objects can use it\n            else if (typeof value === 'object' && value !== null) {\n                // Use object's timezone for nested processing, but allow nested objects to override\n                const nestedTimezone = objTimezone || timezone;\n                const nestedTimezoneOffset = objTimezoneOffset || timezoneOffset;\n                processed[key] = processObject(value, timeFields, nestedTimezoneOffset, nestedTimezone);\n            }\n        }\n    }\n\n    return processed;\n}\n\ntry {\n    // Validate that payload exists\n    if (!msg.payload) {\n        throw new Error('msg.payload is required');\n    }\n\n    node.warn('Converting time fields from 24-hour to 12-hour format...');\n\n    // Process the patient object (or array of patients)\n    const processedPayload = processObject(msg.payload);\n\n    node.warn('Time conversion completed successfully');\n\n    // Update the payload with processed data\n    msg.payload = processedPayload;\n\n    return msg;\n\n} catch (error) {\n    node.error('Error converting patient time format: ' + error.message, msg);\n\n    // Set error payload\n    msg.payload = {\n        success: false,\n        error: error.message || 'Unknown error occurred while converting time format',\n        errorType: error.name || 'Error',\n        timestamp: new Date().toISOString()\n    };\n\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 720,
        "wires": [
            [
                "ab58cd62893bff53",
                "d2ba7b687348cb9e",
                "4ab8dc9913913c62"
            ]
        ]
    },
    {
        "id": "ab58cd62893bff53",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "patientAppts Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 760,
        "wires": []
    },
    {
        "id": "10e51a46931c7be2",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "Alleg",
        "props": [
            {
                "p": "payload.patientId",
                "v": "435619532",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u00075i9��765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333724|421458170VO|2d411063-3769-4618-86d1-925d3578c112|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 230,
        "y": 720,
        "wires": [
            [
                "8331a48e2263763c"
            ]
        ]
    },
    {
        "id": "23772f57e7dfb85f",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "0fb2feb44514306f",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 700,
        "y": 220,
        "wires": [
            [
                "7eb21a1ba101e779"
            ]
        ]
    },
    {
        "id": "d5ca0a376ceeea89",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "712c1fe569af7e6d",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 800,
        "y": 440,
        "wires": [
            [
                "7b1422ce1e8ee8f0",
                "6005bfd25271cf84"
            ]
        ]
    },
    {
        "id": "d0269b54e1f28ae7",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 640,
        "y": 760,
        "wires": [
            [
                "6e8029b299e0062a",
                "83dede7b863766d4"
            ]
        ]
    },
    {
        "id": "26300057398b209c",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "8912dadd9ad9094d",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 600,
        "y": 1000,
        "wires": [
            [
                "b25b992651ad9d6b",
                "4d74ba579ef66846"
            ]
        ]
    },
    {
        "id": "a64f7a25eac76243",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "6282d2c22d141111",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 620,
        "y": 1220,
        "wires": [
            [
                "d40e6e5eba28dffe",
                "fe8d041c17561655"
            ]
        ]
    },
    {
        "id": "948d7f2678a68bfa",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "934e7067c60517f2",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 540,
        "y": 1480,
        "wires": [
            [
                "8a35fb512ca3562c",
                "48d519a374f4332d"
            ]
        ]
    },
    {
        "id": "8be41de85b2f7b6e",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "7375dac1352eefcb",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 580,
        "y": 1960,
        "wires": [
            [
                "4101412b851fce41",
                "b01dca98098a4293"
            ]
        ]
    },
    {
        "id": "8b80bf786e1c1d33",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 620,
        "y": 2580,
        "wires": [
            [
                "ecc65b4adf9b677d"
            ]
        ]
    },
    {
        "id": "b437e4a0abde4984",
        "type": "change",
        "z": "cb091dda25252c01",
        "name": "ParseUui-OpenSIPs",
        "rules": [
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(payload.uui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "split[0]\t",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "split[2]",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 660,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "0ad63c0b0caa3bf6",
        "type": "comment",
        "z": "cb091dda25252c01",
        "name": "Replace the ParseUui-New Nodes with this ParseUui-OpenSIPs once it has been moved over",
        "info": "",
        "x": 640,
        "y": 560,
        "wires": []
    },
    {
        "id": "75c89f53ecc25321",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "499a28b954ecb5bb",
        "name": "ConvertTo12Hr",
        "func": "// Node-RED Function Node - Convert Patient Time to 12-Hour Format\n// This code is designed to run inside a Node-RED Function node\n// Converts time fields from 24-hour format (HH:MM or HH:MM:SS) to 12-hour format (h:mm AM/PM)\n// Processes the patient object from nodeGetPatient.js payload\n\n/**\n * Converts a 24-hour time string to 12-hour format and extracts date if present\n * @param {string} timeString - Time string in 24-hour format (HH:MM or HH:MM:SS) or ISO datetime\n * @returns {object} Object with converted time and extracted date: { time: \"h:mm AM/PM\", date: \"YYYY-MM-DD\" } or original string if conversion fails\n */\nfunction convert24HourTo12Hour(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return { time: timeString, date: null };\n    }\n\n    // Check if already in 12-hour format (contains AM/PM)\n    if (timeString.match(/\\d{1,2}:\\d{2}\\s*(AM|PM)/i)) {\n        return { time: timeString, date: null }; // Already in 12-hour format, no date extracted\n    }\n\n    // Check if it's an ISO datetime string - extract both date and time portions\n    let timeOnly = timeString;\n    let dateOnly = null;\n\n    if (timeString.includes('T')) {\n        // ISO format: extract date portion (YYYY-MM-DD)\n        const dateMatch = timeString.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n        if (dateMatch) {\n            dateOnly = dateMatch[1];\n        }\n\n        // Extract time portion (HH:MM:SS or HH:MM:SS.SSS)\n        const timeMatch = timeString.match(/T(\\d{2}):(\\d{2})(?::(\\d{2}))?(?:\\.\\d+)?/);\n        if (timeMatch) {\n            timeOnly = `${timeMatch[1]}:${timeMatch[2]}${timeMatch[3] ? ':' + timeMatch[3] : ''}`;\n        } else {\n            return { time: timeString, date: dateOnly }; // Can't extract time, return original with date if found\n        }\n    }\n\n    // Match 24-hour format: HH:MM or HH:MM:SS\n    const timeMatch = timeOnly.match(/^(\\d{1,2}):(\\d{2})(?::(\\d{2}))?$/);\n    if (!timeMatch) {\n        return { time: timeString, date: dateOnly }; // Not a valid 24-hour format, return original with date if found\n    }\n\n    const hours = parseInt(timeMatch[1], 10);\n    const minutes = timeMatch[2];\n    const seconds = timeMatch[3] || '';\n\n    // Validate hours\n    if (hours < 0 || hours > 23) {\n        return { time: timeString, date: dateOnly }; // Invalid hours, return original with date if found\n    }\n\n    // Convert to 12-hour format\n    let hours12 = hours;\n    let ampm = 'AM';\n\n    if (hours === 0) {\n        hours12 = 12; // Midnight\n    } else if (hours === 12) {\n        ampm = 'PM'; // Noon\n    } else if (hours > 12) {\n        hours12 = hours - 12;\n        ampm = 'PM';\n    }\n\n    // Format: h:mm AM/PM or h:mm:ss AM/PM\n    const time12Hour = `${hours12}:${minutes}${seconds ? ':' + seconds : ''} ${ampm}`;\n    return { time: time12Hour, date: dateOnly };\n}\n\n/**\n * Maps time field names to their corresponding date field names\n * @param {string} timeFieldName - Name of the time field\n * @returns {string} Corresponding date field name\n */\nfunction getDateFieldName(timeFieldName) {\n    const dateFieldMap = {\n        'time': 'date',\n        'start_time': 'start_date',\n        'end_time': 'end_date',\n        'apptTime': 'apptDate',\n        'appointment_time': 'appointment_date'\n    };\n    return dateFieldMap[timeFieldName] || timeFieldName.replace('_time', '_date').replace('Time', 'Date');\n}\n\n/**\n * Recursively processes an object to convert time fields and add date properties\n * @param {object} obj - Object to process\n * @param {array} timeFields - Array of field names that contain time values\n * @returns {object} Processed object with converted times and added date fields\n */\nfunction processObject(obj, timeFields = ['time', 'start_time', 'end_time', 'apptTime', 'appointment_time']) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n        return obj.map(item => processObject(item, timeFields));\n    }\n\n    // Create a copy to avoid mutating the original\n    const processed = { ...obj };\n\n    // Process each property\n    for (const key in processed) {\n        if (processed.hasOwnProperty(key)) {\n            const value = processed[key];\n\n            // Check if this is a time field that needs conversion\n            if (timeFields.includes(key) && typeof value === 'string') {\n                const converted = convert24HourTo12Hour(value);\n\n                // Update the time field with converted time\n                processed[key] = converted.time;\n\n                // Add date field if date was extracted and doesn't already exist\n                if (converted.date) {\n                    const dateFieldName = getDateFieldName(key);\n                    // Only add date field if it doesn't already exist\n                    if (!processed.hasOwnProperty(dateFieldName)) {\n                        processed[dateFieldName] = converted.date;\n                    }\n                }\n            }\n            // Recursively process nested objects and arrays\n            else if (typeof value === 'object' && value !== null) {\n                processed[key] = processObject(value, timeFields);\n            }\n        }\n    }\n\n    return processed;\n}\n\ntry {\n    // Validate that payload exists\n    if (!msg.payload) {\n        throw new Error('msg.payload is required');\n    }\n\n    node.warn('Converting time fields from 24-hour to 12-hour format...');\n\n    // Process the patient object (or array of patients)\n    const processedPayload = processObject(msg.payload);\n\n    node.warn('Time conversion completed successfully');\n\n    // Update the payload with processed data\n    msg.payload = processedPayload;\n\n    return msg;\n\n} catch (error) {\n    node.error('Error converting patient time format: ' + error.message, msg);\n\n    // Set error payload\n    msg.payload = {\n        success: false,\n        error: error.message || 'Unknown error occurred while converting time format',\n        errorType: error.name || 'Error',\n        timestamp: new Date().toISOString()\n    };\n\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 680,
        "wires": [
            []
        ]
    },
    {
        "id": "e1226d731376d750",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "730bdee0925a4184",
        "name": "Guardian Parent",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "phoneNum",
                "v": "3212002331",
                "vt": "str"
            },
            {
                "p": "payload"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u0007\ti8�g765313363-000000000001105456-SR-000-000000000000DEN130-248B8ED6|333725|421458314VO|5214da68-3794-4d42-be9c-7d5df787ab0b|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"firstName\":\"Kevin\",\"lastName\":\"TestMc\",\"phoneNumber\":\"3212002331\",\"birthDate\":\"2017-03-03\",\"insurance\":\"Delta\",\"emailAddress\":\"aiTest@intelepeer.com\"}",
        "payloadType": "json",
        "x": 200,
        "y": 2620,
        "wires": [
            [
                "d0092387f9cb86a2"
            ]
        ]
    },
    {
        "id": "2bf88d8e27c8845e",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1410,
        "y": 1740,
        "wires": []
    },
    {
        "id": "4529dc67ef023a24",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "normalizeTimeFormat",
        "func": "// Node-RED Function Node - Normalize Time Format\n// This code is designed to run inside a Node-RED Function node\n// Converts ISO datetime strings to separated date and time with timezone offset\n// Handles both ISO format and already-separated date/time formats\n\n/**\n * ============================================================================\n * NORMALIZE TIME FORMAT - Node-RED Function\n * ============================================================================\n * Converts time formats and creates convertedDateTime object with convertedDate and convertedTime.\n * \n * Handles multiple input formats:\n * - ISO with timezone: \"2026-04-13T16:00:00.000-04:00\" \n *   -> convertedDate: \"2026-04-13\", convertedTime: \"16:00:00.000-04:00\"\n * - ISO without timezone: \"2026-04-13T16:00:00\"\n *   -> convertedDate: \"2026-04-13\", convertedTime: \"16:00:00.000-04:00\" (detects timezone)\n * - Already separated 12-hour: apptTime: \"10:00 PM\", apptDate: \"2026-04-13\"\n *   -> convertedDate: \"2026-04-13\", convertedTime: \"10:00 PM\" (uses as-is)\n * - Already separated 24-hour: apptTime: \"15:15\", apptDate: \"2026-05-14\"\n *   -> convertedDate: \"2026-05-14\", convertedTime: \"3:15 PM\" (converts to 12-hour)\n * \n * Expected msg properties:\n * - msg.payload: Object with:\n *   - apptTime or time: Time string (ISO, 12-hour format, or 24-hour HH:MM format)\n *   - apptDate or date: Date string (YYYY-MM-DD format, optional if ISO format)\n * \n * Output msg properties:\n * - msg.payload.convertedDateTime: Object with:\n *   - convertedDate: \"YYYY-MM-DD\"\n *   - convertedTime: \"HH:mm:ss.SSS-04:00\" or \"h:mm A\" (12-hour format)\n * \n * Setup tab: Declare moment-timezone dependency:\n *   const moment = require('moment-timezone');\n */\n\n// ============================================================================\n// 🔧 UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check if a time string is in 12-hour format (e.g., \"10:00 PM\")\n */\nfunction is12HourFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for AM/PM indicators\n    return /^\\d{1,2}:\\d{2}\\s*(AM|PM)/i.test(timeString.trim());\n}\n\n/**\n * Check if a time string is in ISO format (with or without timezone)\n */\nfunction isISOFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for ISO format: contains 'T' and time pattern\n    return /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(timeString);\n}\n\n/**\n * Check if a time string is in 24-hour format without seconds (e.g., \"15:15\")\n */\nfunction is24HourFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for HH:MM format (24-hour, no seconds, no AM/PM)\n    // Must be exactly 5 characters (HH:MM) and match pattern\n    const trimmed = timeString.trim();\n    return /^\\d{2}:\\d{2}$/.test(trimmed) && trimmed.length === 5;\n}\n\n/**\n * Extract timezone offset from ISO string or detect from date\n * @param {string} isoString - ISO datetime string\n * @returns {string} Timezone offset like \"-04:00\" or \"+00:00\"\n */\nfunction getTimezoneOffset(isoString) {\n    if (!isoString || typeof isoString !== 'string') {\n        return '+00:00'; // Default to UTC\n    }\n    \n    // Check if timezone is already in the string\n    const tzMatch = isoString.match(/([+-]\\d{2}):(\\d{2})$/);\n    if (tzMatch) {\n        // Return with colon separator\n        return `${tzMatch[1]}:${tzMatch[2]}`;\n    }\n    \n    // Check for Z (UTC)\n    if (isoString.endsWith('Z')) {\n        return '+00:00';\n    }\n    \n    // If no timezone, parse the date and determine timezone\n    try {\n        // Try to parse as UTC first\n        let momentObj = moment.utc(isoString);\n        \n        if (!momentObj.isValid()) {\n            // Try parsing as local time\n            momentObj = moment(isoString);\n        }\n        \n        if (momentObj.isValid()) {\n            // Convert to Eastern timezone to get the offset\n            const easternMoment = momentObj.tz('America/New_York');\n            const offsetMinutes = easternMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            \n            return `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        }\n    } catch (error) {\n        node.warn(`[normalizeTimeFormat] Error determining timezone for ${isoString}: ${error.message}`);\n    }\n    \n    // Default to UTC if we can't determine\n    return '+00:00';\n}\n\n/**\n * Convert ISO datetime to convertedDateTime object\n * Preserves the time value and only adds the timezone offset (does not convert timezone)\n * @param {string} isoString - ISO datetime string\n * @param {string} [dateString] - Optional date string (if already separated)\n * @returns {object} { convertedDate: string, convertedTime: string }\n */\nfunction convertISOToDateTime(isoString, dateString = null) {\n    if (!isoString || typeof isoString !== 'string') {\n        return null;\n    }\n    \n    try {\n        // Extract date and time portions directly from the ISO string\n        const dateMatch = isoString.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n        const timeMatch = isoString.match(/T(\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?)/);\n        \n        if (!dateMatch || !timeMatch) {\n            node.warn(`[normalizeTimeFormat] Could not parse ISO string: ${isoString}`);\n            return null;\n        }\n        \n        // Extract date (YYYY-MM-DD)\n        const convertedDate = dateMatch[1];\n        \n        // Extract time portion (preserve as-is, don't convert)\n        let timePortion = timeMatch[1];\n        \n        // Ensure milliseconds are present (add .000 if missing)\n        if (!timePortion.includes('.')) {\n            timePortion += '.000';\n        }\n        \n        // Check if timezone offset is already in the string\n        const tzMatch = isoString.match(/([+-]\\d{2}):(\\d{2})$/);\n        let offset;\n        \n        if (tzMatch) {\n            // Use the existing timezone offset\n            offset = `${tzMatch[1]}:${tzMatch[2]}`;\n        } else if (isoString.endsWith('Z')) {\n            // UTC - but we need to determine Eastern timezone offset for this date\n            const dateMoment = moment.tz(convertedDate + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        } else {\n            // No timezone specified - determine Eastern timezone offset for this date\n            // Parse the date to determine if it's DST or not\n            const dateMoment = moment.tz(convertedDate + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        }\n        \n        const convertedTime = `${timePortion}${offset}`;\n        \n        // Create full ISO8601 string: YYYY-MM-DDTHH:mm:ss.SSS-04:00\n        const convertedDateTime = `${convertedDate}T${convertedTime}`;\n        \n        return {\n            convertedDate,\n            convertedTime,\n            convertedDateTime\n        };\n        \n    } catch (error) {\n        node.warn(`[normalizeTimeFormat] Error converting ISO: ${isoString}, error: ${error.message}`);\n        return null;\n    }\n}\n\n/**\n * Process an object and return convertedEntry object\n * @param {object} obj - Object to process\n * @returns {object} convertedEntry object with convertedDate, convertedTime, and convertedDateTime\n */\nfunction processObject(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return null;\n    }\n    \n    // Look for time field (apptTime, time, or end_time)\n    const timeField = obj.apptTime || obj.time || obj.end_time;\n    const dateField = obj.apptDate || obj.date;\n    \n    if (!timeField) {\n        return null;\n    }\n    \n    // Check if it's already in correct format (12-hour with separate date)\n    if (is12HourFormat(timeField) && dateField) {\n        // Already in correct format - use as-is\n        // Create ISO8601 string by parsing the 12-hour time and date\n        try {\n            const combinedString = `${dateField} ${timeField}`;\n            const parsedMoment = moment(combinedString, 'YYYY-MM-DD h:mm A');\n            \n            if (parsedMoment.isValid()) {\n                // Determine timezone offset for this date\n                const dateMoment = moment.tz(dateField + 'T12:00:00', 'America/New_York');\n                const offsetMinutes = dateMoment.utcOffset();\n                const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n                const offsetMins = Math.abs(offsetMinutes) % 60;\n                const sign = offsetMinutes >= 0 ? '+' : '-';\n                const offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n                \n                // Format time as 24-hour with milliseconds\n                const time24Hour = parsedMoment.format('HH:mm:ss') + '.000';\n                const convertedDateTime = `${dateField}T${time24Hour}${offset}`;\n                \n                return {\n                    convertedDate: dateField,\n                    convertedTime: timeField,\n                    convertedDateTime: convertedDateTime\n                };\n            }\n        } catch (error) {\n            node.warn(`[normalizeTimeFormat] Error parsing 12-hour format: ${error.message}`);\n        }\n        \n        // Fallback if parsing fails\n        return {\n            convertedDate: dateField,\n            convertedTime: timeField,\n            convertedDateTime: null\n        };\n    } else if (is24HourFormat(timeField) && dateField) {\n        // 24-hour format (HH:MM) with separate date - convert it\n        // Assumes America/New_York timezone, does not adjust the date\n        try {\n            // Validate date format (YYYY-MM-DD)\n            if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(dateField)) {\n                node.warn(`[normalizeTimeFormat] Invalid date format: ${dateField}`);\n                return {\n                    convertedDate: dateField,\n                    convertedTime: timeField,\n                    convertedDateTime: null\n                };\n            }\n            \n            // Determine timezone offset for America/New_York (handles DST automatically)\n            // Date is preserved as-is, only used to determine correct offset\n            const dateMoment = moment.tz(dateField + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            const offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n            \n            // Format time as HH:mm:ss.000 with timezone offset (date unchanged)\n            const timeWithSeconds = timeField + ':00.000';\n            const convertedTime = `${timeWithSeconds}${offset}`;\n            const convertedDateTime = `${dateField}T${convertedTime}`;\n            \n            // Convert to 12-hour format for convertedTime (to match expected output)\n            const parsedMoment = moment(`${dateField} ${timeField}`, 'YYYY-MM-DD HH:mm');\n            const time12Hour = parsedMoment.isValid() ? parsedMoment.format('h:mm A') : timeField;\n            \n            return {\n                convertedDate: dateField, // Date preserved as-is\n                convertedTime: time12Hour,\n                convertedDateTime: convertedDateTime\n            };\n        } catch (error) {\n            node.warn(`[normalizeTimeFormat] Error parsing 24-hour format: ${error.message}`);\n            return {\n                convertedDate: dateField,\n                convertedTime: timeField,\n                convertedDateTime: null\n            };\n        }\n    } else if (isISOFormat(timeField)) {\n        // ISO format - convert it\n        const converted = convertISOToDateTime(timeField, dateField);\n        return converted;\n    } else {\n        // Unknown format - try to use as-is\n        node.warn(`[normalizeTimeFormat] Unknown time format: ${timeField}`);\n        return {\n            convertedDate: dateField || null,\n            convertedTime: timeField,\n            convertedDateTime: null\n        };\n    }\n}\n\n// ============================================================================\n// 🚀 MAIN EXECUTION\n// ============================================================================\n\ntry {\n    const payload = msg.payload;\n    \n    if (!payload) {\n        node.log('[normalizeTimeFormat] No payload to process');\n        return msg;\n    }\n    \n    // Process the payload object to create convertedEntry\n    let convertedEntry = null;\n    \n    if (typeof payload === 'string') {\n        // Single time string - try to convert\n        convertedEntry = convertISOToDateTime(payload);\n        node.log(`[normalizeTimeFormat] Processed single time string`);\n    } else if (typeof payload === 'object') {\n        // Object - process it\n        convertedEntry = processObject(payload);\n        node.log('[normalizeTimeFormat] Processed object');\n    }\n    \n    // Set msg.convertedEntry if we have a result\n    if (convertedEntry) {\n        msg.convertedEntry = convertedEntry;\n        \n        // Log example conversion for debugging\n        node.log(`[normalizeTimeFormat] convertedDate=${convertedEntry.convertedDate}, convertedTime=${convertedEntry.convertedTime}, convertedDateTime=${convertedEntry.convertedDateTime}`);\n    } else {\n        node.warn('[normalizeTimeFormat] No convertedEntry created - check input format');\n    }\n    \n    // Keep original payload intact\n    // msg.payload remains unchanged\n    \n    return msg;\n    \n} catch (error) {\n    node.error('[normalizeTimeFormat] Error: ' + error.message, msg);\n    \n    msg.payload = {\n        error: error.message,\n        originalPayload: msg.payload\n    };\n    \n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "moment",
                "module": "moment-timezone"
            }
        ],
        "x": 860,
        "y": 1740,
        "wires": [
            [
                "fc5398a0b2cde9f0",
                "6637def903adec31"
            ]
        ]
    },
    {
        "id": "e2879838ddc5c0a4",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "createChildAppt Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1550,
        "y": 1680,
        "wires": []
    },
    {
        "id": "fc5398a0b2cde9f0",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "ConvertedTime",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1000,
        "y": 1700,
        "wires": []
    },
    {
        "id": "024d2d34aa8b528d",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "",
        "url": "/chord/createChildAppt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 250,
        "y": 1740,
        "wires": [
            [
                "6c34ab1ffb06eae2"
            ]
        ]
    },
    {
        "id": "f912a63cf4fee944",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "Parsed Create",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 1780,
        "wires": []
    },
    {
        "id": "ef3a424d1b4deaae",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "Ingress createChildAppt",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 1680,
        "wires": []
    },
    {
        "id": "6637def903adec31",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "createChildAppt-NA",
        "func": "// Node-RED Function Node - Create Appointment\n// This code is designed to run inside a Node-RED Function node\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n/* global fetch, node, msg, flow */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n/*\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n*/\n\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst patientId = msg.payload.patientId;\nconst phoneNumber = msg.payload.phoneNumber;\n\n// Child's information\nconst childFirstName = msg.payload.childFirstName || msg.payload.child_first_name;\nconst childLastName = msg.payload.childLastName || msg.payload.child_last_name;\nconst childDateOfBirth = msg.payload.childDateOfBirth || msg.payload.child_date_of_birth;\n\nconst startTime = msg.convertedEntry.convertedDateTime;\nconst operatoryId = msg.payload.operatoryId;\nconst note = \"Schedule by AI\";\n\nasync function createChildsAppointment() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID (parent/guardian) is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!startTime) {\n            throw new Error('Start time is required');\n        }\n\n        if (!operatoryId) {\n            throw new Error('Operatory ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Validate child information\n        if (!childFirstName) {\n            throw new Error('Child\\'s first name is required');\n        }\n\n        if (!childLastName) {\n            throw new Error('Child\\'s last name is required');\n        }\n\n        if (!childDateOfBirth) {\n            throw new Error('Child\\'s date of birth is required');\n        }\n\n        // Validate startTime format (ISO 8601)\n        const dateObj = new Date(startTime);\n        if (isNaN(dateObj.getTime())) {\n            throw new Error('Invalid start time format. Expected ISO 8601 format.');\n        }\n\n        // Get authentication token from flow context (managed by scheduled authentication node)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n        node.warn(startTime);\n\n        // Create the appointment with guardian flag and child patient information\n        const raw = JSON.stringify({\n            \"appt\": {\n                \"patient_id\": patientId,\n                \"is_guardian\": true,\n                \"provider_id\": providerId,\n                \"start_time\": startTime,\n                \"operatory_id\": operatoryId,\n                \"note\": note,\n                \"patient\": {\n                    \"first_name\": childFirstName,\n                    \"last_name\": childLastName,\n                    \"bio\": {\n                        \"date_of_birth\": childDateOfBirth,\n                        \"phone_number\": phoneNumber\n                    }\n                }\n            },\n            \"appointments_per_timeslot\": 1\n        });\n\n        const apptRequestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Creating appointment for child...');\n        const apptResponse = await fetch(\"https://nexhealth.info/appointments?subdomain=cdm&location_id=\" + locationId + \"&notify_patient=false\", apptRequestOptions);\n\n        // Check for HTTP errors\n        if (!apptResponse.ok) {\n            const errorText = await apptResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Create appointment failed with status ${apptResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate appointment response\n        let result;\n        try {\n            result = await apptResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment creation response: ${parseError.message}`);\n        }\n\n        node.warn('Appointment created successfully');\n\n        // Validate that appointment was created successfully\n        if (!result.data || !result.data.appt || !result.data.appt.id) {\n            throw new Error('Appointment creation may not have been successful. No appointment ID returned.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Appointment created successfully',\n            appointmentId: result.data.appt.id,\n            data: result\n        };\n        msg.payload = msg.payload.data.data.appt\n        return msg;\n\n    } catch (error) {\n        node.error('Error creating appointment: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during appointment creation',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn createChildsAppointment();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 1140,
        "y": 1740,
        "wires": [
            [
                "2bf88d8e27c8845e",
                "e2879838ddc5c0a4"
            ]
        ]
    },
    {
        "id": "ccf30b19041c58f4",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 600,
        "y": 1740,
        "wires": [
            [
                "f912a63cf4fee944",
                "4529dc67ef023a24"
            ]
        ]
    },
    {
        "id": "a1f34f82a22e7450",
        "type": "http in",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "name": "",
        "url": "/chord/editPatientInsurance",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 280,
        "y": 2780,
        "wires": [
            [
                "1efffca56bfbbb63"
            ]
        ]
    },
    {
        "id": "43caccec5fbb1d7b",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "name": "Ingress EditPatientInsurance",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 2740,
        "wires": []
    },
    {
        "id": "88cf081c7d5609c2",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "name": "EditPatientInsurance Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 2780,
        "wires": []
    },
    {
        "id": "9f4e824644d1d389",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "name": "",
        "props": [
            {
                "p": "payload.patientId",
                "v": "436432657",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.insuranceName",
                "v": "Delta Dental",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u0007\ti8�g765313363-000000000001105456-SR-000-000000000000DEN130-248B8ED6|333725|421458314VO|5214da68-3794-4d42-be9c-7d5df787ab0b|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 370,
        "y": 2740,
        "wires": [
            [
                "1efffca56bfbbb63"
            ]
        ]
    },
    {
        "id": "dbd0d16e591a7343",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 930,
        "y": 2780,
        "wires": []
    },
    {
        "id": "bd07c44a370ae0f8",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "name": "editPatientInsurance-NA",
        "func": "// Node-RED Function Node - Edit Patient Insurance\n// This code is designed to run inside a Node-RED Function node\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n/* global fetch, node, msg, flow */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst patientId = msg.payload.patientId;\nconst insuranceName = msg.payload.insuranceName;\nconst subdomain = msg.subdomain || \"cdm\";\n\nasync function editInsurance() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        if (!insuranceName) {\n            throw new Error('Insurance name is required');\n        }\n\n        // Get authentication token from flow context (managed by scheduled authentication node)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build the patient update data\n        const patientData = {\n            \"patient\": {\n                \"bio\": {\n                    \"insurance_name\": insuranceName\n                }\n            }\n        };\n\n        const raw = JSON.stringify(patientData);\n\n        const patientRequestOptions = {\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Updating patient insurance...');\n        const patientResponse = await fetch(\"https://nexhealth.info/patients/\" + patientId + \"?subdomain=\" + subdomain + \"&location_id=\" + locationId, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Edit insurance failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse insurance update response: ${parseError.message}`);\n        }\n\n        node.warn('Insurance updated successfully');\n        node.warn(result);\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Insurance updated successfully',\n            patient: result.data || result,\n            fullResponse: result\n        };\n        msg.payload = msg.payload.patient || msg.payload.fullResponse;\n        return msg;\n\n    } catch (error) {\n        node.error('Error editing insurance: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during insurance update',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn editInsurance();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 930,
        "y": 2740,
        "wires": [
            [
                "dbd0d16e591a7343",
                "88cf081c7d5609c2"
            ]
        ]
    },
    {
        "id": "a01cc523c75d0b7c",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "f981b1c14633130a",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 660,
        "y": 2780,
        "wires": [
            [
                "bd07c44a370ae0f8"
            ]
        ]
    },
    {
        "id": "90b8f3d1b7351536",
        "type": "function",
        "z": "cb091dda25252c01",
        "name": "createChildAppt-NA",
        "func": "// Node-RED Function Node - Create Appointment\n// This code is designed to run inside a Node-RED Function node\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n/* global fetch, node, msg, flow */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\n/*\nconst providerId = msg.payload.providerId || env.get(\"providerId\");\nconst locationId = msg.payload.locationId || env.get(\"locationId\");\n*/\n\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst patientId = msg.payload.patientId;\nconst phoneNumber = msg.payload.phoneNumber;\n\n// Child's information\nconst childFirstName = msg.payload.childFirstName || msg.payload.child_first_name;\nconst childLastName = msg.payload.childLastName || msg.payload.child_last_name;\nconst childDateOfBirth = msg.payload.childDateOfBirth || msg.payload.child_date_of_birth;\n\nconst startTime = msg.convertedEntry.convertedDateTime;\nconst operatoryId = msg.payload.operatoryId;\nconst note = \"Schedule by AI\";\n\nasync function createChildsAppointment() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!patientId) {\n            throw new Error('Patient ID (parent/guardian) is required');\n        }\n\n        if (!providerId) {\n            throw new Error('Provider ID is required');\n        }\n\n        if (!startTime) {\n            throw new Error('Start time is required');\n        }\n\n        if (!operatoryId) {\n            throw new Error('Operatory ID is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        // Validate child information\n        if (!childFirstName) {\n            throw new Error('Child\\'s first name is required');\n        }\n\n        if (!childLastName) {\n            throw new Error('Child\\'s last name is required');\n        }\n\n        if (!childDateOfBirth) {\n            throw new Error('Child\\'s date of birth is required');\n        }\n\n        // Validate startTime format (ISO 8601)\n        const dateObj = new Date(startTime);\n        if (isNaN(dateObj.getTime())) {\n            throw new Error('Invalid start time format. Expected ISO 8601 format.');\n        }\n\n        // Get authentication token from flow context (managed by scheduled authentication node)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n        node.warn(startTime);\n\n        // Create the appointment with guardian flag and child patient information\n        const raw = JSON.stringify({\n            \"appt\": {\n                \"patient_id\": patientId,\n                \"is_guardian\": true,\n                \"provider_id\": providerId,\n                \"start_time\": startTime,\n                \"operatory_id\": operatoryId,\n                \"note\": note,\n                \"patient\": {\n                    \"first_name\": childFirstName,\n                    \"last_name\": childLastName,\n                    \"bio\": {\n                        \"date_of_birth\": childDateOfBirth,\n                        \"phone_number\": phoneNumber\n                    }\n                }\n            },\n            \"appointments_per_timeslot\": 1\n        });\n\n        const apptRequestOptions = {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            body: raw,\n            redirect: \"follow\"\n        };\n\n        node.warn('Creating appointment for child...');\n        const apptResponse = await fetch(\"https://nexhealth.info/appointments?subdomain=cdm&location_id=\" + locationId + \"&notify_patient=false\", apptRequestOptions);\n\n        // Check for HTTP errors\n        if (!apptResponse.ok) {\n            const errorText = await apptResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Create appointment failed with status ${apptResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate appointment response\n        let result;\n        try {\n            result = await apptResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment creation response: ${parseError.message}`);\n        }\n\n        node.warn('Appointment created successfully');\n\n        // Validate that appointment was created successfully\n        if (!result.data || !result.data.appt || !result.data.appt.id) {\n            throw new Error('Appointment creation may not have been successful. No appointment ID returned.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Appointment created successfully',\n            appointmentId: result.data.appt.id,\n            data: result\n        };\n        msg.payload = msg.payload.data.data.appt\n        return msg;\n\n    } catch (error) {\n        node.error('Error creating appointment: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred during appointment creation',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn createChildsAppointment();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 1120,
        "y": 1840,
        "wires": [
            [
                "084814a847d94dd4"
            ]
        ]
    },
    {
        "id": "13c16df532ab11fe",
        "type": "change",
        "z": "cb091dda25252c01",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 660,
        "y": 1840,
        "wires": [
            [
                "1b670f0b7bc77b86"
            ]
        ]
    },
    {
        "id": "1b670f0b7bc77b86",
        "type": "function",
        "z": "cb091dda25252c01",
        "name": "normalizeTimeFormat",
        "func": "// Node-RED Function Node - Normalize Time Format\n// This code is designed to run inside a Node-RED Function node\n// Converts ISO datetime strings to separated date and time with timezone offset\n// Handles both ISO format and already-separated date/time formats\n\n/**\n * ============================================================================\n * NORMALIZE TIME FORMAT - Node-RED Function\n * ============================================================================\n * Converts time formats and creates convertedDateTime object with convertedDate and convertedTime.\n * \n * Handles multiple input formats:\n * - ISO with timezone: \"2026-04-13T16:00:00.000-04:00\" \n *   -> convertedDate: \"2026-04-13\", convertedTime: \"16:00:00.000-04:00\"\n * - ISO without timezone: \"2026-04-13T16:00:00\"\n *   -> convertedDate: \"2026-04-13\", convertedTime: \"16:00:00.000-04:00\" (detects timezone)\n * - Already separated 12-hour: apptTime: \"10:00 PM\", apptDate: \"2026-04-13\"\n *   -> convertedDate: \"2026-04-13\", convertedTime: \"10:00 PM\" (uses as-is)\n * - Already separated 24-hour: apptTime: \"15:15\", apptDate: \"2026-05-14\"\n *   -> convertedDate: \"2026-05-14\", convertedTime: \"3:15 PM\" (converts to 12-hour)\n * \n * Expected msg properties:\n * - msg.payload: Object with:\n *   - apptTime or time: Time string (ISO, 12-hour format, or 24-hour HH:MM format)\n *   - apptDate or date: Date string (YYYY-MM-DD format, optional if ISO format)\n * \n * Output msg properties:\n * - msg.payload.convertedDateTime: Object with:\n *   - convertedDate: \"YYYY-MM-DD\"\n *   - convertedTime: \"HH:mm:ss.SSS-04:00\" or \"h:mm A\" (12-hour format)\n * \n * Setup tab: Declare moment-timezone dependency:\n *   const moment = require('moment-timezone');\n */\n\n// ============================================================================\n// 🔧 UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check if a time string is in 12-hour format (e.g., \"10:00 PM\")\n */\nfunction is12HourFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for AM/PM indicators\n    return /^\\d{1,2}:\\d{2}\\s*(AM|PM)/i.test(timeString.trim());\n}\n\n/**\n * Check if a time string is in ISO format (with or without timezone)\n */\nfunction isISOFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for ISO format: contains 'T' and time pattern\n    return /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(timeString);\n}\n\n/**\n * Check if a time string is in 24-hour format without seconds (e.g., \"15:15\")\n */\nfunction is24HourFormat(timeString) {\n    if (!timeString || typeof timeString !== 'string') {\n        return false;\n    }\n    // Check for HH:MM format (24-hour, no seconds, no AM/PM)\n    // Must be exactly 5 characters (HH:MM) and match pattern\n    const trimmed = timeString.trim();\n    return /^\\d{2}:\\d{2}$/.test(trimmed) && trimmed.length === 5;\n}\n\n/**\n * Extract timezone offset from ISO string or detect from date\n * @param {string} isoString - ISO datetime string\n * @returns {string} Timezone offset like \"-04:00\" or \"+00:00\"\n */\nfunction getTimezoneOffset(isoString) {\n    if (!isoString || typeof isoString !== 'string') {\n        return '+00:00'; // Default to UTC\n    }\n    \n    // Check if timezone is already in the string\n    const tzMatch = isoString.match(/([+-]\\d{2}):(\\d{2})$/);\n    if (tzMatch) {\n        // Return with colon separator\n        return `${tzMatch[1]}:${tzMatch[2]}`;\n    }\n    \n    // Check for Z (UTC)\n    if (isoString.endsWith('Z')) {\n        return '+00:00';\n    }\n    \n    // If no timezone, parse the date and determine timezone\n    try {\n        // Try to parse as UTC first\n        let momentObj = moment.utc(isoString);\n        \n        if (!momentObj.isValid()) {\n            // Try parsing as local time\n            momentObj = moment(isoString);\n        }\n        \n        if (momentObj.isValid()) {\n            // Convert to Eastern timezone to get the offset\n            const easternMoment = momentObj.tz('America/New_York');\n            const offsetMinutes = easternMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            \n            return `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        }\n    } catch (error) {\n        node.warn(`[normalizeTimeFormat] Error determining timezone for ${isoString}: ${error.message}`);\n    }\n    \n    // Default to UTC if we can't determine\n    return '+00:00';\n}\n\n/**\n * Convert ISO datetime to convertedDateTime object\n * Preserves the time value and only adds the timezone offset (does not convert timezone)\n * @param {string} isoString - ISO datetime string\n * @param {string} [dateString] - Optional date string (if already separated)\n * @returns {object} { convertedDate: string, convertedTime: string }\n */\nfunction convertISOToDateTime(isoString, dateString = null) {\n    if (!isoString || typeof isoString !== 'string') {\n        return null;\n    }\n    \n    try {\n        // Extract date and time portions directly from the ISO string\n        const dateMatch = isoString.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n        const timeMatch = isoString.match(/T(\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?)/);\n        \n        if (!dateMatch || !timeMatch) {\n            node.warn(`[normalizeTimeFormat] Could not parse ISO string: ${isoString}`);\n            return null;\n        }\n        \n        // Extract date (YYYY-MM-DD)\n        const convertedDate = dateMatch[1];\n        \n        // Extract time portion (preserve as-is, don't convert)\n        let timePortion = timeMatch[1];\n        \n        // Ensure milliseconds are present (add .000 if missing)\n        if (!timePortion.includes('.')) {\n            timePortion += '.000';\n        }\n        \n        // Check if timezone offset is already in the string\n        const tzMatch = isoString.match(/([+-]\\d{2}):(\\d{2})$/);\n        let offset;\n        \n        if (tzMatch) {\n            // Use the existing timezone offset\n            offset = `${tzMatch[1]}:${tzMatch[2]}`;\n        } else if (isoString.endsWith('Z')) {\n            // UTC - but we need to determine Eastern timezone offset for this date\n            const dateMoment = moment.tz(convertedDate + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        } else {\n            // No timezone specified - determine Eastern timezone offset for this date\n            // Parse the date to determine if it's DST or not\n            const dateMoment = moment.tz(convertedDate + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n        }\n        \n        const convertedTime = `${timePortion}${offset}`;\n        \n        // Create full ISO8601 string: YYYY-MM-DDTHH:mm:ss.SSS-04:00\n        const convertedDateTime = `${convertedDate}T${convertedTime}`;\n        \n        return {\n            convertedDate,\n            convertedTime,\n            convertedDateTime\n        };\n        \n    } catch (error) {\n        node.warn(`[normalizeTimeFormat] Error converting ISO: ${isoString}, error: ${error.message}`);\n        return null;\n    }\n}\n\n/**\n * Process an object and return convertedEntry object\n * @param {object} obj - Object to process\n * @returns {object} convertedEntry object with convertedDate, convertedTime, and convertedDateTime\n */\nfunction processObject(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return null;\n    }\n    \n    // Look for time field (apptTime, time, or end_time)\n    const timeField = obj.apptTime || obj.time || obj.end_time;\n    const dateField = obj.apptDate || obj.date;\n    \n    if (!timeField) {\n        return null;\n    }\n    \n    // Check if it's already in correct format (12-hour with separate date)\n    if (is12HourFormat(timeField) && dateField) {\n        // Already in correct format - use as-is\n        // Create ISO8601 string by parsing the 12-hour time and date\n        try {\n            const combinedString = `${dateField} ${timeField}`;\n            const parsedMoment = moment(combinedString, 'YYYY-MM-DD h:mm A');\n            \n            if (parsedMoment.isValid()) {\n                // Determine timezone offset for this date\n                const dateMoment = moment.tz(dateField + 'T12:00:00', 'America/New_York');\n                const offsetMinutes = dateMoment.utcOffset();\n                const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n                const offsetMins = Math.abs(offsetMinutes) % 60;\n                const sign = offsetMinutes >= 0 ? '+' : '-';\n                const offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n                \n                // Format time as 24-hour with milliseconds\n                const time24Hour = parsedMoment.format('HH:mm:ss') + '.000';\n                const convertedDateTime = `${dateField}T${time24Hour}${offset}`;\n                \n                return {\n                    convertedDate: dateField,\n                    convertedTime: timeField,\n                    convertedDateTime: convertedDateTime\n                };\n            }\n        } catch (error) {\n            node.warn(`[normalizeTimeFormat] Error parsing 12-hour format: ${error.message}`);\n        }\n        \n        // Fallback if parsing fails\n        return {\n            convertedDate: dateField,\n            convertedTime: timeField,\n            convertedDateTime: null\n        };\n    } else if (is24HourFormat(timeField) && dateField) {\n        // 24-hour format (HH:MM) with separate date - convert it\n        // Assumes America/New_York timezone, does not adjust the date\n        try {\n            // Validate date format (YYYY-MM-DD)\n            if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(dateField)) {\n                node.warn(`[normalizeTimeFormat] Invalid date format: ${dateField}`);\n                return {\n                    convertedDate: dateField,\n                    convertedTime: timeField,\n                    convertedDateTime: null\n                };\n            }\n            \n            // Determine timezone offset for America/New_York (handles DST automatically)\n            // Date is preserved as-is, only used to determine correct offset\n            const dateMoment = moment.tz(dateField + 'T12:00:00', 'America/New_York');\n            const offsetMinutes = dateMoment.utcOffset();\n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            const offset = `${sign}${String(offsetHours).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;\n            \n            // Format time as HH:mm:ss.000 with timezone offset (date unchanged)\n            const timeWithSeconds = timeField + ':00.000';\n            const convertedTime = `${timeWithSeconds}${offset}`;\n            const convertedDateTime = `${dateField}T${convertedTime}`;\n            \n            // Convert to 12-hour format for convertedTime (to match expected output)\n            const parsedMoment = moment(`${dateField} ${timeField}`, 'YYYY-MM-DD HH:mm');\n            const time12Hour = parsedMoment.isValid() ? parsedMoment.format('h:mm A') : timeField;\n            \n            return {\n                convertedDate: dateField, // Date preserved as-is\n                convertedTime: time12Hour,\n                convertedDateTime: convertedDateTime\n            };\n        } catch (error) {\n            node.warn(`[normalizeTimeFormat] Error parsing 24-hour format: ${error.message}`);\n            return {\n                convertedDate: dateField,\n                convertedTime: timeField,\n                convertedDateTime: null\n            };\n        }\n    } else if (isISOFormat(timeField)) {\n        // ISO format - convert it\n        const converted = convertISOToDateTime(timeField, dateField);\n        return converted;\n    } else {\n        // Unknown format - try to use as-is\n        node.warn(`[normalizeTimeFormat] Unknown time format: ${timeField}`);\n        return {\n            convertedDate: dateField || null,\n            convertedTime: timeField,\n            convertedDateTime: null\n        };\n    }\n}\n\n// ============================================================================\n// 🚀 MAIN EXECUTION\n// ============================================================================\n\ntry {\n    const payload = msg.payload;\n    \n    if (!payload) {\n        node.log('[normalizeTimeFormat] No payload to process');\n        return msg;\n    }\n    \n    // Process the payload object to create convertedEntry\n    let convertedEntry = null;\n    \n    if (typeof payload === 'string') {\n        // Single time string - try to convert\n        convertedEntry = convertISOToDateTime(payload);\n        node.log(`[normalizeTimeFormat] Processed single time string`);\n    } else if (typeof payload === 'object') {\n        // Object - process it\n        convertedEntry = processObject(payload);\n        node.log('[normalizeTimeFormat] Processed object');\n    }\n    \n    // Set msg.convertedEntry if we have a result\n    if (convertedEntry) {\n        msg.convertedEntry = convertedEntry;\n        \n        // Log example conversion for debugging\n        node.log(`[normalizeTimeFormat] convertedDate=${convertedEntry.convertedDate}, convertedTime=${convertedEntry.convertedTime}, convertedDateTime=${convertedEntry.convertedDateTime}`);\n    } else {\n        node.warn('[normalizeTimeFormat] No convertedEntry created - check input format');\n    }\n    \n    // Keep original payload intact\n    // msg.payload remains unchanged\n    \n    return msg;\n    \n} catch (error) {\n    node.error('[normalizeTimeFormat] Error: ' + error.message, msg);\n    \n    msg.payload = {\n        error: error.message,\n        originalPayload: msg.payload\n    };\n    \n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "moment",
                "module": "moment-timezone"
            }
        ],
        "x": 880,
        "y": 1840,
        "wires": [
            [
                "90b8f3d1b7351536"
            ]
        ]
    },
    {
        "id": "e9241c198db2f385",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "058e8eeb7d55776a",
        "name": "new Child Appt",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u0007\u0005i8l2765305129-000000000001105456-SR-000-000000000000DEN140-5AA00C14|333725|421458314VO|6733e082-0129-4e68-97dc-bd8b71aa02a6|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"patientId\":\"436432657\",\"apptTime\":\"4:15 PM\",\"operatoryId\":\"208834\",\"apptDate\":\"2026-06-11\",\"childFirstName\":\"Jojo\",\"childLastName\":\"McTest\",\"childDateOfBirth\":\"2022-06-11\"}",
        "payloadType": "json",
        "x": 320,
        "y": 1680,
        "wires": [
            [
                "6c34ab1ffb06eae2"
            ]
        ]
    },
    {
        "id": "084814a847d94dd4",
        "type": "debug",
        "z": "cb091dda25252c01",
        "name": "Testing Adding Child Patient",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1400,
        "y": 1840,
        "wires": []
    },
    {
        "id": "833982824e3d44a5",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "name": "GetAppointment Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1130,
        "y": 3720,
        "wires": []
    },
    {
        "id": "f5ee8fbba2beea3a",
        "type": "http in",
        "z": "cb091dda25252c01",
        "d": true,
        "g": "5013cdec34e6a01e",
        "name": "",
        "url": "/chord/getAppt",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 320,
        "y": 3720,
        "wires": [
            [
                "973139af2b430bd0"
            ]
        ]
    },
    {
        "id": "e528e03f3269879f",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "name": "",
        "props": [
            {
                "p": "payload.appointmentId",
                "v": "1131315368",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 390,
        "y": 3680,
        "wires": [
            [
                "973139af2b430bd0"
            ]
        ]
    },
    {
        "id": "e6ecf1b49bbb8002",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "name": "GetAppointment",
        "links": [],
        "x": 245,
        "y": 3680,
        "wires": [
            [
                "973139af2b430bd0"
            ]
        ]
    },
    {
        "id": "481b499410d9bd0b",
        "type": "http response",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 930,
        "y": 3720,
        "wires": []
    },
    {
        "id": "61f1fca8164c27dc",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "name": "CancelAppt",
        "mode": "return",
        "links": [],
        "x": 925,
        "y": 3680,
        "wires": []
    },
    {
        "id": "1ce1d4f4274f6222",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "name": "Ingress GetAppointment",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 690,
        "y": 3680,
        "wires": []
    },
    {
        "id": "73100eea61cea72d",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "5013cdec34e6a01e",
        "name": "getAppointment-NA",
        "func": "// Node-RED Function Node - Get Appointment\n// This code is designed to run inside a Node-RED Function node\n// Uses shared authentication token from flow context (managed by scheduled nodeAuthenticate node)\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n/* global fetch, node, msg, flow */\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst subdomain = msg.payload?.subdomain || msg.subdomain || msg.session?.subdomain || \"cdm\";\nconst appointmentId = msg.payload?.appointmentId;\n\n// Optional include parameters (e.g., ['patient'] to include patient data)\nconst includes = msg.payload.includes || msg.payload.include || [];\n\nasync function getAppointment() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!appointmentId) {\n            throw new Error('Appointment ID is required');\n        }\n\n        // Get authentication token from flow context (managed by scheduled authentication node)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n\n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`\n        ];\n\n        // Add include parameters if specified\n        if (Array.isArray(includes) && includes.length > 0) {\n            includes.forEach(include => {\n                queryParts.push(`include[]=${encodeURIComponent(include)}`);\n            });\n        } else if (typeof includes === 'string' && includes.trim() !== '') {\n            queryParts.push(`include[]=${encodeURIComponent(includes)}`);\n        }\n\n        // Build the full URL with appointmentId in the path\n        const url = `https://nexhealth.info/appointments/${appointmentId}?${queryParts.join('&')}`;\n\n        const apptRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/vnd.Nexhealth+json;version=2\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn(`Fetching appointment ${appointmentId}...`);\n        const apptResponse = await fetch(url, apptRequestOptions);\n\n        // Check for HTTP errors\n        if (!apptResponse.ok) {\n            const errorText = await apptResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get appointment failed with status ${apptResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate appointment response\n        let result;\n        try {\n            result = await apptResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse appointment response: ${parseError.message}`);\n        }\n\n        node.warn('Appointment retrieved successfully');\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Set the payload with results\n        msg.payload = {\n            success: true,\n            message: 'Appointment retrieved successfully',\n            appointment: result.data,\n            fullResponse: result\n        };\n        \n        // Return just the appointment data (matching pattern from other nodes)\n        msg.payload = msg.payload.appointment;\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting appointment: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while retrieving appointment',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAppointment();\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 720,
        "y": 3720,
        "wires": [
            [
                "833982824e3d44a5",
                "481b499410d9bd0b",
                "61f1fca8164c27dc"
            ]
        ]
    },
    {
        "id": "3a1f6826e414ea73",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "name": "getPatientByName Egress",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2780,
        "y": 360,
        "wires": []
    },
    {
        "id": "766016634b41b326",
        "type": "debug",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "name": "IngressGetPatientByName",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2180,
        "y": 360,
        "wires": []
    },
    {
        "id": "993e4a8ff84c663d",
        "type": "inject",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "name": "",
        "props": [
            {
                "p": "OGpatientId",
                "v": "427698262",
                "vt": "str"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload.email",
                "v": "aiTest@intelepeer.com",
                "vt": "str"
            },
            {
                "p": "payload.uui",
                "v": "�\b,\u00075i9��765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1910,
        "y": 360,
        "wires": [
            [
                "34497ab544b665d5"
            ]
        ]
    },
    {
        "id": "48e11d5b5dfe1731",
        "type": "link out",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "name": "getPatientsByEmail",
        "mode": "return",
        "links": [],
        "x": 2745,
        "y": 420,
        "wires": []
    },
    {
        "id": "fed7a803176396ca",
        "type": "link in",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "name": "getPatientByLastName",
        "links": [],
        "x": 1915,
        "y": 440,
        "wires": [
            [
                "34497ab544b665d5"
            ]
        ]
    },
    {
        "id": "9ea62f09a13d9973",
        "type": "change",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "name": "ParseUui-New",
        "rules": [
            {
                "t": "set",
                "p": "trimmedUui",
                "pt": "msg",
                "to": "$substring(payload.uui, 24)",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "split",
                "pt": "msg",
                "to": "$split(trimmedUui, \"|\")\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.ipId",
                "pt": "msg",
                "to": "$substring(split[0], 24)\t",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "session.locationId",
                "pt": "msg",
                "to": "split[1]",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "session.providerId",
                "pt": "msg",
                "to": "$replace(split[2], \"VO\", \"\")\t",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 2160,
        "y": 400,
        "wires": [
            [
                "10ef4f8903704779"
            ]
        ]
    },
    {
        "id": "10ef4f8903704779",
        "type": "function",
        "z": "cb091dda25252c01",
        "g": "4ab53e735c8a8bbf",
        "name": "getPatientByPhoneCombined-NA",
        "func": "// Node-RED Function Node - Get Patient By Phone Number (Combined - New and Existing Patients)\n// This code is designed to run inside a Node-RED Function node\n// Uncomment the line below if fetch is not available globally in your Node-RED version\n// You may need to install node-fetch: npm install node-fetch\n// const fetch = require('node-fetch');\n\n// Get parameters from msg object or use defaults\nconst apiKey = env.get(\"apiKey\");\nconst providerId = msg.session.providerId;\nconst locationId = msg.session.locationId;\n\nconst name = msg.payload.name;\nconst subdomain = msg.payload.subdomain || \"cdm\";\nconst perPage = msg.payload.per_page || 30;\nconst locationStrict = msg.payload.locationStrict || true;\n\nconst requestEndpoint = \"https://nexhealth.info/patients\";\n\n\nasync function getPatientsByNameAndNewPatientStatus(newPatient) {\n    try {\n        // Get authentication token (from flow context or authenticate)\n        const authToken = flow.get(\"nexhealth_auth_token\");\n        \n        if (!authToken) {\n            throw new Error('Authentication token not found in flow context. Ensure the scheduled authentication node (nodeAuthenticate) is running.');\n        }\n\n        // Build query parameters to search by phone number and new_patient status\n        const queryParts = [\n            `subdomain=${encodeURIComponent(subdomain)}`,\n            `location_id=${encodeURIComponent(locationId)}`,\n            `name=${encodeURIComponent(name)}`,\n            `new_patient=${encodeURIComponent(newPatient)}`,\n            `location_strict=${encodeURIComponent(locationStrict)}`,\n            `per_page=${encodeURIComponent(perPage)}`\n        ];\n\n        // Build the full URL\n        const url = `${requestEndpoint}?${queryParts.join('&')}`;\n\n        const patientRequestOptions = {\n            method: \"GET\",\n            headers: {\n                \"Nex-Api-Version\": \"v20240412\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": \"Bearer \" + authToken\n            },\n            redirect: \"follow\"\n        };\n\n        node.warn(`Searching for patients with name: ${name}, new_patient: ${newPatient}...`);\n        const patientResponse = await fetch(url, patientRequestOptions);\n\n        // Check for HTTP errors\n        if (!patientResponse.ok) {\n            const errorText = await patientResponse.text().catch(() => 'Unable to read error response');\n            throw new Error(`Get patient by name failed with status ${patientResponse.status}: ${errorText}`);\n        }\n\n        // Parse and validate patient response\n        let result;\n        try {\n            result = await patientResponse.json();\n        } catch (parseError) {\n            throw new Error(`Failed to parse patient response: ${parseError.message}`);\n        }\n\n        // Validate response structure\n        if (!result.data) {\n            throw new Error('Unexpected response structure. No data field found.');\n        }\n\n        // Return array of patients (handle both single object and array responses)\n        const patients = Array.isArray(result.data) ? result.data : [result.data];\n        node.warn(`Found ${patients.length} patient(s) with name: ${name}, new_patient: ${newPatient}`);\n        \n        return patients;\n\n    } catch (error) {\n        node.error(`Error getting patients with new_patient=${newPatient}: ${error.message}`, msg);\n        // Return empty array on error so we can still combine results\n        return [];\n    }\n}\n\nasync function getAllPatientsByName() {\n    try {\n        // Input validation\n        if (!apiKey) {\n            throw new Error('API key is required');\n        }\n\n        if (!name) {\n            throw new Error('name is required');\n        }\n\n        if (!locationId) {\n            throw new Error('Location ID is required');\n        }\n\n        node.warn(`Fetching all patients with name: ${name} (both new and existing)...`);\n\n        // Make both API calls concurrently using Promise.all\n        const [newPatients, existingPatients] = await Promise.all([\n            getPatientsByNameAndNewPatientStatus(true),\n            getPatientsByNameAndNewPatientStatus(false)\n        ]);\n\n        // Combine the results\n        const allPatients = [...newPatients, ...existingPatients];\n\n        node.warn(`Total patients found: ${allPatients.length} (${newPatients.length} new, ${existingPatients.length} existing)`);\n\n        if (allPatients.length === 0) {\n            // Store detailed info before setting payload\n            msg.patientInfo = {\n                success: true,\n                message: 'No patients found with this Name',\n                found: false,\n                name: name,\n                patients: [],\n                newPatients: [],\n                existingPatients: [],\n                totalCount: 0\n            };\n            msg.payload = [];\n        } else {\n            // Store detailed info before setting payload\n            msg.patientInfo = {\n                success: true,\n                message: `Found ${allPatients.length} patient(s)`,\n                found: true,\n                name: name,\n                patients: allPatients,\n                newPatients: newPatients,\n                existingPatients: existingPatients,\n                totalCount: allPatients.length,\n                newPatientCount: newPatients.length,\n                existingPatientCount: existingPatients.length\n            };\n\n            // Set payload to just the patient data array for easier downstream processing\n            msg.payload = allPatients;\n        }\n\n        return msg;\n\n    } catch (error) {\n        node.error('Error getting patients by Name: ' + error.message, msg);\n\n        // Set error payload\n        msg.payload = {\n            success: false,\n            error: error.message || 'Unknown error occurred while searching for patients',\n            errorType: error.name || 'Error',\n            timestamp: new Date().toISOString()\n        };\n\n        return msg;\n    }\n}\n\n// Execute the function and return the message\nreturn getAllPatientsByName();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fetch",
                "module": "node-fetch"
            }
        ],
        "x": 2460,
        "y": 400,
        "wires": [
            [
                "48e11d5b5dfe1731",
                "3a1f6826e414ea73"
            ]
        ]
    }
]