{
  "name": "chord_scheduling_OnlyCreateChildAppt",
  "description": "Unified appointment scheduling tool. Use action 'slots' to get available appointment times, 'grouped_slots' for booking multiple patients together (e.g., siblings), 'book_child' to create an appointment using slot data from [$selected_appointment] for yourself, or 'cancel' to cancel an existing appointment.",
  "color": "linear-gradient(rgb(60,49,1), rgb(49,157,2))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"description\":\"The operation to perform: 'slots' (get available times), 'grouped_slots' (times for multiple patients), 'book' (create appointment), 'book_child' (book child's appointment), 'cancel' (cancel appointment)\",\"type\":\"string\",\"required\":true},{\"id\":1,\"property\":\"numberOfPatients\",\"description\":\"vnumberOfPatients\\tnumber\\tNumber of patients booking together. Required for 'grouped_slots' action.\\tno\",\"type\":\"number\",\"required\":false},{\"id\":2,\"property\":\"timeWindowMinutes\",\"description\":\"Time window in minutes for grouped bookings. Required for 'grouped_slots' action.\",\"type\":\"number\",\"required\":false},{\"id\":3,\"property\":\"patientId\",\"description\":\"Patient ID to book for. Required for 'book' and 'book_child' actions.\",\"type\":\"string\",\"required\":false},{\"id\":4,\"property\":\"appointmentDate\",\"description\":\"Date of appointment (YYYY-MM-DD format). Required for 'book' and 'book_child' actions.\",\"type\":\"string\",\"required\":false},{\"id\":5,\"property\":\"appointmentTime\",\"description\":\"Time of appointment. Required for 'book' and 'book_child' action.\",\"type\":\"string\",\"required\":false},{\"id\":6,\"property\":\"operatoryId\",\"description\":\"Operatory/room ID from slots response. Required for 'book' and 'book_child' actions.\",\"type\":\"string\",\"required\":false},{\"id\":7,\"property\":\"appointmentId\",\"description\":\"Appointment ID to cancel. Required for 'cancel' action.\",\"type\":\"string\",\"required\":false},{\"id\":8,\"property\":\"childFirstName\",\"description\":\"This is the first name of the child.\",\"type\":\"string\",\"required\":false},{\"id\":9,\"property\":\"childLastName\",\"description\":\"This is the last name of the child.\",\"type\":\"string\",\"required\":false},{\"id\":10,\"property\":\"childDateOfBirth\",\"description\":\"This is the birth date of the child.\",\"type\":\"string\",\"required\":false},{\"id\":11,\"property\":\"phoneNumber\",\"description\":\"This is the phone number of the parent patient. It is required for 'book_child' actions.\",\"type\":\"string\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING - Unified Appointment Scheduling Tool (v02)\n * ============================================================================\n * Consolidates: getApptSlots, getGroupedApptSlots, createAppt, createChildsAppt, cancelAppointment\n * \n * Actions:\n *   - slots: Get available appointment slots\n *   - grouped_slots: Get slots for multiple patients booking together\n *   - book: Create/book an appointment\n *   - book_child: Create/book a parent's child's appointment\n *   - cancel: Cancel an existing appointment\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\n// ============================================================================\n// ðŸ“ ACTION CONFIGURATIONS\n// ============================================================================\n\nconst BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord';\n\nconst ACTIONS = {\n    slots: {\n        endpoint: `${BASE_URL}/getApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui\n        }),\n        validate: () => {},\n        successLog: (data) => `Found ${data.totalSlots || (data.slots ? data.slots.length : 0) || 0} available slots`\n    },\n    grouped_slots: {\n        endpoint: `${BASE_URL}/getGroupedApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            numberOfAppointments: params.numberOfPatients,\n            timeWindowMinutes: params.timeWindowMinutes\n        }),\n        validate: (params) => {\n            if (!params.numberOfPatients) {\n                throw new Error(\"numberOfPatients is required for 'grouped_slots' action\");\n            }\n            if (!params.timeWindowMinutes) {\n                throw new Error(\"timeWindowMinutes is required for 'grouped_slots' action\");\n            }\n        },\n        successLog: (data) => `Found ${data.totalGroups || (data.groups ? data.groups.length : 0) || 0} grouped slot options`\n    },\n    book: {\n        endpoint: `${BASE_URL}/createAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            patientId: params.patientId,\n            apptTime: params.appointmentTime,\n            operatoryId: params.operatoryId,\n            apptDate: params.appointmentDate\n        }),\n        validate: (params) => {\n            if (!params.patientId) throw new Error(\"patientId is required for 'book' action\");\n            if (!params.appointmentDate) throw new Error(\"appointmentDate is required for 'book' action\");\n            if (!params.appointmentTime) throw new Error(\"appointmentTime is required for 'book' action\");\n            if (!params.operatoryId) throw new Error(\"operatoryId is required for 'book' action\");\n        },\n        successLog: () => 'Appointment booked successfully'\n    },\n    book_child: {\n        endpoint: `${BASE_URL}/createChildAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            uui: uui,\n            patientId: params.patientId, // Parent's Patient ID\n            phoneNumber: params.phoneNumber,\n            childFirstName: params.childFirstName,\n            childLastName: params.childLastName,\n            childDateOfBirth: params.childDateOfBirth,\n            apptTime: params.appointmentTime,\n            operatoryId: params.operatoryId,\n            apptDate: params.appointmentDate\n        }),\n        validate: (params) => {\n            if (!params.patientId) throw new Error(\"patientId (parent/guardian) is required for 'book_child' action\");\n            if (!params.phoneNumber) throw new Error(\"phoneNumber is required for 'book_child' action\");\n            if (!params.childFirstName) throw new Error(\"childFirstName is required for 'book_child' action\");\n            if (!params.childLastName) throw new Error(\"childLastName is required for 'book_child' action\");\n            if (!params.childDateOfBirth) throw new Error(\"childDateOfBirth is required for 'book_child' action\");\n            if (!params.appointmentDate) throw new Error(\"appointmentDate is required for 'book_child' action\");\n            if (!params.appointmentTime) throw new Error(\"appointmentTime is required for 'book_child' action\");\n            if (!params.operatoryId) throw new Error(\"operatoryId is required for 'book_child' action\");\n        },\n        successLog: () => 'Child\\'s appointment booked successfully'\n    },\n    cancel: {\n        endpoint: `${BASE_URL}/cancelAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({\n            appointmentId: params.appointmentId\n        }),\n        validate: (params) => {\n            if (!params.appointmentId) {\n                throw new Error(\"appointmentId is required for 'cancel' action\");\n            }\n        },\n        successLog: () => 'Appointment cancelled successfully'\n    }\n};\n\n// ============================================================================\n// ðŸ” AUTHENTICATION\n// ============================================================================\n\nfunction getAuthHeader() {\n    try {\n        const username = \"workflowapi\";\n        const password = \"e^@V95&6sAJReTsb5!iq39mIC4HYIV\";\n        if (username && password) {\n            const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n            return `Basic ${credentials}`;\n        }\n    } catch (e) {\n        return null;\n    }\n    return null;\n}\n\n// ============================================================================\n// ðŸ” ERROR DETECTION HELPER\n// ============================================================================\n\nfunction checkForError(data) {\n    if (!data || typeof data !== 'object') return null;\n    \n    // Check for various error patterns from backend\n    // Pattern 1: { success: false, error: \"...\" }\n    if (data.success === false) {\n        return data.error || data.message || 'Operation failed';\n    }\n    \n    // Pattern 2: { code: false, error: [...] } - Nexhealth API pattern\n    if (data.code === false) {\n        if (Array.isArray(data.error)) {\n            return data.error.join(', ');\n        }\n        return data.error || data.message || 'API returned error';\n    }\n    \n    // Pattern 3: String response containing error message\n    if (typeof data === 'string' && data.toLowerCase().includes('failed')) {\n        return data;\n    }\n    \n    // Pattern 4: { error: \"...\" } without success/code field (but not valid response with error field)\n    if (data.error && !data.data && !data.id && !data.slots && !data.groups && !data.appointments) {\n        if (Array.isArray(data.error)) {\n            return data.error.join(', ');\n        }\n        return data.error;\n    }\n    \n    return null;\n}\n\n// ============================================================================\n// ðŸš€ HTTP REQUEST ENGINE\n// ============================================================================\n\nasync function executeRequest() {\n    const toolName = 'chord_scheduling';\n    const action = $action;\n    const timeout = 30000;\n    \n    console.log(`[${toolName}] Action: ${action}`);\n    \n    // Validate action\n    if (!action || !ACTIONS[action]) {\n        const validActions = Object.keys(ACTIONS).join(', ');\n        throw new Error(`Invalid action '${action}'. Valid actions: ${validActions}`);\n    }\n    \n    const config = ACTIONS[action];\n    \n    // Get UUI with fallback\n    let uui;\n    if (!$vars || !$vars.c1mg_uui || $vars.c1mg_uui === 'c1mg_uui' || (typeof $vars.c1mg_uui === 'string' && $vars.c1mg_uui.trim() === '')) {\n        uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';\n    } else {\n        uui = $vars.c1mg_uui;\n    }\n    \n    // Build params object from Flowise variables\n    const params = {\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientId: typeof $patientId !== 'undefined' ? $patientId : null,\n        phoneNumber: typeof $phoneNumber !== 'undefined' ? $phoneNumber : null,\n        appointmentDate: typeof $appointmentDate !== 'undefined' ? $appointmentDate : null,\n        appointmentTime: typeof $appointmentTime !== 'undefined' ? $appointmentTime : null,\n        operatoryId: typeof $operatoryId !== 'undefined' ? $operatoryId : null,\n        appointmentId: typeof $appointmentId !== 'undefined' ? $appointmentId : null,\n        // Child-specific parameters\n        childFirstName: typeof $childFirstName !== 'undefined' ? $childFirstName : null,\n        childLastName: typeof $childLastName !== 'undefined' ? $childLastName : null,\n        childDateOfBirth: typeof $childDateOfBirth !== 'undefined' ? $childDateOfBirth : null\n    };\n    \n    try {\n        // Validate required params for this action\n        config.validate(params);\n        \n        const body = config.buildBody(params, uui);\n        console.log(`[${toolName}] Endpoint: ${config.method} ${config.endpoint}`);\n        console.log(`[${toolName}] Request Body:`, JSON.stringify(body, null, 2));\n        \n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        \n        const authHeader = getAuthHeader();\n        if (authHeader) {\n            headers['Authorization'] = authHeader;\n        }\n        \n        const options = {\n            method: config.method,\n            headers: headers,\n            body: JSON.stringify(body)\n        };\n        \n        // Add timeout\n        let timeoutId;\n        if (typeof AbortController !== 'undefined') {\n            const controller = new AbortController();\n            timeoutId = setTimeout(() => controller.abort(), timeout);\n            options.signal = controller.signal;\n        }\n        \n        console.log(`[${toolName}] Making request...`);\n        const response = await fetch(config.endpoint, options);\n        \n        if (timeoutId) clearTimeout(timeoutId);\n        \n        console.log(`[${toolName}] Response Status: ${response.status} ${response.statusText}`);\n        \n        let data;\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            data = await response.json();\n        } else {\n            data = await response.text();\n        }\n        \n        // Check HTTP status\n        if (!response.ok) {\n            console.error(`[${toolName}] HTTP Error ${response.status}:`, data);\n            // Try to extract error message from response body\n            let errorMsg = `HTTP ${response.status}: ${response.statusText}`;\n            if (data) {\n                const bodyError = checkForError(typeof data === 'string' ? (() => { try { return JSON.parse(data); } catch(e) { return data; } })() : data);\n                if (bodyError) errorMsg = bodyError;\n            }\n            throw new Error(errorMsg);\n        }\n        \n        // Parse response if string\n        let responseData = data;\n        if (typeof data === 'string') {\n            try { responseData = JSON.parse(data); } catch (e) { responseData = data; }\n        }\n        \n        // Check for error patterns in successful HTTP response\n        const errorMessage = checkForError(responseData);\n        if (errorMessage) {\n            console.error(`[${toolName}] API Error:`, responseData);\n            throw new Error(errorMessage);\n        }\n        \n        const successMsg = typeof config.successLog === 'function' ? config.successLog(responseData) : config.successLog;\n        console.log(`[${toolName}] ${successMsg}`);\n        \n        return JSON.stringify(responseData);\n        \n    } catch (error) {\n        console.error(`[${toolName}] Error:`, error.message);\n        \n        if (error.name === 'AbortError') {\n            error.message = `Request timeout after ${timeout}ms`;\n        }\n        \n        const errorResponse = {\n            error: `Failed to execute ${action}`,\n            message: error.message,\n            action: action,\n            timestamp: new Date().toISOString()\n        };\n        \n        throw new Error(JSON.stringify(errorResponse, null, 2));\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}