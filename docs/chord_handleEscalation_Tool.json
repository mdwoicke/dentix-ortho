{
  "name": "chord_handleEscalation",
  "description": "This tool is used to update the reporting database for all call escalations. It should only be called when a call is being escalated at disconnect.\n",
  "color": "linear-gradient(rgb(8,150,221), rgb(25,40,55))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"firstName\",\"description\":\"This is the parent's first name.\",\"type\":\"string\",\"required\":true},{\"id\":1,\"property\":\"lastName\",\"description\":\"This is the paren't last name.\",\"type\":\"string\",\"required\":true},{\"id\":2,\"property\":\"DOB\",\"description\":\"This is the parent's date of birth.\",\"type\":\"string\",\"required\":true},{\"id\":3,\"property\":\"escalationIntent\",\"description\":\"This is the reason that the call had to be escalated outside of the bot.\",\"type\":\"string\",\"required\":true}]",
  "func": "/**\n * ============================================================================\n * HANDLE ESCALATION - Flowise Tool\n * ============================================================================\n * Self-contained tool with built-in error handling.\n * Calls Node-RED endpoint that handles escalation requests with patient information.\n */\n\nconst fetch = require('node-fetch');\n\n// ============================================================================\n// ðŸ“ CONFIG - Change these values for your setup\n// ============================================================================\n\nconst CONFIG = {\n    toolName: 'handleEscalation',\n\n    // Node-RED endpoint (handles escalation + API calls)\n    // TODO: Update this endpoint URL to match your Node-RED service\n    endpoint: 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord/handleEscalation',\n    method: 'POST',\n\n    // Build request body from Flowise parameters\n    buildBody: () => {\n\n        // Set default value only if c1mg_uui is null, empty, or unresolved (literal \"c1mg_uui\" string)\n        if (!$vars || !$vars.c1mg_uui || $vars.c1mg_uui === 'c1mg_uui' || (typeof $vars.c1mg_uui === 'string' && $vars.c1mg_uui.trim() === '')) {\n            if (!$vars) {\n                $vars = {};\n            }\n            $vars.c1mg_uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';\n        }\n        const body = {\n                firstName: $firstName,\n                lastName: $lastName,\n                DOB: $DOB,\n                escalationIntent: $escalationIntent,\n                uui: $vars.c1mg_uui\n        };\n\n        return body;\n    },\n\n    // Basic Authentication - Optional, only used if username and password are provided\n    getAuthHeader: () => {\n        try {\n            const username = \"workflowapi\";\n            const password = \"e^@V95&6sAJReTsb5!iq39mIC4HYIV\";\n\n            // Only create auth header if both username and password exist\n            if (username && password) {\n                const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n                return `Basic ${credentials}`;\n            }\n        } catch (e) {\n            // Variables not defined in Flowise, skip authentication\n            return null;\n        }\n        return null;\n    },\n\n    headers: {},\n    timeout: 30000,\n\n    buildSuccessMessage: (result) => {\n        // Return the full response from Node-RED\n        console.log('[handleEscalation] Full Node-RED response:', JSON.stringify(result));\n        return result;\n    },\n\n    buildErrorMessage: (error) => ({\n        error: 'Failed to handle escalation',\n        message: error.message,\n        timestamp: new Date().toISOString()\n    })\n};\n\n// ============================================================================\n// ðŸš€ HTTP REQUEST ENGINE\n// ============================================================================\n\nasync function executeRequest() {\n    console.log(`[${CONFIG.toolName}] Starting execution`);\n    console.log(`[${CONFIG.toolName}] Endpoint: ${CONFIG.method} ${CONFIG.endpoint}`);\n\n    try {\n        let url = CONFIG.endpoint;\n        let body = null;\n\n        if (CONFIG.method.toUpperCase() === 'GET' && CONFIG.buildQueryParams) {\n            const queryString = CONFIG.buildQueryParams();\n            url = `${CONFIG.endpoint}?${queryString}`;\n            console.log(`[${CONFIG.toolName}] Endpoint: ${CONFIG.method} ${url}`);\n        } else if (['POST', 'PUT', 'PATCH'].includes(CONFIG.method.toUpperCase())) {\n            body = CONFIG.buildBody ? CONFIG.buildBody() : null;\n            if (body) {\n                console.log(`[${CONFIG.toolName}] Request Body:`, JSON.stringify(body, null, 2));\n            }\n        }\n\n        const headers = {\n            'Content-Type': 'application/json',\n            ...CONFIG.headers\n        };\n\n        // Add Authorization header only if credentials are provided\n        const authHeader = CONFIG.getAuthHeader();\n        if (authHeader) {\n            headers['Authorization'] = authHeader;\n        }\n\n        const options = {\n            method: CONFIG.method.toUpperCase(),\n            headers: headers\n        };\n\n        if (body) {\n            options.body = JSON.stringify(body);\n        }\n\n        // Add timeout if AbortController is available\n        let timeoutId;\n        if (typeof AbortController !== 'undefined') {\n            const controller = new AbortController();\n            timeoutId = setTimeout(() => controller.abort(), CONFIG.timeout);\n            options.signal = controller.signal;\n        }\n\n        console.log(`[${CONFIG.toolName}] Making request...`);\n        const response = await fetch(url, options);\n\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n\n        console.log(`[${CONFIG.toolName}] Response Status: ${response.status} ${response.statusText}`);\n\n        let data;\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            data = await response.json();\n        } else {\n            data = await response.text();\n        }\n\n        if (!response.ok) {\n            console.error(`[${CONFIG.toolName}] HTTP Error ${response.status}:`, data);\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        // Check if Node-RED returned an error in the payload (even with 200 OK)\n        if (data && data.success === false) {\n            console.error(`[${CONFIG.toolName}] Node-RED Error:`, data);\n            throw new Error(data.error || 'Escalation handling failed');\n        }\n\n        console.log(`[${CONFIG.toolName}] Success - Escalation handled`);\n\n        const successResponse = CONFIG.buildSuccessMessage(data);\n        return JSON.stringify(successResponse);\n\n    } catch (error) {\n        console.error(`[${CONFIG.toolName}] Error:`, error.message);\n        console.error(`[${CONFIG.toolName}] Error Type:`, error.name);\n\n        if (error.name === 'AbortError') {\n            console.error(`[${CONFIG.toolName}] Request timed out after ${CONFIG.timeout}ms`);\n            error.message = `Request timeout after ${CONFIG.timeout}ms`;\n        }\n\n        // Build detailed error response\n        const errorResponse = CONFIG.buildErrorMessage(error);\n        const errorMessage = JSON.stringify(errorResponse, null, 2);\n\n        // THROW the error to make Flowise show RED (with structured message)\n        throw new Error(errorMessage);\n    }\n}\n\n// Execute and return the result (Flowise needs this)\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}