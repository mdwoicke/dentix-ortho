{
  "name": "chord_dso_scheduling",
  "description": "Unified appointment scheduling tool. Use action 'slots' to get available appointment times, 'grouped_slots' for booking multiple patients together (e.g., siblings), 'book_child' to create an appointment using slot data from [$selected_appointment] for yourself, or 'cancel' to cancel an existing appointment.",
  "color": "linear-gradient(rgb(187,123,6), rgb(87,134,116))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"The scheduling operation to perform. Valid values: slots, grouped_slots, book_child, cancel\",\"required\":true},{\"id\":1,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"Start date for slot search in MM/DD/YYYY format\",\"required\":false},{\"id\":2,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"End date for slot search in MM/DD/YYYY format\",\"required\":false},{\"id\":3,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"Comma-separated schedule view GUIDs to search\",\"required\":false},{\"id\":4,\"property\":\"numberOfPatients\",\"type\":\"integer\",\"description\":\"Number of patients for grouped_slots action\",\"required\":false},{\"id\":5,\"property\":\"timeWindowMinutes\",\"type\":\"integer\",\"description\":\"Time window in minutes for grouped_slots (30 for 1-2 children, 45 for 3+)\",\"required\":false},{\"id\":6,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"Patient GUID for book_child action\",\"required\":false},{\"id\":7,\"property\":\"startTime\",\"type\":\"string\",\"description\":\"Appointment start time in MM/DD/YYYY HH:MM AM format\",\"required\":false},{\"id\":8,\"property\":\"scheduleViewGUID\",\"type\":\"string\",\"description\":\"Schedule view GUID for booking\",\"required\":false},{\"id\":9,\"property\":\"scheduleColumnGUID\",\"type\":\"string\",\"description\":\"Schedule column GUID for booking\",\"required\":false},{\"id\":10,\"property\":\"appointmentTypeGUID\",\"type\":\"string\",\"description\":\"Appointment type GUID for booking\",\"required\":false},{\"id\":11,\"property\":\"minutes\",\"type\":\"integer\",\"description\":\"Appointment duration in minutes\",\"required\":false},{\"id\":12,\"property\":\"providerGUID\",\"type\":\"string\",\"description\":\"Provider GUID for booking\",\"required\":false},{\"id\":13,\"property\":\"locationGUID\",\"type\":\"string\",\"description\":\"Location GUID for booking\",\"required\":false},{\"id\":14,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"Appointment GUID for cancel action\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING - Cloud9 Direct API Integration\n * ============================================================================\n * Calls Cloud9 XML APIs directly (no Node-RED intermediary)\n *\n * Actions:\n *   - slots: Get available appointment slots (GetOnlineReservations)\n *   - grouped_slots: Get slots for siblings (GetOnlineReservations + grouping)\n *   - book_child: Create appointment (SetAppointment)\n *   - cancel: Cancel appointment (SetAppointmentStatusCanceled)\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\n// ============================================================================\n// CLOUD9 API CONFIGURATION (Sandbox)\n// ============================================================================\n\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partnertest.cloud9ortho.com/GetData.ashx',\n    clientId: 'c15aa02a-adc1-40ae-a2b5-d2e39173ae56',\n    userName: 'IntelepeerTest',\n    password: '#!InteleP33rTest!#',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    vendorUserName: 'IntelepeerTest'\n};\n\n// ============================================================================\n// XML UTILITIES\n// ============================================================================\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({\n        '<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'\n    }[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    \n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    \n    if (status === 'Error' || status !== 'Success') {\n        const errorMatch = xmlText.match(/<Result>([^<]+)<\\/Result>/);\n        if (errorMatch && (errorMatch[1].includes('Error') || errorMatch[1].includes('error'))) {\n            throw new Error(errorMatch[1]);\n        }\n    }\n    \n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\n// ============================================================================\n// DATE FORMATTING\n// ============================================================================\n\nfunction formatDateForSlots(dateStr, isStart) {\n    if (!dateStr) return null;\n    if (dateStr.includes(':')) return dateStr;\n    return isStart ? `${dateStr} 7:00:00 AM` : `${dateStr} 5:00:00 PM`;\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction cleanParams(params) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(params)) {\n        if (value !== null && value !== undefined && value !== '' &&\n            value !== 'NULL' && value !== 'null' && value !== 'None' &&\n            value !== 'none' && value !== 'N/A' && value !== 'n/a') {\n            cleaned[key] = value;\n        }\n    }\n    return cleaned;\n}\n\nfunction extractGuidFromResult(result, pattern) {\n    if (!result) return null;\n    const match = result.match(pattern);\n    return match ? match[1] : null;\n}\n\n// ============================================================================\n// GROUP SLOTS POST-PROCESSING\n// ============================================================================\n\nfunction groupConsecutiveSlots(slots, numberOfPatients, timeWindowMinutes) {\n    if (!slots || slots.length === 0) return [];\n    \n    const duration = timeWindowMinutes || (numberOfPatients >= 3 ? 45 : 30);\n    const sorted = [...slots].sort((a, b) => new Date(a.StartTime) - new Date(b.StartTime));\n    const groups = [];\n    \n    for (let i = 0; i <= sorted.length - numberOfPatients; i++) {\n        const group = [sorted[i]];\n        let lastEnd = new Date(sorted[i].StartTime);\n        lastEnd.setMinutes(lastEnd.getMinutes() + parseInt(sorted[i].Minutes || 30));\n        \n        for (let j = i + 1; j < sorted.length && group.length < numberOfPatients; j++) {\n            const nextStart = new Date(sorted[j].StartTime);\n            const gapMinutes = (nextStart - lastEnd) / 60000;\n            \n            if (gapMinutes >= 0 && gapMinutes <= 15 &&\n                sorted[j].ScheduleViewGUID === sorted[i].ScheduleViewGUID) {\n                group.push(sorted[j]);\n                lastEnd = new Date(sorted[j].StartTime);\n                lastEnd.setMinutes(lastEnd.getMinutes() + parseInt(sorted[j].Minutes || 30));\n            }\n        }\n        \n        if (group.length >= numberOfPatients) {\n            groups.push({\n                slots: group.slice(0, numberOfPatients),\n                startTime: group[0].StartTime,\n                scheduleViewGUID: group[0].ScheduleViewGUID,\n                locationGUID: group[0].LocationGUID\n            });\n        }\n    }\n    return groups;\n}\n\n// ============================================================================\n// MAIN EXECUTION\n// ============================================================================\n\nasync function executeRequest() {\n    const toolName = 'chord_scheduling';\n    const action = $action;\n    const timeout = 30000;\n    \n    console.log(`[${toolName}] Action: ${action}`);\n    \n    const validActions = ['slots', 'grouped_slots', 'book_child', 'cancel'];\n    if (!action || !validActions.includes(action)) {\n        throw new Error(`Invalid action '${action}'. Valid: ${validActions.join(', ')}`);\n    }\n    \n    const rawParams = {\n        startDate: typeof $startDate !== 'undefined' ? $startDate : null,\n        endDate: typeof $endDate !== 'undefined' ? $endDate : null,\n        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,\n        startTime: typeof $startTime !== 'undefined' ? $startTime : null,\n        scheduleViewGUID: typeof $scheduleViewGUID !== 'undefined' ? $scheduleViewGUID : null,\n        scheduleColumnGUID: typeof $scheduleColumnGUID !== 'undefined' ? $scheduleColumnGUID : null,\n        appointmentTypeGUID: typeof $appointmentTypeGUID !== 'undefined' ? $appointmentTypeGUID : null,\n        minutes: typeof $minutes !== 'undefined' ? $minutes : null,\n        providerGUID: typeof $providerGUID !== 'undefined' ? $providerGUID : null,\n        locationGUID: typeof $locationGUID !== 'undefined' ? $locationGUID : null,\n        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null\n    };\n    const params = cleanParams(rawParams);\n    \n    let procedure, apiParams;\n    \n    try {\n        switch (action) {\n            case 'slots':\n            case 'grouped_slots':\n                // TEMP: Use hardcoded Jan 2026 dates for sandbox testing\n                const testStartDate = '01/01/2026';\n                const testEndDate = '01/07/2026';\n                const testApptTypeGUID = '8fc9d063-ae46-4975-a5ae-734c6efe341a';\n                \n                if (action === 'grouped_slots' && !params.numberOfPatients) {\n                    throw new Error('numberOfPatients required for grouped_slots');\n                }\n                procedure = 'GetOnlineReservations';\n                apiParams = {\n                    startDate: formatDateForSlots(testStartDate, true),\n                    endDate: formatDateForSlots(testEndDate, false),\n                    morning: 'True',\n                    afternoon: 'True',\n                    appttypGUIDs: testApptTypeGUID\n                };\n                if (params.scheduleViewGUIDs) apiParams.schdvwGUIDs = params.scheduleViewGUIDs;\n                console.log('[chord_scheduling] Using test dates: Jan 1-7, 2026');\n                break;\n                \n            case 'book_child':\n                if (!params.patientGUID) throw new Error('patientGUID required');\n                if (!params.startTime) throw new Error('startTime required (MM/DD/YYYY HH:MM AM)');\n                if (!params.scheduleViewGUID) throw new Error('scheduleViewGUID required');\n                if (!params.scheduleColumnGUID) throw new Error('scheduleColumnGUID required');\n                if (!params.appointmentTypeGUID) throw new Error('appointmentTypeGUID required');\n                procedure = 'SetAppointment';\n                apiParams = {\n                    PatientGUID: params.patientGUID,\n                    StartTime: params.startTime,\n                    ScheduleViewGUID: params.scheduleViewGUID,\n                    ScheduleColumnGUID: params.scheduleColumnGUID,\n                    AppointmentTypeGUID: params.appointmentTypeGUID,\n                    Minutes: String(params.minutes || 30),\n                    VendorUserName: CLOUD9.vendorUserName\n                };\n                break;\n                \n            case 'cancel':\n                if (!params.appointmentGUID) throw new Error('appointmentGUID required');\n                procedure = 'SetAppointmentStatusCanceled';\n                apiParams = { apptGUID: params.appointmentGUID };\n                break;\n        }\n        \n        const xmlRequest = buildXmlRequest(procedure, apiParams);\n        console.log(`[${toolName}] Calling Cloud9: ${procedure}`);\n        console.log(`[${toolName}] Endpoint: ${CLOUD9.endpoint}`);\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 30000\n        });\n        \n        const xmlText = await response.text();\n        console.log(`[${toolName}] Response status: ${response.status}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n        \n        const parsed = parseXmlResponse(xmlText);\n        \n        let result;\n        switch (action) {\n            case 'slots':\n                result = { slots: parsed.records, count: parsed.records.length };\n                console.log(`[${toolName}] Found ${parsed.records.length} slots`);\n                break;\n                \n            case 'grouped_slots':\n                const groups = groupConsecutiveSlots(\n                    parsed.records,\n                    parseInt(params.numberOfPatients),\n                    params.timeWindowMinutes ? parseInt(params.timeWindowMinutes) : null\n                );\n                result = {\n                    groups: groups,\n                    count: groups.length,\n                    numberOfPatients: params.numberOfPatients\n                };\n                console.log(`[${toolName}] Found ${groups.length} grouped options`);\n                break;\n                \n            case 'book_child':\n                const apptResult = parsed.records[0]?.Result || '';\n                const apptGUID = extractGuidFromResult(apptResult, /Appointment GUID Added:\\s*([A-Fa-f0-9-]+)/i);\n                result = {\n                    success: apptResult.includes('Added'),\n                    appointmentGUID: apptGUID,\n                    message: apptResult\n                };\n                console.log(`[${toolName}] Appointment created: ${apptGUID}`);\n                break;\n                \n            case 'cancel':\n                const cancelResult = parsed.records[0]?.Result || 'Cancellation processed';\n                result = {\n                    success: !cancelResult.toLowerCase().includes('error'),\n                    message: cancelResult\n                };\n                console.log(`[${toolName}] Cancellation: ${cancelResult}`);\n                break;\n        }\n        \n        return JSON.stringify(result);\n        \n    } catch (error) {\n        console.error(`[${toolName}] Error:`, error.message);\n        return JSON.stringify({\n            error: `Failed to execute ${action}`,\n            message: error.message,\n            action: action,\n            timestamp: new Date().toISOString()\n        });\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}