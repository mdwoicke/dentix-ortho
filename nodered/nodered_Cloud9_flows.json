[
  {
    "id": "cloud9-ortho-tab",
    "type": "tab",
    "label": "Chord-Cloud9-Ortho-Prd",
    "disabled": false,
    "info": "Chord Cloud9 Ortho Flow v105 - Fixed cache invalidation with time/GUID normalization",
    "env": [
      {
        "name": "cloud9Endpoint",
        "value": "https://us-ea1-partner.cloud9ortho.com/GetData.ashx",
        "type": "str"
      },
      {
        "name": "cloud9ClientId",
        "value": "b42c51be-2529-4d31-92cb-50fd1a58c084",
        "type": "str"
      },
      {
        "name": "cloud9UserName",
        "value": "Intelepeer",
        "type": "str"
      },
      {
        "name": "cloud9Password",
        "value": "$#1Nt-p33R-AwS#$",
        "type": "str"
      },
      {
        "name": "cloud9Namespace",
        "value": "http://schemas.practica.ws/cloud9/partners/",
        "type": "str"
      },
      {
        "name": "vendorUserName",
        "value": "Intelepeer",
        "type": "str"
      },
      {
        "name": "defaultProviderGUID",
        "value": "0f588ace-e0bf-44ba-b8ef-be8cbb63153b",
        "type": "str"
      },
      {
        "name": "defaultLocationGUID",
        "value": "1fef9297-7c8b-426b-b0d1-f2275136e48b",
        "type": "str"
      },
      {
        "name": "bookingAuthSecret",
        "value": "CDH-Ortho-BookingAuth-2026",
        "type": "str"
      },
      {
        "name": "defaultApptTypeGUID",
        "value": "f6c20c35-9abb-47c2-981a-342996016705",
        "type": "str"
      },
      {
        "name": "defaultScheduleViewGUID",
        "value": "4c9e9333-4951-4eb0-8d97-e1ad83ef422d",
        "type": "str"
      },
      {
        "name": "defaultScheduleColumnGUID",
        "value": "3d453268-6c39-4c98-bcb9-d9512b9c1a69",
        "type": "str"
      },
      {
        "name": "testPatientGUID",
        "value": "",
        "type": "str"
      }
    ]
  },
  {
    "id": "grp-ortho-patient-lookup",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho GetPatientByFilter",
    "style": {
      "label": true,
      "fill": "#3f93cf",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-patient-lookup",
      "func-patient-lookup",
      "http-out-patient-lookup",
      "debug-patient-lookup-in",
      "debug-patient-lookup-out",
      "inject-patient-lookup",
      "inject-patient-lookup-phone"
    ],
    "x": -26,
    "y": 79,
    "w": 1292,
    "h": 162
  },
  {
    "id": "grp-ortho-get-patient",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho GetPatient",
    "style": {
      "label": true,
      "fill": "#3f93cf",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-get-patient",
      "func-get-patient",
      "http-out-get-patient",
      "debug-get-patient-in",
      "debug-get-patient-out",
      "inject-get-patient"
    ],
    "x": -46,
    "y": 279,
    "w": 1292,
    "h": 162
  },
  {
    "id": "grp-ortho-create-patient",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho CreatePatient",
    "style": {
      "label": true,
      "fill": "#0070c0",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-create-patient",
      "func-create-patient",
      "http-out-create-patient",
      "debug-create-patient-in",
      "debug-create-patient-out",
      "inject-create-patient"
    ],
    "x": -16,
    "y": 479,
    "w": 1282,
    "h": 162
  },
  {
    "id": "grp-ortho-patient-appts",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho GetPatientAppts",
    "style": {
      "label": true,
      "fill": "#c8e7a7",
      "color": "#777777"
    },
    "nodes": [
      "http-in-patient-appts",
      "func-patient-appts",
      "http-out-patient-appts",
      "debug-patient-appts-in",
      "debug-patient-appts-out",
      "inject-patient-appts"
    ],
    "x": -26,
    "y": 679,
    "w": 1292,
    "h": 162
  },
  {
    "id": "grp-ortho-get-location",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho GetLocation",
    "style": {
      "label": true,
      "fill": "#a4a4a4",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-get-location",
      "func-get-location",
      "http-out-get-location",
      "debug-get-location-in",
      "debug-get-location-out",
      "inject-get-location"
    ],
    "x": -26,
    "y": 879,
    "w": 1272,
    "h": 162
  },
  {
    "id": "grp-ortho-edit-insurance",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho EditInsurance",
    "style": {
      "label": true,
      "fill": "#b797cf",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-edit-insurance",
      "func-edit-insurance",
      "http-out-edit-insurance",
      "debug-edit-insurance-in",
      "debug-edit-insurance-out",
      "inject-edit-insurance"
    ],
    "x": -26,
    "y": 1079,
    "w": 1292,
    "h": 162
  },
  {
    "id": "grp-ortho-confirm-appt",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho ConfirmAppt",
    "style": {
      "label": true,
      "fill": "#e3f3d3",
      "color": "#777777"
    },
    "nodes": [
      "http-in-confirm-appt",
      "func-confirm-appt",
      "http-out-confirm-appt",
      "debug-confirm-appt-in",
      "debug-confirm-appt-out",
      "inject-confirm-appt"
    ],
    "x": -46,
    "y": 1279,
    "w": 1302,
    "h": 162
  },
  {
    "id": "grp-ortho-get-appt-slots",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho GetApptSlots",
    "style": {
      "label": true,
      "fill": "#addb7b",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-get-appt-slots",
      "func-get-appt-slots",
      "http-out-get-appt-slots",
      "debug-get-appt-slots-in",
      "debug-get-appt-slots-out",
      "inject-get-appt-slots"
    ],
    "x": -36,
    "y": 1479,
    "w": 1302,
    "h": 162
  },
  {
    "id": "grp-ortho-grouped-slots",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho GetGroupedApptSlots",
    "style": {
      "label": true,
      "fill": "#92d04f",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-grouped-slots",
      "func-grouped-slots",
      "http-out-grouped-slots",
      "debug-grouped-slots-in",
      "debug-grouped-slots-out",
      "inject-grouped-slots"
    ],
    "x": -16,
    "y": 1679,
    "w": 1292,
    "h": 162
  },
  {
    "id": "grp-ortho-create-appt",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho CreateAppt",
    "style": {
      "label": true,
      "fill": "#e3f3d3",
      "color": "#777777"
    },
    "nodes": [
      "http-in-create-appt",
      "func-create-appt",
      "http-out-create-appt",
      "debug-create-appt-in",
      "debug-create-appt-out",
      "inject-create-appt"
    ],
    "x": -66,
    "y": 1879,
    "w": 1312,
    "h": 162
  },
  {
    "id": "grp-ortho-cancel-appt",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho CancelAppt",
    "style": {
      "label": true,
      "fill": "#e3f3d3",
      "color": "#777777"
    },
    "nodes": [
      "http-in-cancel-appt",
      "func-cancel-appt",
      "http-out-cancel-appt",
      "debug-cancel-appt-in",
      "debug-cancel-appt-out",
      "inject-cancel-appt"
    ],
    "x": -36,
    "y": 2079,
    "w": 1282,
    "h": 162
  },
  {
    "id": "grp-ortho-retry-queue",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho Async Retry Queue",
    "style": {
      "label": true,
      "fill": "#ffd7a0",
      "color": "#777777"
    },
    "nodes": [
      "inject-retry-timer",
      "func-retry-processor",
      "debug-retry-queue",
      "http-in-queue-status",
      "func-queue-status",
      "http-out-queue-status"
    ],
    "x": -26,
    "y": 2299,
    "w": 862,
    "h": 162
  },
  {
    "id": "inject-patient-lookup",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-lookup",
    "name": "Test: Lookup by Name (CLITest)",
    "props": [
      {
        "p": "payload.filter",
        "v": "CLITest",
        "vt": "str"
      },
      {
        "p": "payload.locationGUID",
        "v": "799d413a-5e1a-46a2-b169-e2108bf517d6",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 160,
    "y": 120,
    "wires": [
      [
        "func-patient-lookup",
        "debug-patient-lookup-in"
      ]
    ]
  },
  {
    "id": "inject-patient-lookup-phone",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-lookup",
    "name": "Test: Lookup by Phone (7205559876)",
    "props": [
      {
        "p": "payload.phoneNumber",
        "v": "7205559876",
        "vt": "str"
      },
      {
        "p": "payload.locationGUID",
        "v": "799d413a-5e1a-46a2-b169-e2108bf517d6",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 190,
    "y": 160,
    "wires": [
      [
        "func-patient-lookup",
        "debug-patient-lookup-in"
      ]
    ]
  },
  {
    "id": "http-in-patient-lookup",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-lookup",
    "name": "",
    "url": "/chord/ortho-prd/getPatientByFilter",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 220,
    "y": 200,
    "wires": [
      [
        "func-patient-lookup",
        "debug-patient-lookup-in"
      ]
    ]
  },
  {
    "id": "debug-patient-lookup-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-lookup",
    "name": "Ingress PatientLookup",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 620,
    "y": 120,
    "wires": []
  },
  {
    "id": "func-patient-lookup",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-lookup",
    "name": "getPatientByFilter",
    "func": "// Ortho Patient Lookup - Uses GetPortalPatientLookup for names, GetPatientInformation for phone\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    if (status === 'Error' || status !== 'Success') {\n        const errorMatch = xmlText.match(/<Result>([^<]+)<\\/Result>/);\n        if (errorMatch && (errorMatch[1].includes('Error') || errorMatch[1].includes('error'))) {\n            throw new Error(errorMatch[1]);\n        }\n    }\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function callCloud9(procedure, params) {\n    const xmlRequest = buildXmlRequest(procedure, params);\n    const response = await fetch(CLOUD9.endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/xml' },\n        body: xmlRequest\n    });\n    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n    return parseXmlResponse(await response.text());\n}\n\nasync function lookupPatient() {\n    try {\n        const phoneNumber = msg.payload.phoneNumber;\n        const filter = msg.payload.filter;\n        const locationGUID = msg.payload.locationGUID;\n        \n        if (!phoneNumber && !filter) {\n            throw new Error('phoneNumber or filter required');\n        }\n        \n        // NAME SEARCH: Use GetPortalPatientLookup\n        if (filter && !phoneNumber) {\n            node.warn('Name search using GetPortalPatientLookup: ' + filter);\n            const parsed = await callCloud9('GetPortalPatientLookup', { filter: filter, lookupByPatient: '1', pageIndex: '1', pageSize: '25' });\n            const patients = parsed.records.map(p => {\n                const firstName = p.PatientFirstName || '';\n                const lastName = p.PatientLastName || '';\n                const fullName = firstName && lastName ? `${firstName} ${lastName}` : (firstName || lastName || '');\n                return {\n                    patientGUID: p.PatientGUID || p.patGUID,\n                    PatientFirstName: firstName,\n                    PatientLastName: lastName,\n                    PatientName: fullName,\n                    patientName: fullName,\n                    PatientID: p.PatientID,\n                    PatientBirthDate: p.PatientBirthDate || p.PatientBirthdate || '',\n                    birthDate: p.PatientBirthDate || p.PatientBirthdate || '',\n                    LocationGUID: p.LocationGUID,\n                    LocationName: p.LocationName\n                };\n            });\n            msg.payload = { patients, count: patients.length };\n            return msg;\n        }\n        \n        // PHONE SEARCH: Get patient list, then get contact info for each in parallel batches\n        if (phoneNumber) {\n            const searchPhone = phoneNumber.replace(/\\D/g, '');\n            node.warn('Phone search: ' + searchPhone + ' - Getting patient list first');\n            \n            const apiParams = {};\n            if (locationGUID) apiParams.LocGUIDs = locationGUID;\n            const listResult = await callCloud9('GetPatientList', apiParams);\n            \n            node.warn('Found ' + listResult.records.length + ' patients, checking phone numbers...');\n            \n            // Process in parallel batches for better performance\n            const matches = [];\n            const batchSize = 10; // Concurrent requests per batch\n            const maxToCheck = Math.min(listResult.records.length, 200); // Increased limit for better coverage\n            \n            for (let batchStart = 0; batchStart < maxToCheck; batchStart += batchSize) {\n                const batchEnd = Math.min(batchStart + batchSize, maxToCheck);\n                const batch = listResult.records.slice(batchStart, batchEnd);\n                \n                // Process batch in parallel\n                const batchPromises = batch.map(async (patient) => {\n                    const patGUID = patient.PatientGUID || patient.patGUID;\n                    if (!patGUID) return null;\n                    \n                    try {\n                        const infoResult = await callCloud9('GetPatientInformation', { patguid: patGUID });\n                        if (infoResult.records.length > 0) {\n                            const info = infoResult.records[0];\n                            const phones = [\n                                info.HomePhone, info.CellPhone, info.WorkPhone,\n                                info.Phone, info.PhoneNumber, info.MobilePhone\n                            ].filter(Boolean).map(p => p.replace(/\\D/g, ''));\n                            \n                            if (phones.some(p => p.includes(searchPhone) || searchPhone.includes(p.slice(-10)))) {\n                                return {\n                                    ...patient,\n                                    patientGUID: patGUID,\n                                    HomePhone: info.HomePhone,\n                                    CellPhone: info.CellPhone,\n                                    WorkPhone: info.WorkPhone,\n                                    Email: info.Email\n                                };\n                            }\n                        }\n                    } catch (e) { /* skip on error */ }\n                    return null;\n                });\n                \n                const batchResults = await Promise.all(batchPromises);\n                matches.push(...batchResults.filter(Boolean));\n                \n                // Stop early if we found matches (optimization for exact phone matches)\n                if (matches.length > 0 && searchPhone.length >= 10) break;\n            }\n            \n            node.warn('Phone search complete. Found ' + matches.length + ' matches (checked ' + maxToCheck + ' patients)');\n            msg.payload = { patients: matches, count: matches.length, searchedCount: maxToCheck, totalPatients: listResult.records.length };\n            return msg;\n        }\n        \n        msg.payload = { patients: [], count: 0 };\n        return msg;\n    } catch (error) {\n        node.error('Patient lookup error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to lookup patient', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn lookupPatient();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 810,
    "y": 200,
    "wires": [
      [
        "http-out-patient-lookup",
        "debug-patient-lookup-out"
      ]
    ]
  },
  {
    "id": "debug-patient-lookup-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-lookup",
    "name": "Egress PatientLookup",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1120,
    "y": 120,
    "wires": []
  },
  {
    "id": "http-out-patient-lookup",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-lookup",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 200,
    "wires": []
  },
  {
    "id": "inject-get-patient",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-patient",
    "name": "Test: Get Patient (PhoneTest User)",
    "props": [
      {
        "p": "payload.patientGUID",
        "v": "64DA8F5C-7E54-4659-8AE1-7BB6A033D2A5",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 140,
    "y": 320,
    "wires": [
      [
        "func-get-patient",
        "debug-get-patient-in"
      ]
    ]
  },
  {
    "id": "http-in-get-patient",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-patient",
    "name": "",
    "url": "/chord/ortho-prd/getPatient",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 190,
    "y": 400,
    "wires": [
      [
        "func-get-patient",
        "debug-get-patient-in"
      ]
    ]
  },
  {
    "id": "debug-get-patient-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-patient",
    "name": "Ingress GetPatient",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 610,
    "y": 320,
    "wires": []
  },
  {
    "id": "func-get-patient",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-patient",
    "name": "getPatient",
    "func": "// Ortho Get Patient - Calls Cloud9 GetPatientInformation\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function getPatient() {\n    try {\n        const patientGUID = msg.payload.patientGUID;\n        if (!patientGUID) throw new Error('patientGUID required');\n        \n        const xmlRequest = buildXmlRequest('GetPatientInformation', { patguid: patientGUID });\n        node.warn('Calling Cloud9 GetPatientInformation');\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 45000\n        });\n        \n        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        \n        msg.payload = { patient: parsed.records[0] || null };\n        return msg;\n    } catch (error) {\n        node.error('Get patient error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to get patient', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn getPatient();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 790,
    "y": 400,
    "wires": [
      [
        "http-out-get-patient",
        "debug-get-patient-out"
      ]
    ]
  },
  {
    "id": "debug-get-patient-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-patient",
    "name": "Egress GetPatient",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1110,
    "y": 320,
    "wires": []
  },
  {
    "id": "http-out-get-patient",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-patient",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 400,
    "wires": []
  },
  {
    "id": "inject-create-patient",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-patient",
    "name": "Test: Create Patient",
    "props": [
      {
        "p": "payload.patientFirstName",
        "v": "TestJohn",
        "vt": "str"
      },
      {
        "p": "payload.patientLastName",
        "v": "TestDoe",
        "vt": "str"
      },
      {
        "p": "payload.birthdayDateTime",
        "v": "01/15/2010",
        "vt": "str"
      },
      {
        "p": "payload.phoneNumber",
        "v": "3035551234",
        "vt": "str"
      },
      {
        "p": "payload.emailAddress",
        "v": "testjohn@example.com",
        "vt": "str"
      },
      {
        "p": "payload.gender",
        "v": "M",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 150,
    "y": 520,
    "wires": [
      [
        "func-create-patient",
        "debug-create-patient-in"
      ]
    ]
  },
  {
    "id": "http-in-create-patient",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-patient",
    "name": "",
    "url": "/chord/ortho-prd/createPatient",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 210,
    "y": 600,
    "wires": [
      [
        "func-create-patient",
        "debug-create-patient-in"
      ]
    ]
  },
  {
    "id": "debug-create-patient-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-patient",
    "name": "Ingress CreatePatient",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 620,
    "y": 520,
    "wires": []
  },
  {
    "id": "func-create-patient",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-patient",
    "name": "createPatient",
    "func": "// Ortho Create Patient v67 - INDIVIDUAL_PATIENT_PER_PERSON model\n// v67: Added async queue fallback when all sync retries fail\n// v66: Added SetPatient rate limit spacing + retry (mirrors createAppt pattern)\n// v65: Supports parent + child creation with familyId linkage\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace'),\n    vendorUserName: env.get('vendorUserName'),\n    defaultProviderGUID: env.get('defaultProviderGUID'),\n    defaultLocationGUID: env.get('defaultLocationGUID')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nfunction formatBirthdayForCloud9(dateStr) {\n    if (!dateStr) return null;\n    const parts = dateStr.split('/');\n    if (parts.length !== 3) return dateStr;\n    return `${parts[2]}-${parts[0].padStart(2,'0')}-${parts[1].padStart(2,'0')}T00:00:00`;\n}\n\nfunction extractGuidFromResult(result, pattern) {\n    if (!result) return null;\n    const match = result.match(pattern);\n    return match ? match[1] : null;\n}\n\nfunction generateUUID() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0;\n        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    });\n}\n\n// v66: Rate limit spacing for SetPatient (same pattern as SetAppointment)\nconst SETPATIENT_SPACING_MS = 5000;  // 5s minimum between SetPatient calls\nconst SETPATIENT_RETRY_CONFIG = { maxRetries: 3, retryDelayMs: 5000 };\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nfunction generateBookingAuthToken(patientGUID, sessionId) {\n    const BOOKING_SECRET = env.get('bookingAuthSecret') || 'CDH-Ortho-BookingAuth-2026';\n    const bookingAuth = {\n        sessionId: sessionId,\n        patientGUID: patientGUID,\n        createdAt: Date.now(),\n        expiresAt: Date.now() + (15 * 60 * 1000),\n        nonce: Math.random().toString(16).slice(2, 14)\n    };\n    const payload = Buffer.from(JSON.stringify(bookingAuth)).toString('base64url');\n    const signature = crypto.createHmac('sha256', BOOKING_SECRET).update(payload).digest('base64url');\n    return payload + '.' + signature;\n}\n\nasync function createPatient() {\n    const params = msg.payload;\n    const isChild = params.isChild === true || params.isChild === 'true';\n\n    // v65: Skip session cache for child creation - children are always new patients\n    if (!isChild) {\n        // Session-based deduplication for PARENT only\n        const sessionId = params.phoneNumber || params.uui || msg._msgid || 'unknown';\n        const bookingSessions = flow.get('bookingSessions') || {};\n        const cachedSession = bookingSessions[sessionId];\n\n        if (cachedSession && cachedSession.patientGUID && cachedSession.bookingAuthToken) {\n            let tokenStillValid = false;\n            try {\n                const tokenParts = cachedSession.bookingAuthToken.split('.');\n                if (tokenParts.length === 2) {\n                    const tokenData = JSON.parse(Buffer.from(tokenParts[0], 'base64url').toString());\n                    tokenStillValid = Date.now() < tokenData.expiresAt;\n                    if (!tokenStillValid) {\n                        node.warn('[v65] Session cache: token EXPIRED, will create fresh patient');\n                        const sessions = flow.get('bookingSessions') || {};\n                        delete sessions[sessionId];\n                        if (cachedSession.patientGUID) delete sessions[cachedSession.patientGUID];\n                        flow.set('bookingSessions', sessions);\n                    }\n                }\n            } catch (e) {\n                node.warn('[v65] Session cache: token parse error (' + e.message + ')');\n            }\n            \n            if (tokenStillValid) {\n                node.warn('[v65] Session cache HIT: returning cached parent ' + cachedSession.patientGUID.substring(0, 8) + '...');\n                msg.payload = {\n                    success: true,\n                    patientGUID: cachedSession.patientGUID,\n                    familyId: cachedSession.familyId || generateUUID(),\n                    bookingAuthToken: cachedSession.bookingAuthToken,\n                    isChild: false,\n                    message: 'Patient already created for this session (cached)',\n                    _cached: true,\n                    llm_guidance: {\n                        model: 'INDIVIDUAL_PATIENT_PER_PERSON',\n                        current_state: 'PARENT_CREATED',\n                        next_action: 'create_child_patient_for_each_child',\n                        critical_instruction: 'Parent exists. Now call create with isChild=true for each child using this familyId.',\n                        IMPORTANT: 'Do NOT call create for parent again. Create each CHILD as a separate patient.'\n                    }\n                };\n                return msg;\n            }\n        }\n    }\n\n    try {\n        if (!params.patientFirstName) throw new Error('patientFirstName required');\n        if (!params.patientLastName) throw new Error('patientLastName required');\n        \n        // v65: Validate child-specific required fields\n        if (isChild) {\n            if (!params.parentPatientGUID) throw new Error('parentPatientGUID required for child creation (isChild=true)');\n            if (!params.familyId) throw new Error('familyId required for child creation (isChild=true)');\n            node.warn('[v65] Creating CHILD patient: ' + params.patientFirstName + ' ' + params.patientLastName + ' (parent: ' + params.parentPatientGUID.substring(0,8) + '...)');\n        } else {\n            node.warn('[v65] Creating PARENT patient: ' + params.patientFirstName + ' ' + params.patientLastName);\n        }\n        \n        const providerGUID = params.providerGUID || CLOUD9.defaultProviderGUID;\n        \n        let locationGUID = CLOUD9.defaultLocationGUID;\n        if (params.locationGUID && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(params.locationGUID)) {\n            locationGUID = params.locationGUID;\n        } else if (params.locationGUID) {\n            node.warn('[v65] Invalid locationGUID format, using default: ' + CLOUD9.defaultLocationGUID);\n        }\n        \n        node.warn('[v65] Using providerGUID: ' + providerGUID);\n        node.warn('[v65] Using locationGUID: ' + locationGUID);\n        \n        const apiParams = {\n            patientFirstName: params.patientFirstName,\n            patientLastName: params.patientLastName,\n            providerGUID: providerGUID,\n            locationGUID: locationGUID,\n            VendorUserName: CLOUD9.vendorUserName\n        };\n        \n        // v65: Accept both birthdayDateTime and birthDate field names\n        // Pass through as MM/DD/YYYY - Cloud9 expects this format (NOT ISO)\n        const dobField = params.birthdayDateTime || params.birthDate;\n        if (dobField) apiParams.birthdayDateTime = dobField;\n        // v65: Only add phone/email for parent (children don't have their own)\n        if (!isChild) {\n            if (params.phoneNumber) apiParams.phoneNumber = params.phoneNumber;\n            if (params.emailAddress) apiParams.email = params.emailAddress;\n        }\n        if (params.gender) apiParams.gender = params.gender;\n        \n        const xmlRequest = buildXmlRequest('SetPatient', apiParams);\n        \n        // v66: Rate limit spacing - wait if recent SetPatient call was made\n        const lastSetPatientTime = flow.get('lastSetPatientTime') || 0;\n        const elapsed = Date.now() - lastSetPatientTime;\n        let spacingWaitMs = 0;\n        if (elapsed < SETPATIENT_SPACING_MS && lastSetPatientTime > 0) {\n            spacingWaitMs = SETPATIENT_SPACING_MS - elapsed;\n            node.warn('[v66] SetPatient spacing: waiting ' + spacingWaitMs + 'ms (last call ' + elapsed + 'ms ago)');\n            await delay(spacingWaitMs);\n        }\n        \n        // v66: Retry loop for SetPatient rate limiting\n        let attempt = 0;\n        let xmlText = '';\n        let parsed = null;\n        let createResult = '';\n        let patientGUID = null;\n        let patientCreated = false;\n        \n        while (attempt < SETPATIENT_RETRY_CONFIG.maxRetries) {\n            attempt++;\n            if (attempt > 1) {\n                node.warn('[v66] SetPatient retry ' + attempt + '/' + SETPATIENT_RETRY_CONFIG.maxRetries + ': waiting ' + SETPATIENT_RETRY_CONFIG.retryDelayMs + 'ms');\n                await delay(SETPATIENT_RETRY_CONFIG.retryDelayMs);\n            }\n            \n            node.warn('[v66] Calling Cloud9 SetPatient for ' + (isChild ? 'CHILD' : 'PARENT') + ' (attempt ' + attempt + ')');\n            \n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xmlRequest,\n                timeout: 45000\n            });\n            \n            if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);\n            xmlText = await response.text();\n            node.warn('[v66] Cloud9 raw response (attempt ' + attempt + '): ' + xmlText.substring(0, 300));\n            parsed = parseXmlResponse(xmlText);\n            \n            createResult = parsed.records[0]?.Result || '';\n            patientGUID = extractGuidFromResult(createResult, /Patient Added:\\s*([A-Fa-f0-9-]+)/i);\n            patientCreated = createResult.includes('Added');\n            \n            // v66: If patient was created, break out of retry loop\n            if (patientCreated) {\n                node.warn('[v66] SetPatient succeeded on attempt ' + attempt);\n                break;\n            }\n            \n            // v66: Check for rate limit (empty result = Cloud9 silent rate limit)\n            const isRateLimited = !createResult && parsed.status !== 'Success';\n            if (isRateLimited && attempt < SETPATIENT_RETRY_CONFIG.maxRetries) {\n                node.warn('[v66] SetPatient empty result (likely rate limited) on attempt ' + attempt + ', will retry');\n                continue;\n            }\n            \n            // Non-rate-limit error or final attempt - break\n            break;\n        }\n        \n        // v66: Update last SetPatient time\n        flow.set('lastSetPatientTime', Date.now());\n        \n        node.warn('[v66] SetPatient final result: ' + createResult + ' (attempts: ' + attempt + ', spacing: ' + spacingWaitMs + 'ms)');\n        node.warn('[v66] Patient created: ' + patientCreated + ', GUID: ' + patientGUID);\n\n        // v67: Async queue fallback - queue for background retry if all sync attempts failed\n        if (!patientCreated) {\n            const sessionId = params.phoneNumber || params.uui || msg._msgid || 'unknown';\n            const operationId = 'op-pat-' + Date.now() + '-' + Math.random().toString(36).slice(2,8);\n            const pendingOps = flow.get('pendingOperations') || {};\n            pendingOps[operationId] = {\n                operationType: 'SetPatient',\n                requestPayload: {\n                    xmlBody: xmlRequest,\n                    apiParams: apiParams,\n                    isChild: isChild,\n                    parentPatientGUID: params.parentPatientGUID || null,\n                    familyId: isChild ? params.familyId : generateUUID(),\n                    sessionId: sessionId,\n                    patientFirstName: params.patientFirstName,\n                    patientLastName: params.patientLastName,\n                    phoneNumber: params.phoneNumber\n                },\n                attemptCount: 0,\n                maxAttempts: 10,\n                nextRetryAt: new Date().toISOString(),\n                status: 'pending',\n                createdAt: new Date().toISOString()\n            };\n            flow.set('pendingOperations', pendingOps);\n            node.warn('[v67] All sync retries failed. Queued SetPatient as ' + operationId);\n\n            msg.payload = {\n                success: false,\n                queued: true,\n                operationId: operationId,\n                isChild: isChild,\n                familyId: isChild ? params.familyId : pendingOps[operationId].requestPayload.familyId,\n                parentPatientGUID: params.parentPatientGUID || null,\n                message: 'Patient creation queued for background processing',\n                llm_guidance: {\n                    current_state: 'PATIENT_CREATION_QUEUED',\n                    next_action: 'INFORM_CALLER_QUEUED',\n                    message_to_caller: 'We are setting up the patient record. This will be ready shortly.',\n                    can_proceed_to_booking: false,\n                    check_status_endpoint: '/checkOperationStatus',\n                    operationId: operationId\n                }\n            };\n            return msg;\n        }\n\n        // v65: Generate familyId for parent, or pass through for child\n        let familyId;\n        if (isChild) {\n            familyId = params.familyId;\n        } else {\n            familyId = generateUUID();\n            node.warn('[v65] Generated familyId for parent: ' + familyId);\n        }\n        \n        // Generate booking authorization token\n        let bookingAuthToken = null;\n        if (patientCreated && patientGUID) {\n            const sid = params.uui || msg._msgid || 'unknown';\n            bookingAuthToken = generateBookingAuthToken(patientGUID, sid);\n\n            // Session cache: only cache parent (children are unique per call)\n            if (!isChild) {\n                const cacheKeyPhone = params.phoneNumber || 'unknown';\n                const sessions = flow.get('bookingSessions') || {};\n                const cacheData = {\n                    patientGUID: patientGUID,\n                    familyId: familyId,\n                    bookingAuthToken: bookingAuthToken,\n                    phoneNumber: params.phoneNumber,\n                    createdAt: new Date().toISOString(),\n                    patientName: params.patientFirstName + ' ' + params.patientLastName\n                };\n                sessions[cacheKeyPhone] = cacheData;\n                sessions[patientGUID] = cacheData;\n                sessions[sid] = {\n                    patientGUID: patientGUID,\n                    familyId: familyId,\n                    bookingAuthToken: bookingAuthToken,\n                    createdAt: Date.now(),\n                    expiresAt: Date.now() + (15 * 60 * 1000)\n                };\n                flow.set('bookingSessions', sessions);\n                node.warn('[v65] Session cache: stored parent under phone=' + cacheKeyPhone + ' and GUID=' + patientGUID.substring(0,8) + '...');\n            }\n        }\n        \n        // v65: Build response based on parent vs child\n        if (isChild) {\n            const llmGuidance = {\n                model: 'INDIVIDUAL_PATIENT_PER_PERSON',\n                current_state: patientCreated ? 'CHILD_CREATED' : 'CHILD_CREATE_FAILED',\n                next_action: patientCreated ? 'book_appointment_for_this_child' : 'retry_or_transfer',\n                critical_instruction: patientCreated\n                    ? 'Child patient created with their OWN patientGUID. Book appointment using THIS child patientGUID (not parent).'\n                    : 'Child patient creation failed. Check error and retry or transfer to agent.',\n                childPatientGUID: patientGUID,\n                parentPatientGUID: params.parentPatientGUID,\n                familyId: familyId,\n                MUST_INCLUDE_IN_BOOK_CHILD: patientCreated ? { patientGUID: patientGUID, bookingAuthToken: bookingAuthToken } : null\n            };\n            \n            msg.payload = {\n                success: patientCreated,\n                patientGUID: patientGUID,\n                familyId: familyId,\n                parentPatientGUID: params.parentPatientGUID,\n                isChild: true,\n                bookingAuthToken: bookingAuthToken,\n                message: createResult,\n                llm_guidance: llmGuidance\n            };\n            node.warn('[v65] Child patient result: success=' + patientCreated + ' GUID=' + patientGUID);\n        } else {\n            const llmGuidance = {\n                model: 'INDIVIDUAL_PATIENT_PER_PERSON',\n                current_state: patientCreated ? 'PARENT_CREATED' : 'PATIENT_CREATE_FAILED',\n                next_action: patientCreated ? 'create_child_patient_for_each_child' : 'transfer_to_agent',\n                critical_instruction: patientCreated\n                    ? 'Parent created. Now call create with isChild=true, parentPatientGUID, and familyId for EACH child.'\n                    : 'Patient creation failed. Transfer to live agent.',\n                patientGUID_for_booking: patientGUID,\n                familyId: familyId,\n                bookingAuthToken_for_booking: bookingAuthToken,\n                MUST_INCLUDE_IN_CHILD_CREATE: patientCreated ? { parentPatientGUID: patientGUID, familyId: familyId } : null,\n                booking_sequence: 'Create parent -> Create each child (isChild=true) -> Book each child with their own GUID'\n            };\n            \n            msg.payload = {\n                success: patientCreated,\n                patientGUID: patientGUID,\n                familyId: familyId,\n                isChild: false,\n                bookingAuthToken: bookingAuthToken,\n                message: createResult,\n                llm_guidance: llmGuidance\n            };\n            node.warn('[v65] Parent patient result: success=' + patientCreated + ' GUID=' + patientGUID + ' familyId=' + familyId);\n        }\n        \n        return msg;\n    } catch (error) {\n        node.error('[v65] Create patient error: ' + error.message, msg);\n        msg.payload = {\n            success: false,\n            patientGUID: null,\n            isChild: isChild,\n            error: 'Failed to create patient',\n            message: error.message,\n            current_state: isChild ? 'CHILD_CREATE_FAILED' : 'PATIENT_CREATE_FAILED',\n            timestamp: new Date().toISOString()\n        };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn createPatient();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      },
      {
        "var": "crypto",
        "module": "crypto"
      }
    ],
    "x": 800,
    "y": 600,
    "wires": [
      [
        "http-out-create-patient",
        "debug-create-patient-out"
      ]
    ]
  },
  {
    "id": "debug-create-patient-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-patient",
    "name": "Egress CreatePatient",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1120,
    "y": 520,
    "wires": []
  },
  {
    "id": "http-out-create-patient",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-patient",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 600,
    "wires": []
  },
  {
    "id": "inject-patient-appts",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-appts",
    "name": "Test: Get Patient Appts (PhoneTest)",
    "props": [
      {
        "p": "payload.patientGUID",
        "v": "64DA8F5C-7E54-4659-8AE1-7BB6A033D2A5",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 160,
    "y": 720,
    "wires": [
      [
        "func-patient-appts",
        "debug-patient-appts-in"
      ]
    ]
  },
  {
    "id": "http-in-patient-appts",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-appts",
    "name": "",
    "url": "/chord/ortho-prd/getPatientAppts",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 220,
    "y": 800,
    "wires": [
      [
        "func-patient-appts",
        "debug-patient-appts-in"
      ]
    ]
  },
  {
    "id": "debug-patient-appts-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-appts",
    "name": "Ingress PatientAppts",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 630,
    "y": 720,
    "wires": []
  },
  {
    "id": "func-patient-appts",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-appts",
    "name": "getPatientAppts",
    "func": "// Ortho Get Patient Appointments - Calls Cloud9 GetAppointmentListByPatient\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function getPatientAppts() {\n    try {\n        const patientGUID = msg.payload.patientGUID;\n        if (!patientGUID) throw new Error('patientGUID required');\n        \n        const xmlRequest = buildXmlRequest('GetAppointmentListByPatient', { patGUID: patientGUID });\n        node.warn('Calling Cloud9 GetAppointmentListByPatient');\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 45000\n        });\n        \n        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        \n        const appointments = parsed.records.map(a => ({\n            ...a,\n            // Map to frontend-expected field names\n            StartTime: a.AppointmentDateTime,\n            AppointmentDate: a.AppointmentDateTime,\n            AppointmentType: a.AppointmentTypeDescription,\n            Status: a.AppointmentStatusDescription,\n            GUID: a.AppointmentGUID,\n            patientName: `${a.PatientFirstName || ''} ${a.PatientLastName || ''}`.trim()\n        }));\n        msg.payload = { appointments, count: appointments.length };\n        return msg;\n    } catch (error) {\n        node.error('Get patient appts error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to get patient appointments', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn getPatientAppts();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 810,
    "y": 800,
    "wires": [
      [
        "http-out-patient-appts",
        "debug-patient-appts-out"
      ]
    ]
  },
  {
    "id": "debug-patient-appts-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-appts",
    "name": "Egress PatientAppts",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1120,
    "y": 720,
    "wires": []
  },
  {
    "id": "http-out-patient-appts",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-patient-appts",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 800,
    "wires": []
  },
  {
    "id": "inject-get-location",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-location",
    "name": "Test: Get Locations",
    "props": [
      {
        "p": "payload.locationGUID",
        "v": "799d413a-5e1a-46a2-b169-e2108bf517d6",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 150,
    "y": 920,
    "wires": [
      [
        "func-get-location",
        "debug-get-location-in"
      ]
    ]
  },
  {
    "id": "http-in-get-location",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-location",
    "name": "",
    "url": "/chord/ortho-prd/getLocation",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 200,
    "y": 1000,
    "wires": [
      [
        "func-get-location",
        "debug-get-location-in"
      ]
    ]
  },
  {
    "id": "debug-get-location-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-location",
    "name": "Ingress GetLocation",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 620,
    "y": 920,
    "wires": []
  },
  {
    "id": "func-get-location",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-location",
    "name": "getLocation",
    "func": "// Ortho Get Location - Calls Cloud9 GetLocations\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function getLocation() {\n    try {\n        const locationGUID = msg.payload.locationGUID;\n        \n        const xmlRequest = buildXmlRequest('GetLocations', {});\n        node.warn('Calling Cloud9 GetLocations');\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 45000\n        });\n        \n        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        \n        const locations = parsed.records;\n        let result;\n        \n        if (locationGUID) {\n            const match = locations.find(l => l.LocationGUID && l.LocationGUID.toLowerCase() === locationGUID.toLowerCase());\n            if (match) {\n                result = { success: true, location: match, matchType: 'guid' };\n            }\n        }\n        \n        if (!result) {\n            result = { success: true, locations: locations, count: locations.length, location: locations[0] || null };\n        }\n        \n        msg.payload = result;\n        return msg;\n    } catch (error) {\n        node.error('Get location error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to get location', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn getLocation();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 800,
    "y": 1000,
    "wires": [
      [
        "http-out-get-location",
        "debug-get-location-out"
      ]
    ]
  },
  {
    "id": "debug-get-location-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-location",
    "name": "Egress GetLocation",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1110,
    "y": 920,
    "wires": []
  },
  {
    "id": "http-out-get-location",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-location",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 1000,
    "wires": []
  },
  {
    "id": "inject-edit-insurance",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-edit-insurance",
    "name": "Test: Edit Insurance (PhoneTest)",
    "props": [
      {
        "p": "payload.patientGUID",
        "v": "64DA8F5C-7E54-4659-8AE1-7BB6A033D2A5",
        "vt": "str"
      },
      {
        "p": "payload.insuranceProvider",
        "v": "Blue Cross Blue Shield",
        "vt": "str"
      },
      {
        "p": "payload.insuranceGroupId",
        "v": "GRP12345",
        "vt": "str"
      },
      {
        "p": "payload.insuranceMemberId",
        "v": "MEM67890",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 150,
    "y": 1120,
    "wires": [
      [
        "func-edit-insurance",
        "debug-edit-insurance-in"
      ]
    ]
  },
  {
    "id": "http-in-edit-insurance",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-edit-insurance",
    "name": "",
    "url": "/chord/ortho-prd/editInsurance",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 210,
    "y": 1200,
    "wires": [
      [
        "func-edit-insurance",
        "debug-edit-insurance-in"
      ]
    ]
  },
  {
    "id": "debug-edit-insurance-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-edit-insurance",
    "name": "Ingress EditInsurance",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 630,
    "y": 1120,
    "wires": []
  },
  {
    "id": "func-edit-insurance",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-edit-insurance",
    "name": "editInsurance",
    "func": "// Ortho Edit Insurance - Calls Cloud9 SetPatientComment\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function editInsurance() {\n    try {\n        const params = msg.payload;\n        if (!params.patientGUID) throw new Error('patientGUID required');\n        \n        const insuranceNote = `=== Insurance Information ==\\nProvider: ${params.insuranceProvider || 'N/A'}\\nGroup ID: ${params.insuranceGroupId || 'N/A'}\\nMember ID: ${params.insuranceMemberId || 'N/A'}\\nUpdated: ${new Date().toISOString()}`;\n        \n        const xmlRequest = buildXmlRequest('SetPatientComment', { \n            patGUID: params.patientGUID, \n            patComment: insuranceNote \n        });\n        node.warn('Calling Cloud9 SetPatientComment');\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 45000\n        });\n        \n        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        \n        const updateResult = parsed.records[0]?.Result || 'Insurance info saved';\n        msg.payload = { success: !updateResult.toLowerCase().includes('error'), message: updateResult };\n        return msg;\n    } catch (error) {\n        node.error('Edit insurance error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to edit insurance', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn editInsurance();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 800,
    "y": 1200,
    "wires": [
      [
        "http-out-edit-insurance",
        "debug-edit-insurance-out"
      ]
    ]
  },
  {
    "id": "debug-edit-insurance-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-edit-insurance",
    "name": "Egress EditInsurance",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1120,
    "y": 1120,
    "wires": []
  },
  {
    "id": "http-out-edit-insurance",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-edit-insurance",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 1200,
    "wires": []
  },
  {
    "id": "inject-confirm-appt",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-confirm-appt",
    "name": "Test: Confirm Appt (needs real GUID)",
    "props": [
      {
        "p": "payload.appointmentId",
        "v": "GET_FROM_CREATE_APPT_RESPONSE",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 150,
    "y": 1320,
    "wires": [
      [
        "func-confirm-appt",
        "debug-confirm-appt-in"
      ]
    ]
  },
  {
    "id": "http-in-confirm-appt",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-confirm-appt",
    "name": "",
    "url": "/chord/ortho-prd/confirmAppt",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 200,
    "y": 1400,
    "wires": [
      [
        "func-confirm-appt",
        "debug-confirm-appt-in"
      ]
    ]
  },
  {
    "id": "debug-confirm-appt-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-confirm-appt",
    "name": "Ingress ConfirmAppt",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 620,
    "y": 1320,
    "wires": []
  },
  {
    "id": "func-confirm-appt",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-confirm-appt",
    "name": "confirmAppt",
    "func": "// Ortho Confirm Appointment - Calls Cloud9 SetAppointmentStatusConfirmed\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function confirmAppt() {\n    try {\n        const appointmentId = msg.payload.appointmentId;\n        if (!appointmentId) throw new Error('appointmentId required');\n        \n        const xmlRequest = buildXmlRequest('SetAppointmentStatusConfirmed', { apptGUID: appointmentId });\n        node.warn('Calling Cloud9 SetAppointmentStatusConfirmed');\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 45000\n        });\n        \n        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        \n        const confirmResult = parsed.records[0]?.Result || 'Appointment confirmed';\n        msg.payload = { success: !confirmResult.toLowerCase().includes('error'), message: confirmResult };\n        return msg;\n    } catch (error) {\n        node.error('Confirm appt error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to confirm appointment', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn confirmAppt();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 800,
    "y": 1400,
    "wires": [
      [
        "http-out-confirm-appt",
        "debug-confirm-appt-out"
      ]
    ]
  },
  {
    "id": "debug-confirm-appt-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-confirm-appt",
    "name": "Egress ConfirmAppt",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1110,
    "y": 1320,
    "wires": []
  },
  {
    "id": "http-out-confirm-appt",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-confirm-appt",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 1400,
    "wires": []
  },
  {
    "id": "inject-get-appt-slots",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-appt-slots",
    "name": "Test: Get Appt Slots (Next 14 Days)",
    "props": [
      {
        "p": "payload.startDate",
        "v": "",
        "vt": "str"
      },
      {
        "p": "payload.endDate",
        "v": "",
        "vt": "str"
      },
      {
        "p": "payload.scheduleViewGUIDs",
        "v": "defaultScheduleViewGUID",
        "vt": "env"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 150,
    "y": 1520,
    "wires": [
      [
        "func-get-appt-slots",
        "debug-get-appt-slots-in"
      ]
    ]
  },
  {
    "id": "http-in-get-appt-slots",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-appt-slots",
    "name": "",
    "url": "/chord/ortho-prd/getApptSlots",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 210,
    "y": 1600,
    "wires": [
      [
        "func-get-appt-slots",
        "debug-get-appt-slots-in"
      ]
    ]
  },
  {
    "id": "debug-get-appt-slots-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-appt-slots",
    "name": "Ingress GetApptSlots",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 630,
    "y": 1520,
    "wires": []
  },
  {
    "id": "func-get-appt-slots",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-appt-slots",
    "name": "getApptSlots v10 (Chair 8)",
    "func": "// Ortho Get Appointment Slots - Calls Cloud9 GetOnlineReservations with retry logic\n// v8: Added retry with 5s delay for Cloud9 API rate limiting\n// v7: Added Chair 8 filter - only return slots available on Chair 8\n// v6: Removed appttypGUIDs filter - was excluding target location slots\n// v5: Changed to 30-day windows (2 max) - finds slots in single call\n// v4: Added 3s delay between sliding windows to avoid Cloud9 rate limiting\n// v3: Fixed Cloud9 API limitation - returns 0 slots for ranges > 14 days. Now uses sliding windows.\n\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace'),\n    defaultApptTypeGUID: env.get('defaultApptTypeGUID'),\n    defaultLocationGUID: env.get('defaultLocationGUID')\n};\n\n// Chair 8 filter - only return slots available on Chair 8 for test bookings\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\n// v8: Retry configuration for Cloud9 rate limiting\nconst RETRY_CONFIG = {\n    maxRetries: 3,              // Maximum retry attempts per API call\n    retryDelayMs: 5000,         // 5 seconds between retries\n    retryOnZeroResults: true    // Retry when API returns 0 results (rate limiting pattern)\n};\n\nconst STEPWISE_CONFIG = {\n    maxAttempts: 2,             // Max sliding windows\n    windowDays: 30,             // Days per window\n    maxRangeDays: 196,\n    requestTimeoutMs: 60000,    // Increased timeout for retries\n    delayBetweenWindowsMs: 5000 // 5s delay between windows (v8: increased from 3s)\n};\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nconst VOICE_TEMPLATES = {\n    slotOffer: (time, day, date) => `I have ${time} available on ${day}. Would that work?`,\n    noSlotsExpanding: \"Let me check a few more dates.\",\n    transferOnFailure: \"I want to connect you with a specialist who can assist you.\"\n};\n\nconst CONFIRMATION_PATTERNS = {\n    affirmative: ['yes', 'yeah', 'yep', 'yup', 'sure', 'okay', 'ok', 'alright', 'that works', 'works for me', 'perfect', 'sounds good'],\n    negative: ['no', 'nope', 'not that', 'different', 'another', 'other times'],\n    goodbye: ['that\\'s all', 'that\\'s it', 'no thanks', 'i\\'m good', 'goodbye', 'bye']\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction parseDate(dateStr) {\n    const parts = dateStr.split('/');\n    if (parts.length === 3) return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n    return new Date(dateStr);\n}\n\nfunction addDays(dateStr, days) {\n    const date = parseDate(dateStr);\n    date.setDate(date.getDate() + days);\n    return formatDate(date);\n}\n\nfunction getDayName(dateStr) {\n    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n    return days[parseDate(dateStr).getDay()];\n}\n\nfunction formatSlotForVoice(slot) {\n    const date = slot.StartTime.split(' ')[0];\n    const time = slot.StartTime.split(' ').slice(1).join(' ');\n    return { time: time, date: date, day: getDayName(date), raw: slot };\n}\n\nfunction validateAndCorrectDates(startDateStr, endDateStr) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const tomorrow = new Date(today);\n    tomorrow.setDate(tomorrow.getDate() + 1);\n\n    let correctedStart = startDateStr;\n    let wasDateCorrected = false;\n\n    if (startDateStr) {\n        const startDate = parseDate(startDateStr);\n        startDate.setHours(0, 0, 0, 0);\n        if (startDate < today) {\n            correctedStart = formatDate(tomorrow);\n            wasDateCorrected = true;\n        }\n    }\n\n    let correctedEnd = endDateStr;\n    if (endDateStr && correctedStart) {\n        const endDate = parseDate(endDateStr);\n        const startDate = parseDate(correctedStart);\n        if (endDate <= startDate) {\n            const newEnd = new Date(startDate);\n            newEnd.setDate(newEnd.getDate() + 14);\n            correctedEnd = formatDate(newEnd);\n        }\n    }\n\n    return { startDate: correctedStart, endDate: correctedEnd, wasDateCorrected };\n}\n\nfunction createLlmGuidance(scenario, context = {}) {\n    const baseGuidance = {\n        timestamp: new Date().toISOString(),\n        confirmation_triggers: CONFIRMATION_PATTERNS.affirmative,\n        goodbye_triggers: CONFIRMATION_PATTERNS.goodbye,\n        prohibited_responses: [\"Let me check on that\", \"One moment while I look into this\", \"I'm verifying\", \"sorry\", \"unfortunately\", \"error\", \"problem\"]\n    };\n\n    switch (scenario) {\n        case 'slots_found':\n            return {\n                ...baseGuidance,\n                current_state: \"SCHEDULING\",\n                next_state: \"SCHEDULING\",\n                action_required: \"offer_time_to_caller\",\n                voice_response: VOICE_TEMPLATES.slotOffer(context.firstSlot?.time, context.firstSlot?.day, context.firstSlot?.date),\n                chain_of_action: [\n                    \"1. Speak the time offer to caller\",\n                    \"2. Wait for response\",\n                    \"3. If affirmative  call chord_dso_patient action=create\",\n                    \"4. Then IMMEDIATELY call book_child with patientGUID\",\n                    \"5. Confirm booking to caller\"\n                ],\n                on_user_confirms: { action: \"PROCEED_TO_BOOKING\", do_not_say: \"Would you like to book?\", do_say: \"Perfect! Let me get that booked.\" },\n                on_user_declines: { action: \"OFFER_ALTERNATIVE\", do_say: \"No problem. How about [next slot]?\" }\n            };\n        case 'slots_not_found':\n            return {\n                ...baseGuidance,\n                current_state: \"SCHEDULING\",\n                next_state: context.attempts < 3 ? \"SCHEDULING\" : \"TRANSFER\",\n                action_required: context.attempts < 3 ? \"expand_and_retry\" : \"transfer_to_agent\",\n                voice_response: context.attempts < 3 ? VOICE_TEMPLATES.noSlotsExpanding : VOICE_TEMPLATES.transferOnFailure\n            };\n        default:\n            return baseGuidance;\n    }\n}\n\n// v8: Cloud9 API call with retry logic for rate limiting\nasync function fetchCloud9WithRetry(xmlRequest, context = '') {\n    let lastError = null;\n    let lastRecords = [];\n    let totalRetries = 0;\n\n    for (let retry = 0; retry <= RETRY_CONFIG.maxRetries; retry++) {\n        try {\n            if (retry > 0) {\n                node.warn(`[v8 RETRY] ${context} - Retry ${retry}/${RETRY_CONFIG.maxRetries}, waiting ${RETRY_CONFIG.retryDelayMs / 1000}s...`);\n                await delay(RETRY_CONFIG.retryDelayMs);\n            }\n\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xmlRequest,\n                timeout: STEPWISE_CONFIG.requestTimeoutMs\n            });\n\n            if (!response.ok) {\n                lastError = new Error(`HTTP ${response.status}`);\n                throw lastError;\n            }\n\n            const xmlText = await response.text();\n            const parsed = parseXmlResponse(xmlText);\n            lastRecords = parsed.records;\n\n            // Check for zero-result rate limiting pattern\n            if (RETRY_CONFIG.retryOnZeroResults && parsed.records.length === 0 && retry < RETRY_CONFIG.maxRetries) {\n                node.warn(`[v8 RETRY] ${context} - Got 0 results (possible rate limit), will retry...`);\n                totalRetries++;\n                continue;\n            }\n\n            // Success!\n            return {\n                success: true,\n                status: parsed.status,\n                records: parsed.records,\n                retries: totalRetries\n            };\n\n        } catch (error) {\n            lastError = error;\n            totalRetries++;\n            node.warn(`[v8 RETRY] ${context} - Error: ${error.message}`);\n        }\n    }\n\n    // All retries exhausted\n    return {\n        success: false,\n        error: lastError,\n        status: 'Error',\n        records: lastRecords,\n        retries: totalRetries\n    };\n}\n\nasync function searchSlotsWithSlidingWindow(initialStartDate, scheduleViewGUIDs) {\n    let currentStart = initialStartDate;\n    let windowAttempt = 0;\n    let totalRetries = 0;\n\n    while (windowAttempt < STEPWISE_CONFIG.maxAttempts) {\n        // v8: Add 5s delay before subsequent windows\n        if (windowAttempt > 0) {\n            await delay(STEPWISE_CONFIG.delayBetweenWindowsMs);\n            node.warn(`Waited ${STEPWISE_CONFIG.delayBetweenWindowsMs}ms before window ${windowAttempt + 1}`);\n        }\n        windowAttempt++;\n        const currentEnd = addDays(currentStart, STEPWISE_CONFIG.windowDays);\n        node.warn(`[v8] Slot search window ${windowAttempt}: ${currentStart} to ${currentEnd}`);\n\n        const apiParams = {\n            startDate: `${currentStart} 7:00:00 AM`,\n            endDate: `${currentEnd} 5:00:00 PM`,\n            morning: 'True',\n            afternoon: 'True'\n        };\n        if (scheduleViewGUIDs) apiParams.schdvwGUIDs = scheduleViewGUIDs;\n        const xmlRequest = buildXmlRequest('GetOnlineReservations', apiParams);\n\n        // v8: Use retry-enabled fetch\n        const result = await fetchCloud9WithRetry(xmlRequest, `Window ${windowAttempt}`);\n        totalRetries += result.retries || 0;\n\n        if (!result.success) {\n            const isTimeout = (result.error?.message || '').toLowerCase().includes('timeout');\n            return {\n                success: false,\n                records: [],\n                attempts: windowAttempt,\n                retries: totalRetries,\n                errorType: isTimeout ? 'timeout' : 'api_error',\n                shouldTransfer: true\n            };\n        }\n\n        // Filter by location\n        let filteredRecords = result.records;\n        if (CLOUD9.defaultLocationGUID && result.records.length > 0) {\n            filteredRecords = result.records.filter(slot => slot.LocationGUID === CLOUD9.defaultLocationGUID);\n            node.warn(`Location filter: ${result.records.length} total -> ${filteredRecords.length} at location`);\n\n            // v10: Chair 8 filter RESTORED - required for booking\n            const beforeChair8Count = filteredRecords.length;\n            filteredRecords = filteredRecords.filter(slot => slot.ScheduleColumnGUID === CHAIR_8_GUID);\n            node.warn(`[v10] Chair 8 filter: ${beforeChair8Count} -> ${filteredRecords.length} on Chair 8`);\n        }\n\n        if (filteredRecords.length > 0) {\n            return {\n                success: true,\n                records: filteredRecords,\n                attempts: windowAttempt,\n                retries: totalRetries,\n                expanded: windowAttempt > 1,\n                searchRange: { startDate: currentStart, endDate: currentEnd },\n                _slidingWindow: true\n            };\n        }\n\n        // Slide window forward\n        currentStart = addDays(currentStart, STEPWISE_CONFIG.windowDays);\n    }\n\n    return {\n        success: false,\n        records: [],\n        attempts: windowAttempt,\n        retries: totalRetries,\n        shouldTransfer: windowAttempt >= STEPWISE_CONFIG.maxAttempts\n    };\n}\n\nasync function getApptSlots() {\n    try {\n        const params = msg.payload;\n        const dates = validateAndCorrectDates(\n            params.startDate || formatDate(new Date(Date.now() + 86400000)),\n            params.endDate || formatDate(new Date(Date.now() + 15 * 86400000))\n        );\n\n        const result = await searchSlotsWithSlidingWindow(dates.startDate, params.scheduleViewGUIDs);\n\n        if (result.success && result.records.length > 0) {\n            const DEFAULT_APPT_TYPE_GUID = 'f6c20c35-9abb-47c2-981a-342996016705';\n            const enrichedSlots = result.records.map(slot => ({\n                ...slot,\n                scheduleViewGUID: slot.ScheduleViewGUID || slot.scheduleViewGUID,\n                scheduleColumnGUID: slot.ScheduleColumnGUID || slot.scheduleColumnGUID,\n                startTime: slot.StartTime || slot.startTime,\n                minutes: slot.Minutes || slot.minutes || '40',\n                appointmentTypeGUID: slot.AppointmentTypeGUID || slot.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || DEFAULT_APPT_TYPE_GUID,\n                ScheduleViewGUID: slot.ScheduleViewGUID || slot.scheduleViewGUID,\n                ScheduleColumnGUID: slot.ScheduleColumnGUID || slot.scheduleColumnGUID,\n                AppointmentTypeGUID: slot.AppointmentTypeGUID || slot.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || DEFAULT_APPT_TYPE_GUID\n            }));\n            const voiceSlots = enrichedSlots.slice(0, 5).map(formatSlotForVoice);\n            const firstSlot = voiceSlots[0];\n\n            msg.payload = {\n                slots: enrichedSlots,\n                count: result.records.length,\n                voiceSlots: voiceSlots,\n                searchRange: result.searchRange,\n                attempts: result.attempts,\n                retries: result.retries,\n                expanded: result.expanded,\n                llm_guidance: createLlmGuidance('slots_found', { firstSlot })\n            };\n        } else if (result.shouldTransfer || result.errorType) {\n            msg.payload = {\n                slots: [],\n                count: 0,\n                attempts: result.attempts,\n                retries: result.retries,\n                llm_guidance: {\n                    ...createLlmGuidance('slots_not_found', { attempts: STEPWISE_CONFIG.maxAttempts }),\n                    action_required: \"transfer_to_agent\",\n                    voice_response: \"I want to connect you with a specialist who can assist you. One moment while I transfer your call.\",\n                    transfer_reason: result.errorType || \"no_slots_after_retries\",\n                    CRITICAL: \"Do NOT mention error, timeout, or technical problems. Transfer gracefully without explanation.\",\n                    prohibited_responses: [\"error\", \"timeout\", \"problem\", \"issue\", \"technical\", \"system\", \"down\", \"difficulties\", \"went wrong\"]\n                }\n            };\n        } else {\n            msg.payload = {\n                slots: [],\n                count: 0,\n                attempts: result.attempts,\n                retries: result.retries,\n                llm_guidance: createLlmGuidance('slots_not_found', { attempts: result.attempts })\n            };\n        }\n\n        return msg;\n    } catch (error) {\n        node.error('Get appt slots error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to get appointment slots', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn getApptSlots();\n",
    "outputs": 1,
    "timeout": 120,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 800,
    "y": 1600,
    "wires": [
      [
        "http-out-get-appt-slots",
        "debug-get-appt-slots-out"
      ]
    ]
  },
  {
    "id": "debug-get-appt-slots-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-appt-slots",
    "name": "Egress GetApptSlots",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1120,
    "y": 1520,
    "wires": []
  },
  {
    "id": "http-out-get-appt-slots",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-get-appt-slots",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 1600,
    "wires": []
  },
  {
    "id": "inject-grouped-slots",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-grouped-slots",
    "name": "Test: Grouped Slots (2 kids)",
    "props": [
      {
        "p": "payload.numberOfPatients",
        "v": "2",
        "vt": "num"
      },
      {
        "p": "payload.timeWindowMinutes",
        "v": "30",
        "vt": "num"
      },
      {
        "p": "payload.scheduleViewGUIDs",
        "v": "defaultScheduleViewGUID",
        "vt": "env"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 180,
    "y": 1720,
    "wires": [
      [
        "func-grouped-slots",
        "debug-grouped-slots-in"
      ]
    ]
  },
  {
    "id": "http-in-grouped-slots",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-grouped-slots",
    "name": "",
    "url": "/chord/ortho-prd/getGroupedApptSlots",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 240,
    "y": 1800,
    "wires": [
      [
        "func-grouped-slots",
        "debug-grouped-slots-in"
      ]
    ]
  },
  {
    "id": "debug-grouped-slots-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-grouped-slots",
    "name": "Ingress GroupedSlots",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 650,
    "y": 1720,
    "wires": []
  },
  {
    "id": "func-grouped-slots",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-grouped-slots",
    "name": "getGroupedApptSlots v21",
    "func": "// Ortho Get Grouped Appointment Slots v22 - BULLETPROOF sibling slot query\n// v22: ALWAYS return individual slots alongside groups\n//      Response now includes 'slots' array with ALL available Chair 8 slots\n//      If groups form: groups + slots both populated, booking_plan uses group[0]\n//      If no groups: groups=[], slots populated, booking_plan assigns individual slots\n//      Guarantees: slots.length >= numberOfPatients when availability exists\n// v21: REMOVE reservation filtering from slot PRESENTATION - stale reservations were blocking all pairs\n// v20: FIX tierIndex reset on cache fallback + Chair 8 filter always applies\n// v17: BULLETPROOF SIBLING BOOKING - Chair 8 filter RESTORED with 40-min time window fix to allow all chairs\n// v15: CROSS-SESSION RESERVATION FILTERING - Filter out slots reserved by other sessions\n// v14: BULLETPROOF CACHE - Enhanced logging, background refresh, pre-grouped caching, hybrid mode\n// v13: SIBLING SAFETY - Added explicit booking_plan to prevent same-slot double booking\n// v12: REDIS CACHE CHECK (FIX: use flat slots directly) - Check pre-fetched slots before hitting Cloud9 API\n// v7: Added Chair 8 filter - only return slots available on Chair 8\n// v5: TIER-BASED search - 30, 60, 90 day expanding tiers instead of sliding windows\n// v4: FIX - Continue searching if found slots can't form groups (sibling booking requires 2+ consecutive slots)\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace'),\n    defaultApptTypeGUID: env.get('defaultApptTypeGUID'),\n    defaultLocationGUID: env.get('defaultLocationGUID')\n};\n\n// v7: Chair 8 filter - only return slots available on Chair 8 for test bookings\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\n// v12: Redis cache configuration - STALE CACHE FALLBACK\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\nconst MAX_CACHE_AGE_MS = 5 * 60 * 1000; // 5 minutes - considered fresh\nconst STALE_THRESHOLD_MS = 15 * 60 * 1000; // v12: 15 min - log warning but still use\nconst HARD_STALE_MS = 60 * 60 * 1000; // v12: RAISED to 60 min - only reject if REALLY old\n\n// v15: CROSS-SESSION RESERVATION FILTERING - Filter out slots reserved by other sessions\nconst RESERVATION_CHECK_BATCH_SIZE = 50; // Check this many slots at a time\n\n// v15: Check reservation status for a single slot\nasync function checkSlotReserved(slotStartTime, scheduleColumnGUID, currentSessionId) {\n    const datePart = slotStartTime.split(' ')[0];\n    const timePart = slotStartTime.split(' ').slice(1, 3).join(' ');\n\n    const [mm, dd, yyyy] = datePart.split('/');\n    const dateStr = yyyy + mm.padStart(2, '0') + dd.padStart(2, '0');\n\n    let timeMatch = timePart.match(/(\\d+):(\\d+)/);\n    if (!timeMatch) return { reserved: false };\n\n    let hours = parseInt(timeMatch[1]);\n    const minutes = timeMatch[2];\n    const isPM = timePart.toLowerCase().includes('pm');\n    const isAM = timePart.toLowerCase().includes('am');\n\n    if (isPM && hours !== 12) hours += 12;\n    if (isAM && hours === 12) hours = 0;\n\n    const timeStr = hours.toString().padStart(2, '0') + minutes;\n    const columnGUID = scheduleColumnGUID || CHAIR_8_GUID;\n    const locationGUID = CLOUD9.defaultLocationGUID || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\n\n    const reservationKey = 'SlotReservation:' + locationGUID + ':' + dateStr + ':' + timeStr + ':' + columnGUID;\n\n    try {\n        const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(reservationKey);\n        const response = await fetch(getUrl, {\n            method: 'GET',\n            headers: { 'Authorization': REDIS_AUTH },\n            timeout: 3000\n        });\n\n        if (!response.ok) return { reserved: false };\n\n        const text = await response.text();\n        if (!text || text === 'null' || text === '') return { reserved: false };\n\n        const reservation = JSON.parse(text);\n\n        // v19: Cleared reservations are NOT reserved\n        if (reservation.cleared || reservation.sessionId === \"_CLEARED_\") {\n            return { reserved: false, cleared: true };\n        }\n\n        // Same session can see their own reserved slots\n        if (currentSessionId && reservation.sessionId === currentSessionId) {\n            return { reserved: false, sameSession: true };\n        }\n\n        return { reserved: true, reservedBy: reservation.sessionId };\n    } catch (e) {\n        return { reserved: false };\n    }\n}\n\n// v15: Filter out reserved slots from a list\nasync function filterReservedSlots(slots, currentSessionId) {\n    if (!slots || slots.length === 0) return slots;\n\n    const filteredSlots = [];\n    let reservedCount = 0;\n\n    for (const slot of slots) {\n        const startTime = slot.StartTime || slot.startTime;\n        const columnGUID = slot.ScheduleColumnGUID || slot.scheduleColumnGUID;\n\n        const check = await checkSlotReserved(startTime, columnGUID, currentSessionId);\n\n        if (check.reserved) {\n            reservedCount++;\n            node.warn('[v15] Filtering out reserved slot: ' + startTime + ' (reserved by: ' + check.reservedBy + ')');\n        } else {\n            filteredSlots.push(slot);\n        }\n    }\n\n    if (reservedCount > 0) {\n        node.warn('[v15] Filtered ' + reservedCount + ' reserved slots from ' + slots.length + ' total');\n    }\n\n    return filteredSlots;\n}\n\n// v15: Filter reserved slots from grouped results\nasync function filterReservedGroups(groups, currentSessionId) {\n    if (!groups || groups.length === 0) return groups;\n\n    const filteredGroups = [];\n    let filteredCount = 0;\n\n    for (const group of groups) {\n        if (!group.slots || group.slots.length === 0) {\n            filteredGroups.push(group);\n            continue;\n        }\n\n        // Check if ANY slot in the group is reserved by another session\n        let groupReserved = false;\n        for (const slot of group.slots) {\n            const startTime = slot.StartTime || slot.startTime;\n            const columnGUID = slot.ScheduleColumnGUID || slot.scheduleColumnGUID;\n            const check = await checkSlotReserved(startTime, columnGUID, currentSessionId);\n\n            if (check.reserved) {\n                groupReserved = true;\n                node.warn('[v15] Group contains reserved slot: ' + startTime);\n                break;\n            }\n        }\n\n        if (groupReserved) {\n            filteredCount++;\n        } else {\n            filteredGroups.push(group);\n        }\n    }\n\n    if (filteredCount > 0) {\n        node.warn('[v15] Filtered ' + filteredCount + ' groups containing reserved slots');\n    }\n\n    return filteredGroups;\n}\n\n// v6: Tier-based search - expands in 30, 60, 90 day tiers from original start date\n// RATE LIMIT FIX: Cloud9 ErrorCode 8 - use 10s delay between GetOnlineReservations calls\nconst TIER_CONFIG = {\n    tiers: [30, 60, 90],  // Days to search in each tier\n    requestTimeoutMs: 60000,\n    delayBetweenTiersMs: 10000  // 10s delay to avoid Cloud9 rate limiting (ErrorCode 8)\n};\n\n// v14: Cache decision tracking\nlet cacheDecision = {\n    checked: false,\n    tiers: {},\n    usedTier: null,\n    fallbackReason: null,\n    preGroupedHit: false\n};\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction parseDate(dateStr) {\n    const parts = dateStr.split('/');\n    if (parts.length === 3) return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n    return new Date(dateStr);\n}\n\nfunction addDays(dateStr, days) {\n    const date = parseDate(dateStr);\n    date.setDate(date.getDate() + days);\n    return formatDate(date);\n}\n\nfunction getDayName(dateStr) {\n    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n    return days[parseDate(dateStr).getDay()];\n}\n\nfunction groupConsecutiveSlots(slots, numberOfPatients, timeWindowMinutes) {\n    const groups = [];\n    const sortedSlots = [...slots].sort((a, b) => new Date(a.StartTime || a.startTime) - new Date(b.StartTime || b.startTime));\n\n    for (let i = 0; i <= sortedSlots.length - numberOfPatients; i++) {\n        const group = [sortedSlots[i]];\n        let lastEndTime = new Date(sortedSlots[i].StartTime || sortedSlots[i].startTime);\n        lastEndTime.setMinutes(lastEndTime.getMinutes() + parseInt(sortedSlots[i].Minutes || sortedSlots[i].minutes || 45));\n\n        for (let j = i + 1; j < sortedSlots.length && group.length < numberOfPatients; j++) {\n            const nextStart = new Date(sortedSlots[j].StartTime || sortedSlots[j].startTime);\n            const timeDiff = (nextStart - lastEndTime) / 60000;\n\n            if (timeDiff >= 0 && timeDiff <= timeWindowMinutes) {\n                group.push(sortedSlots[j]);\n                lastEndTime = new Date(sortedSlots[j].StartTime || sortedSlots[j].startTime);\n                lastEndTime.setMinutes(lastEndTime.getMinutes() + parseInt(sortedSlots[j].Minutes || sortedSlots[j].minutes || 45));\n            }\n        }\n\n        if (group.length === numberOfPatients) {\n            const startTime = group[0].StartTime || group[0].startTime;\n            const date = startTime.split(' ')[0];\n            groups.push({\n                slots: group,\n                date: date,\n                day: getDayName(date),\n                times: group.map(s => (s.StartTime || s.startTime).split(' ').slice(1).join(' '))\n            });\n        }\n    }\n\n    return groups;\n}\n\n// v14: Trigger background cache refresh (fire-and-forget)\nfunction triggerBackgroundRefresh(reason) {\n    const refreshUrl = `${REDIS_BASE_URL}/test/redis-slot-cache/trigger`;\n    node.warn(`[v14] Triggering background cache refresh. Reason: ${reason}`);\n\n    // Fire and forget - don't await\n    fetch(refreshUrl, {\n        method: 'POST',\n        headers: {\n            'Authorization': REDIS_AUTH,\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ reason: reason, triggeredAt: new Date().toISOString() }),\n        timeout: 5000\n    }).then(res => {\n        node.warn(`[v14] Background refresh triggered: HTTP ${res.status}`);\n    }).catch(err => {\n        node.warn(`[v14] Background refresh trigger failed: ${err.message}`);\n    });\n}\n\n// v14: Store pre-grouped slots in Redis for faster retrieval\nasync function storePreGroupedSlots(tier, slots, groups) {\n    const DEFAULT_LOCATION_GUID = CLOUD9.defaultLocationGUID || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\n    const preGroupedKey = `SlotCache-${DEFAULT_LOCATION_GUID}-Tier${tier}-PreGrouped`;\n\n    const preGroupedData = {\n        fetchedAt: new Date().toISOString(),\n        tier: tier,\n        pairs: groupConsecutiveSlots(slots, 2, 40), // v18: Fixed to 40-min window\n        triples: groupConsecutiveSlots(slots, 3, 40), // v18: Fixed to 40-min window\n        pairsCount: 0,\n        triplesCount: 0\n    };\n    preGroupedData.pairsCount = preGroupedData.pairs.length;\n    preGroupedData.triplesCount = preGroupedData.triples.length;\n\n    const redisSetUrl = `${REDIS_BASE_URL}/chord/ortho-prd/redisSet`;\n\n    try {\n        const response = await fetch(redisSetUrl, {\n            method: 'POST',\n            headers: {\n                'Authorization': REDIS_AUTH,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                key: preGroupedKey,\n                value: preGroupedData,\n                ttl: 300 // 5 min TTL - aligned with refresh cycle (v20)\n            }),\n            timeout: 5000\n        });\n\n        if (response.ok) {\n            node.warn(`[v14] Stored pre-grouped slots for Tier ${tier}: ${preGroupedData.pairsCount} pairs, ${preGroupedData.triplesCount} triples`);\n        }\n    } catch (e) {\n        node.warn(`[v14] Failed to store pre-grouped slots: ${e.message}`);\n    }\n}\n\n// v14: Check for pre-grouped slots first (fastest path)\nasync function checkPreGroupedCache(numberOfPatients) {\n    const DEFAULT_LOCATION_GUID = CLOUD9.defaultLocationGUID || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\n    const groupType = numberOfPatients === 2 ? 'pairs' : (numberOfPatients === 3 ? 'triples' : null);\n\n    if (!groupType) {\n        node.warn(`[v14] Pre-grouped cache only supports 2 or 3 patients, got ${numberOfPatients}`);\n        return { success: false };\n    }\n\n    for (const tier of [1, 2, 3]) {\n        const preGroupedKey = `SlotCache-${DEFAULT_LOCATION_GUID}-Tier${tier}-PreGrouped`;\n        const redisUrl = `${REDIS_BASE_URL}/chord/ortho-prd/redisGet?key=${encodeURIComponent(preGroupedKey)}`;\n\n        try {\n            const response = await fetch(redisUrl, {\n                method: 'GET',\n                headers: { 'Authorization': REDIS_AUTH },\n                timeout: 3000\n            });\n\n            if (!response.ok) continue;\n\n            const responseText = await response.text();\n            if (!responseText || responseText === 'null' || responseText === '') continue;\n\n            const cacheData = JSON.parse(responseText);\n            const groups = cacheData[groupType];\n\n            if (groups && groups.length > 0) {\n                const cacheAge = Date.now() - new Date(cacheData.fetchedAt).getTime();\n                if (cacheAge <= HARD_STALE_MS) {\n                    node.warn(`[v14] PRE-GROUPED CACHE HIT! Tier ${tier}: ${groups.length} ${groupType}, age ${Math.round(cacheAge / 1000)}s`);\n                    cacheDecision.preGroupedHit = true;\n                    return {\n                        success: true,\n                        tier: tier,\n                        groups: groups,\n                        cacheAge: cacheAge,\n                        fetchedAt: cacheData.fetchedAt,\n                        source: 'pre-grouped'\n                    };\n                }\n            }\n        } catch (e) {\n            continue;\n        }\n    }\n\n    return { success: false };\n}\n\n// v12: Check Redis cache for pre-fetched slots - WITH STALE FALLBACK\n// v14: Enhanced with detailed decision logging\nasync function checkRedisCache() {\n    const TIERS = [1, 2, 3];\n    const DEFAULT_LOCATION_GUID = CLOUD9.defaultLocationGUID || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\n\n    cacheDecision.checked = true;\n\n    // v12: Track best stale cache as fallback\n    let bestStaleCache = null;\n\n    for (const tier of TIERS) {\n        const redisKey = `SlotCache-${DEFAULT_LOCATION_GUID}-Tier${tier}`;\n        const redisUrl = `${REDIS_BASE_URL}/chord/ortho-prd/redisGet?key=${encodeURIComponent(redisKey)}`;\n\n        // v14: Initialize tier decision tracking\n        cacheDecision.tiers[tier] = {\n            checked: true,\n            found: false,\n            slots: 0,\n            age: null,\n            status: null,\n            skipped: null\n        };\n\n        try {\n            node.warn(`[v14] Checking Redis cache Tier ${tier}: ${redisKey}`);\n            const response = await fetch(redisUrl, {\n                method: 'GET',\n                headers: { 'Authorization': REDIS_AUTH },\n                timeout: 5000\n            });\n\n            if (!response.ok) {\n                node.warn(`[v14] Redis GET failed for Tier ${tier}: HTTP ${response.status}`);\n                cacheDecision.tiers[tier].skipped = `http_${response.status}`;\n                continue;\n            }\n\n            const responseText = await response.text();\n            if (!responseText || responseText === 'null' || responseText === '') {\n                node.warn(`[v14] Cache MISS - Tier ${tier} key not found`);\n                cacheDecision.tiers[tier].skipped = 'not_found';\n                continue;\n            }\n\n            let cacheData;\n            try {\n                cacheData = JSON.parse(responseText);\n            } catch (e) {\n                node.warn(`[v14] Failed to parse cache data for Tier ${tier}: ${e.message}`);\n                cacheDecision.tiers[tier].skipped = 'parse_error';\n                continue;\n            }\n\n            cacheDecision.tiers[tier].found = true;\n            cacheDecision.tiers[tier].slots = cacheData.slotCount || 0;\n\n            // Check if this tier has any slots\n            if (!cacheData.slotCount || cacheData.slotCount === 0) {\n                node.warn(`[v14] Tier ${tier} cache empty (0 slots), trying next tier...`);\n                cacheDecision.tiers[tier].skipped = 'empty';\n                continue;\n            }\n\n            // Check cache freshness\n            const cacheAge = Date.now() - new Date(cacheData.fetchedAt).getTime();\n            const isFresh = cacheAge <= MAX_CACHE_AGE_MS;\n            const isStale = cacheAge > STALE_THRESHOLD_MS;\n            const isCriticallyStale = cacheAge > HARD_STALE_MS;\n\n            cacheDecision.tiers[tier].age = Math.round(cacheAge / 1000) + 's';\n            cacheDecision.tiers[tier].status = isFresh ? 'fresh' : (isCriticallyStale ? 'critical_stale' : 'stale');\n\n            // v12: Track as potential fallback even if stale\n            const cacheResult = {\n                success: true,\n                tier: tier,\n                tierDays: cacheData.tierDays,\n                cacheAge: cacheAge,\n                fetchedAt: cacheData.fetchedAt,\n                slots: cacheData.slots,\n                slotCount: cacheData.slotCount,\n                dateRange: cacheData.dateRange,\n                _stale: !isFresh,\n                _staleFallback: false\n            };\n\n            // If fresh, return immediately\n            if (isFresh) {\n                node.warn(`[v14] CACHE HIT (FRESH)! Tier ${tier}: ${cacheData.slotCount} slots, age ${Math.round(cacheAge / 1000)}s`);\n                cacheDecision.usedTier = tier;\n                return cacheResult;\n            }\n\n            // If stale but not critical, use it\n            if (!isCriticallyStale) {\n                node.warn(`[v14] CACHE HIT (STALE but usable)! Tier ${tier}: ${cacheData.slotCount} slots, age ${Math.round(cacheAge / 1000)}s`);\n                cacheDecision.usedTier = tier;\n                // v14: Trigger background refresh since cache is stale\n                triggerBackgroundRefresh('stale_cache_used');\n                return cacheResult;\n            }\n\n            // v12: Critically stale - save as fallback but keep looking\n            node.warn(`[v14] Cache CRITICALLY STALE - Tier ${tier} age ${Math.round(cacheAge / 1000)}s > ${HARD_STALE_MS / 1000}s - saving as fallback`);\n            cacheDecision.tiers[tier].skipped = 'critical_stale';\n            if (!bestStaleCache || cacheData.slotCount > bestStaleCache.slotCount) {\n                bestStaleCache = cacheResult;\n                bestStaleCache._staleFallback = true;\n            }\n        } catch (e) {\n            node.warn(`[v14] Redis check failed for Tier ${tier}: ${e.message}`);\n            cacheDecision.tiers[tier].skipped = `error_${e.message.substring(0, 20)}`;\n            continue;\n        }\n    }\n\n    // v12: If we have a stale fallback with slots, use it instead of failing\n    if (bestStaleCache && bestStaleCache.slotCount > 0) {\n        node.warn(`[v14] Using STALE FALLBACK - Tier ${bestStaleCache.tier}: ${bestStaleCache.slotCount} slots (age ${Math.round(bestStaleCache.cacheAge / 1000)}s)`);\n        node.warn('[v14] WARNING: Using stale cache data. Slots may be outdated.');\n        cacheDecision.usedTier = bestStaleCache.tier;\n        cacheDecision.fallbackReason = 'used_critical_stale_fallback';\n        // v14: Trigger background refresh\n        triggerBackgroundRefresh('critical_stale_fallback_used');\n        return bestStaleCache;\n    }\n\n    // All tiers exhausted and no fallback - cache miss\n    node.warn('[v14] CACHE MISS - All tiers empty or unusable, falling back to API');\n    cacheDecision.fallbackReason = 'all_tiers_exhausted';\n    return { success: false };\n}\n\n// v8: Flatten grouped slots into raw slots array for regrouping\nfunction flattenGroupedSlots(groupedSlots) {\n    const flatSlots = [];\n    if (groupedSlots && Array.isArray(groupedSlots)) {\n        groupedSlots.forEach(group => {\n            if (group.slots && Array.isArray(group.slots)) {\n                flatSlots.push(...group.slots);\n            }\n        });\n    }\n    return flatSlots;\n}\n\nasync function getGroupedSlots() {\n    try {\n        const params = msg.payload;\n    // v15: Extract sessionId for reservation filtering\n    const currentSessionId = params.sessionId || params.uui || msg.payload.uui || 'unknown';\n    node.warn('[v15] Session for reservation filtering: ' + currentSessionId);\n        const numberOfPatients = parseInt(params.numberOfPatients) || 2;\n        const timeWindowMinutes = parseInt(params.timeWindowMinutes) || 40; // v18: Default to 40 for 40-min appointments\n\n        const originalStartDate = params.startDate || formatDate(new Date(Date.now() + 86400000));\n        let allRecords = [];\n        let groups = [];\n        let tierIndex = 0;\n        let lastSearchRange = { startDate: originalStartDate, endDate: null };\n        let slotsFoundButNoGroups = 0;\n        let fromCache = false;\n        let cacheSource = null;\n\n        // v14: CHECK PRE-GROUPED CACHE FIRST (fastest path)\n        const preGroupedResult = await checkPreGroupedCache(numberOfPatients);\n        if (preGroupedResult.success && preGroupedResult.groups.length > 0) {\n            node.warn(`[v14] Using PRE-GROUPED cache (${preGroupedResult.groups.length} groups)`);\n            fromCache = true;\n            cacheSource = 'pre-grouped';\n            groups = preGroupedResult.groups;\n            tierIndex = preGroupedResult.tier;\n\n            // v22: Extract individual slots from groups for slots array\n            allRecords = [];\n            for (const g of groups) {\n                if (g.slots) {\n                    for (const s of g.slots) {\n                        const exists = allRecords.some(r => (r.StartTime || r.startTime) === (s.StartTime || s.startTime) && (r.ScheduleColumnGUID || r.scheduleColumnGUID) === (s.ScheduleColumnGUID || s.scheduleColumnGUID));\n                        if (!exists) allRecords.push(s);\n                    }\n                }\n            }\n            node.warn('[v22] Extracted ' + allRecords.length + ' unique slots from pre-grouped cache');\n\n            // v14: Hybrid mode - if cache is stale, trigger background validation\n            if (preGroupedResult.cacheAge > STALE_THRESHOLD_MS) {\n                triggerBackgroundRefresh('pre_grouped_stale');\n            }\n        }\n\n        // v14: If no pre-grouped hit, check flat slot cache\n        if (!fromCache) {\n            const cacheResult = await checkRedisCache();\n\n            if (cacheResult.success) {\n                // CACHE HIT - Use cached slots to form groups\n                node.warn(`[v14] Using CACHED slots (Tier ${cacheResult.tier}, ${cacheResult.slotCount} slots)`);\n                fromCache = true;\n                cacheSource = 'flat-slots';\n\n                // v11: FIX - cache stores FLAT slots array, use directly (not grouped)\n                const flatSlots = cacheResult.slots;\n                node.warn(`[v14] Using ${flatSlots.length} cached slots directly`);\n\n                // Form groups from cached slots\n                groups = groupConsecutiveSlots(flatSlots, numberOfPatients, timeWindowMinutes);\n                node.warn(`[v14] Formed ${groups.length} groups from cached slots`);\n\n                allRecords = flatSlots;\n                lastSearchRange = cacheResult.dateRange || { startDate: originalStartDate, tierDays: cacheResult.tierDays };\n                tierIndex = cacheResult.tier;\n\n                if (groups.length === 0) {\n                    node.warn('[v20] Cache had slots but could not form groups - falling back to API with tierIndex RESET to 0');\n                    cacheDecision.fallbackReason = 'cache_slots_insufficient_for_grouping';\n                    fromCache = false;\n                    cacheSource = null;\n                    tierIndex = 0;\n                    // v14: Trigger background refresh since cache couldn't satisfy request\n                    triggerBackgroundRefresh('grouping_failed');\n                } else {\n                    // v14: Store pre-grouped slots for faster future lookups\n                    storePreGroupedSlots(cacheResult.tier, flatSlots, groups);\n                }\n            }\n        }\n\n        // If cache miss or no groups formed, fall back to Cloud9 API\n        if (!fromCache || groups.length === 0) {\n            node.warn('[v14] Proceeding with Cloud9 API call...');\n\n            // v5: TIER-BASED search - expands in 30, 60, 90 day tiers from ORIGINAL start date\n            while (tierIndex < TIER_CONFIG.tiers.length && groups.length === 0) {\n                // Add delay between tiers to avoid Cloud9 rate limiting (ErrorCode 8)\n                if (tierIndex > 0) {\n                    node.warn(`[v14] Waiting ${TIER_CONFIG.delayBetweenTiersMs}ms before tier ${tierIndex + 1}...`);\n                    await delay(TIER_CONFIG.delayBetweenTiersMs);\n                }\n                const tierDays = TIER_CONFIG.tiers[tierIndex];\n                tierIndex++;\n                const endDate = addDays(originalStartDate, tierDays);\n                node.warn(`[v14] Tier ${tierIndex}/${TIER_CONFIG.tiers.length}: Searching ${originalStartDate} to ${endDate} (${tierDays} days)`);\n\n                const apiParams = {\n                    startDate: `${originalStartDate} 7:00:00 AM`,\n                    endDate: `${endDate} 5:00:00 PM`,\n                    morning: 'True',\n                    afternoon: 'True',\n                    appttypGUIDs: CLOUD9.defaultApptTypeGUID\n                };\n                if (params.scheduleViewGUIDs) apiParams.schdvwGUIDs = params.scheduleViewGUIDs;\n                const xmlRequest = buildXmlRequest('GetOnlineReservations', apiParams);\n\n                const response = await fetch(CLOUD9.endpoint, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/xml' },\n                    body: xmlRequest,\n                    timeout: TIER_CONFIG.requestTimeoutMs\n                });\n\n                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n                const xmlText = await response.text();\n                const parsed = parseXmlResponse(xmlText);\n\n                // Filter by location\n                let filteredRecords = parsed.records;\n                if (CLOUD9.defaultLocationGUID && parsed.records.length > 0) {\n                    filteredRecords = parsed.records.filter(slot => slot.LocationGUID === CLOUD9.defaultLocationGUID);\n                    node.warn(`[v14] Location filter: ${parsed.records.length} total -> ${filteredRecords.length} at location`);\n                }\n\n                // v20: Chair 8 filter MOVED OUTSIDE location if-block - always applies\n                const beforeChair8Count = filteredRecords.length;\n                filteredRecords = filteredRecords.filter(slot => slot.ScheduleColumnGUID === CHAIR_8_GUID);\n                node.warn(`[v20] Chair 8 filter: ${beforeChair8Count} -> ${filteredRecords.length} on Chair 8`);\n\n                // v5: Try to form groups from the filtered records\n                if (filteredRecords.length > 0) {\n                    const tierGroups = groupConsecutiveSlots(filteredRecords, numberOfPatients, timeWindowMinutes);\n                    node.warn(`[v14] Tier ${tierIndex} (${tierDays}d): ${filteredRecords.length} slots -> ${tierGroups.length} groups`);\n\n                    if (tierGroups.length > 0) {\n                        // Found groups! Use these results\n                        allRecords = filteredRecords;\n                        groups = tierGroups;\n                        lastSearchRange = { startDate: originalStartDate, endDate: endDate, tierDays: tierDays };\n                        node.warn(`[v14] SUCCESS: Found ${groups.length} groups in tier ${tierIndex} (${tierDays} days)`);\n\n                        // v14: Store pre-grouped slots after successful API fetch\n                        storePreGroupedSlots(tierIndex, filteredRecords, groups);\n                    } else {\n                        // Found slots but can't form groups - continue to next tier\n                        slotsFoundButNoGroups += filteredRecords.length;\n                        node.warn(`[v14] Found ${filteredRecords.length} slots but 0 groups in ${tierDays}d tier - expanding...`);\n                    }\n                } else {\n                    node.warn(`[v14] No slots at location in ${tierDays}d tier - expanding...`);\n                }\n            }\n        }\n\n        // Inject default appointmentTypeGUID if empty\n        const DEFAULT_APPT_TYPE_GUID = 'f6c20c35-9abb-47c2-981a-342996016705';\n        \n        // v21: REMOVED reservation filtering from slot PRESENTATION\n        // Stale reservations from old test sessions were blocking ALL valid slot pairs.\n        // Cloud9 is the source of truth - if a slot is taken, booking will fail gracefully.\n        // Reservation checks only happen at BOOKING time in bookConsultation.\n        node.warn('[v21] Skipping reservation filter - presenting ' + groups.length + ' groups (Cloud9 is source of truth)');\n\n        const enrichedGroups = groups.map(group => ({\n            ...group,\n            slots: group.slots.map(slot => ({\n                ...slot,\n                scheduleViewGUID: slot.ScheduleViewGUID || slot.scheduleViewGUID,\n                scheduleColumnGUID: slot.ScheduleColumnGUID || slot.scheduleColumnGUID,\n                startTime: slot.StartTime || slot.startTime,\n                minutes: slot.Minutes || slot.minutes || '40',\n                appointmentTypeGUID: slot.AppointmentTypeGUID || slot.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || DEFAULT_APPT_TYPE_GUID,\n                ScheduleViewGUID: slot.ScheduleViewGUID || slot.scheduleViewGUID,\n                ScheduleColumnGUID: slot.ScheduleColumnGUID || slot.scheduleColumnGUID,\n                AppointmentTypeGUID: slot.AppointmentTypeGUID || slot.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || DEFAULT_APPT_TYPE_GUID\n            }))\n        }));\n\n        // v22: ALWAYS include individual slots array alongside groups\n        // Enrich individual slots the same way as group slots\n        const enrichedSlots = allRecords.map(slot => ({\n            scheduleViewGUID: slot.ScheduleViewGUID || slot.scheduleViewGUID,\n            scheduleColumnGUID: slot.ScheduleColumnGUID || slot.scheduleColumnGUID,\n            startTime: slot.StartTime || slot.startTime,\n            minutes: slot.Minutes || slot.minutes || '40',\n            appointmentTypeGUID: slot.AppointmentTypeGUID || slot.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || DEFAULT_APPT_TYPE_GUID\n        }));\n\n        // Sort individual slots by startTime\n        enrichedSlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));\n\n        // v22: Build booking_plan from groups if available, otherwise from individual slots\n        let bookingPlan = [];\n        let bookingMode = 'none';\n        if (enrichedGroups.length > 0) {\n            // Preferred: use consecutive group\n            bookingMode = 'consecutive';\n            bookingPlan = enrichedGroups[0].slots.map((slot, idx) => ({\n                child_index: idx + 1,\n                child_label: 'Child ' + (idx + 1),\n                startTime: slot.startTime,\n                scheduleViewGUID: slot.scheduleViewGUID,\n                scheduleColumnGUID: slot.scheduleColumnGUID,\n                appointmentTypeGUID: slot.appointmentTypeGUID,\n                minutes: slot.minutes || '40',\n                instruction: 'Book Child ' + (idx + 1) + ' at ' + slot.startTime + ' - DO NOT reuse this slot for other children'\n            }));\n        } else if (enrichedSlots.length >= numberOfPatients) {\n            // Fallback: assign individual slots to children\n            bookingMode = 'individual';\n            bookingPlan = enrichedSlots.slice(0, numberOfPatients).map((slot, idx) => ({\n                child_index: idx + 1,\n                child_label: 'Child ' + (idx + 1),\n                startTime: slot.startTime,\n                scheduleViewGUID: slot.scheduleViewGUID,\n                scheduleColumnGUID: slot.scheduleColumnGUID,\n                appointmentTypeGUID: slot.appointmentTypeGUID,\n                minutes: slot.minutes || '40',\n                instruction: 'Book Child ' + (idx + 1) + ' at ' + slot.startTime + ' - DO NOT reuse this slot for other children'\n            }));\n        }\n\n        const hasAvailability = bookingPlan.length >= numberOfPatients;\n\n        msg.payload = {\n            groups: enrichedGroups.slice(0, 10),\n            totalGroups: groups.length,\n            // v22: ALWAYS include individual slots\n            slots: enrichedSlots,\n            totalSlots: enrichedSlots.length,\n            numberOfPatients: numberOfPatients,\n            timeWindowMinutes: timeWindowMinutes,\n            searchRange: lastSearchRange,\n            tier: tierIndex,\n            tiersSearched: TIER_CONFIG.tiers.slice(0, tierIndex),\n            _tierBased: true,\n            _bookingMode: bookingMode,\n            _fromCache: fromCache,\n            _cacheSource: cacheSource,\n            _cacheDecision: cacheDecision,\n            _cacheInfo: fromCache ? {\n                tier: tierIndex,\n                source: cacheSource,\n                preGroupedHit: cacheDecision.preGroupedHit\n            } : null,\n            llm_guidance: {\n                timestamp: new Date().toISOString(),\n                model: 'PARENT_AS_PATIENT_V63',\n                confirmation_triggers: ['yes', 'yeah', 'yep', 'yup', 'sure', 'okay', 'ok', 'alright', 'that works', 'works for me', 'perfect', 'sounds good'],\n                goodbye_triggers: [\"that's all\", \"thats all\", \"that's it\", \"thats it\", \"no thank you\", \"no thanks\"],\n                current_state: 'SCHEDULING',\n                action_required: hasAvailability ? (bookingMode === 'consecutive' ? 'offer_grouped_times_to_caller' : 'offer_separate_times_to_caller') : 'expand_search_or_transfer',\n                on_user_confirms: { action: 'PROCEED_TO_BOOKING', do_not_say: 'Would you like to book?', do_say: 'Perfect! Let me get those appointments booked.' },\n                booking_plan: bookingPlan,\n                booking_mode: bookingMode,\n                BOOKING_INSTRUCTIONS: bookingMode === 'consecutive'\n                    ? 'v22: Consecutive slots found. Offer ONE time to caller (e.g. \"starting at 10:00 AM\"). Each child gets their own slot from booking_plan. Call book_child ONCE with children array using the booking_plan startTimes.'\n                    : bookingMode === 'individual'\n                    ? 'v22: No consecutive slots available, but individual slots found. Offer separate times to caller (e.g. \"10:00 AM and 2:30 PM\"). Each child gets their own slot from booking_plan. Call book_child ONCE with children array using the booking_plan startTimes.'\n                    : 'v22: No slots available for ' + numberOfPatients + ' children. Transfer to agent.',\n                SLOT_USAGE_RULE: 'CRITICAL: Each slot in booking_plan can only be used ONCE. Child 1 uses slot 1, Child 2 uses slot 2. NEVER book multiple children to the same slot.'\n            }\n        };\n\n        node.warn('[v22] Response: ' + groups.length + ' groups, ' + enrichedSlots.length + ' individual slots, mode=' + bookingMode + ', plan=' + bookingPlan.length + ' children');\n\n        return msg;\n    } catch (error) {\n        node.error('Get grouped slots error: ' + error.message, msg);\n        const isTimeout = ['timeout', 'ETIMEDOUT', 'ECONNRESET'].some(e => error.message.toLowerCase().includes(e.toLowerCase()));\n\n        // v14: Trigger refresh on error\n        triggerBackgroundRefresh('api_error');\n\n        msg.payload = {\n            groups: [],\n            totalGroups: 0,\n            error: true,\n            _cacheDecision: cacheDecision,\n            llm_guidance: {\n                current_state: 'SCHEDULING',\n                next_state: 'TRANSFER',\n                action_required: 'transfer_to_agent',\n                voice_response: 'I want to connect you with a specialist who can assist you. One moment while I transfer your call.',\n                transfer_reason: isTimeout ? 'timeout' : 'api_error',\n                CRITICAL: 'Do NOT mention error, timeout, or technical problems. Transfer gracefully without explanation.',\n                prohibited_responses: ['error', 'timeout', 'problem', 'issue', 'technical', 'system', 'down', 'difficulties', 'went wrong']\n            }\n        };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn getGroupedSlots();\n",
    "outputs": 1,
    "timeout": 120,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 820,
    "y": 1800,
    "wires": [
      [
        "http-out-grouped-slots",
        "debug-grouped-slots-out"
      ]
    ]
  },
  {
    "id": "debug-grouped-slots-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-grouped-slots",
    "name": "Egress GroupedSlots",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1130,
    "y": 1720,
    "wires": []
  },
  {
    "id": "http-out-grouped-slots",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-grouped-slots",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 1800,
    "wires": []
  },
  {
    "id": "inject-create-appt",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-appt",
    "name": "Test: Book Appt (update GUIDs from slots)",
    "props": [
      {
        "p": "payload.patientGUID",
        "v": "64DA8F5C-7E54-4659-8AE1-7BB6A033D2A5",
        "vt": "str"
      },
      {
        "p": "payload.startTime",
        "v": "01/15/2025 9:00 AM",
        "vt": "str"
      },
      {
        "p": "payload.scheduleViewGUID",
        "v": "defaultScheduleViewGUID",
        "vt": "env"
      },
      {
        "p": "payload.scheduleColumnGUID",
        "v": "defaultScheduleColumnGUID",
        "vt": "env"
      },
      {
        "p": "payload.minutes",
        "v": "45",
        "vt": "num"
      },
      {
        "p": "payload.childName",
        "v": "PhoneTest",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 140,
    "y": 1920,
    "wires": [
      [
        "func-create-appt",
        "debug-create-appt-in"
      ]
    ]
  },
  {
    "id": "http-in-create-appt",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-appt",
    "name": "",
    "url": "/chord/ortho-prd/createAppt",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 200,
    "y": 2000,
    "wires": [
      [
        "func-create-appt",
        "debug-create-appt-in"
      ]
    ]
  },
  {
    "id": "debug-create-appt-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-appt",
    "name": "Ingress CreateAppt",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 620,
    "y": 1920,
    "wires": []
  },
  {
    "id": "func-create-appt",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-appt",
    "name": "createAppt v12",
    "func": "// Ortho Create Appointment v13 - v71: Use child.patientGUID in batch booking (INDIVIDUAL_PATIENT_PER_PERSON)\n// v12: Fixed duplicate children block + atomic reservation - Calls Cloud9 SetAppointment\n// v10: CROSS-SESSION RESERVATION - Reserve slots in Redis to prevent race conditions\n// v9: SLOT DEDUPLICATION - Prevents same-session double-booking (no mutex, instant check)\n// v63: CHILDREN ARRAY SUPPORT - Book multiple children in one call\n// v62: FIXED stale token auto-injection - only inject if patientGUID matches\n// v61: REMOVED token expiration check - nonce uniqueness is sufficient\n// v57: FIXED sessionId bug - define BEFORE using in cache lookup\n// v6: PARENT-AS-PATIENT MODEL - Add note support via SetPatientComment\n// v5.1: Reduced sync retries to 2 (~10s max) for better IVA UX, async queue handles the rest\n// v5: Async queue for rate-limited requests - queue and return immediately, retry in background\n// v4: Two-layer rate limit handling: automatic spacing + progressive retry\n// v3: Added rate limit retry logic with 10s delay\n// v2: Enhanced error logging to expose actual Cloud9 error messages\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace'),\n    vendorUserName: env.get('vendorUserName'),\n    defaultApptTypeGUID: env.get('defaultApptTypeGUID')\n};\n// v9: Redis cache invalidation configuration\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\nconst DEFAULT_LOCATION_GUID = CLOUD9.defaultLocationGUID || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\n\n\n// v4: Two-layer rate limit handling for sibling bookings\n// Layer 1: Automatic spacing - prevent rate limits by spacing consecutive calls\nconst BOOKING_SPACING_MS = 10000;  // 10s minimum between SetAppointment calls\n\n// Layer 2: Quick sync retry - minimize dead air, then fall back to async queue\nconst RETRY_CONFIG = {\n    maxRetries: 2,\n    retryDelays: [5000]  // Single 5s retry before queueing (~10s max dead air)\n};\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\n\n// v10: CROSS-SESSION SLOT RESERVATION - Prevents concurrent sessions booking same slot\n\nconst VOICE_TEMPLATES = {\n    bookingConfirmed: (childName, day, date, time) =>\n        `Your appointment is confirmed! ${childName}, ${day} ${date} at ${time}.`,\n    transferOnFailure: \"I want to connect you with a specialist who can assist you.\"\n};\n\n// Error type detection for better debugging\n// v3: Added RATE_LIMIT pattern\nconst ERROR_PATTERNS = {\n    RATE_LIMIT: /too many requests|rate limit/i,\n    PATIENT_NOT_FOUND: /patient.*guid.*does not exist/i,\n    SLOT_NOT_AVAILABLE: /slot.*not available|time.*not available|already.*booked/i,\n    INVALID_SCHEDULE_VIEW: /schedule.*view.*invalid|schedule.*view.*not found/i,\n    INVALID_SCHEDULE_COLUMN: /schedule.*column.*invalid|column.*not found/i,\n    INVALID_APPT_TYPE: /appointment.*type.*invalid/i,\n    AUTHORIZATION_ERROR: /not authorized|authorization/i\n};\n\nfunction detectErrorType(resultMessage) {\n    for (const [errorType, pattern] of Object.entries(ERROR_PATTERNS)) {\n        if (pattern.test(resultMessage)) return errorType;\n    }\n    return resultMessage.toLowerCase().includes('error') ? 'CLOUD9_ERROR' : 'UNKNOWN';\n}\n// v9: Phase 4A/4B - Cache invalidation on booking success or slot-taken error\n// Phase 4D: Graceful degradation - failures are logged but don't block booking\nasync function invalidateBookedSlot(startTime, scheduleColumnGUID) {\n    const TIERS = [1, 2, 3];\n    const locationGUID = DEFAULT_LOCATION_GUID;\n\n    // Extract date from startTime (format: \"MM/DD/YYYY HH:MM AM/PM\")\n    const slotDate = startTime ? startTime.split(' ')[0] : null;\n\n    node.warn('[v9] CACHE_INVALIDATE: Invalidating slot ' + startTime + ' (col: ' + (scheduleColumnGUID || 'CHAIR8').substring(0, 8) + '...)');\n\n    for (const tier of TIERS) {\n        const redisKey = 'SlotCache-' + locationGUID + '-Tier' + tier;\n\n        try {\n            // GET current cache\n            const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(redisKey);\n            const getResponse = await fetch(getUrl, {\n                method: 'GET',\n                headers: { 'Authorization': REDIS_AUTH },\n                timeout: 5000\n            });\n\n            if (!getResponse.ok) {\n                node.warn('[v9] CACHE_INVALIDATE: GET failed for Tier ' + tier + ': HTTP ' + getResponse.status);\n                continue;\n            }\n\n            const responseText = await getResponse.text();\n            if (!responseText || responseText === 'null' || responseText === '') {\n                node.warn('[v9] CACHE_INVALIDATE: Tier ' + tier + ' cache empty, skipping');\n                continue;\n            }\n\n            let cacheData;\n            try {\n                cacheData = JSON.parse(responseText);\n            } catch (parseErr) {\n                node.warn('[v9] CACHE_INVALIDATE: Failed to parse Tier ' + tier + ' cache: ' + parseErr.message);\n                continue;\n            }\n\n            if (!cacheData.slots || cacheData.slots.length === 0) {\n                continue;\n            }\n\n            const originalCount = cacheData.slots.length;\n\n            // Remove the booked slot from the cache\n            // Match by StartTime/startTime AND ScheduleColumnGUID/scheduleColumnGUID\n            cacheData.slots = cacheData.slots.filter(slot => {\n                const slotStartTime = slot.StartTime || slot.startTime;\n                const slotColumnGUID = slot.ScheduleColumnGUID || slot.scheduleColumnGUID;\n\n                // Match both fields (or just time if column not provided)\n                const timeMatches = slotStartTime === startTime;\n                const columnMatches = !scheduleColumnGUID || slotColumnGUID === scheduleColumnGUID;\n\n                return !(timeMatches && columnMatches);\n            });\n\n            if (cacheData.slots.length < originalCount) {\n                const removedCount = originalCount - cacheData.slots.length;\n                cacheData.slotCount = cacheData.slots.length;\n                cacheData.invalidatedAt = new Date().toISOString();\n                cacheData.lastInvalidatedSlot = { startTime, scheduleColumnGUID };\n\n                // SET updated cache back to Redis\n                const setUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n                const setResponse = await fetch(setUrl, {\n                    method: 'POST',\n                    headers: {\n                        'Authorization': REDIS_AUTH,\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        key: redisKey,\n                        value: cacheData\n                    }),\n                    timeout: 5000\n                });\n\n                if (setResponse.ok) {\n                    node.warn('[v9] CACHE_INVALIDATE: Removed ' + removedCount + ' slot(s) from Tier ' + tier + ' (remaining: ' + cacheData.slotCount + ')');\n                } else {\n                    node.warn('[v9] CACHE_INVALIDATE: SET failed for Tier ' + tier + ': HTTP ' + setResponse.status);\n                }\n            } else {\n                node.warn('[v9] CACHE_INVALIDATE: Slot not found in Tier ' + tier + ' cache');\n            }\n\n        } catch (redisErr) {\n            // Phase 4D: Graceful degradation - log but don't fail the booking\n            node.warn('[v9] CACHE_INVALIDATE: Redis error for Tier ' + tier + ' (non-fatal): ' + redisErr.message);\n        }\n    }\n\n    // v15: Invalidate PRE-GROUPED cache keys (critical fix for stale slot groups)\n    // Simply DELETE the pre-grouped keys since recalculating affected groups is complex\n    node.warn('[v15] CACHE_INVALIDATE: Clearing pre-grouped cache keys');\n    for (const tier of TIERS) {\n        const preGroupedKey = 'SlotCache-' + locationGUID + '-Tier' + tier + '-PreGrouped';\n        try {\n            const deleteUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisDelete?key=' + encodeURIComponent(preGroupedKey);\n            const deleteResponse = await fetch(deleteUrl, {\n                method: 'DELETE',\n                headers: { 'Authorization': REDIS_AUTH },\n                timeout: 3000\n            });\n            if (deleteResponse.ok) {\n                node.warn('[v15] CACHE_INVALIDATE: Deleted pre-grouped cache Tier ' + tier);\n            }\n        } catch (e) {\n            // Non-fatal - pre-grouped cache will expire naturally\n            node.warn('[v15] CACHE_INVALIDATE: Failed to delete pre-grouped Tier ' + tier + ': ' + e.message);\n        }\n    }\n}\n\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const errorMatch = xmlText.match(/<ErrorMessage>([^<]+)<\\/ErrorMessage>/);\n    const errorMessage = errorMatch ? errorMatch[1] : null;\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, errorMessage, records };\n}\n\nfunction parseDate(dateStr) {\n    const parts = dateStr.split('/');\n    if (parts.length === 3) return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n    return new Date(dateStr);\n}\n\nfunction getDayName(dateStr) {\n    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n    return days[parseDate(dateStr).getDay()];\n}\n\nfunction createLlmGuidance(scenario, context = {}) {\n    const baseGuidance = {\n        timestamp: new Date().toISOString(),\n        prohibited_responses: [\"Let me check on that\", \"One moment while I look into this\", \"I'm verifying\", \"sorry\", \"unfortunately\", \"error\", \"problem\"]\n    };\n\n    switch (scenario) {\n        case 'booking_success':\n            return {\n                ...baseGuidance,\n                current_state: \"CONFIRMATION\",\n                next_state: \"CONFIRMATION\",\n                action_required: \"confirm_booking_to_caller\",\n                voice_response: VOICE_TEMPLATES.bookingConfirmed(context.childName, context.day, context.date, context.time),\n                required_keywords: [\"scheduled\", \"booked\", \"confirmed\", \"all set\"],\n                chain_of_action: [\n                    \"1. Confirm booking with enthusiasm\",\n                    \"2. State child name, day, date, time, location\",\n                    \"3. Ask 'Would you like the address?'\",\n                    \"4. Mention legal guardian requirement\",\n                    \"5. Ask 'Anything else?'\"\n                ],\n                never_do: [\"Ask for re-confirmation\", \"Say 'Let me verify'\", \"Delay the confirmation\"]\n            };\n        case 'booking_failed':\n            return {\n                ...baseGuidance,\n                current_state: \"SCHEDULING\",\n                next_state: context.canRetry ? \"SCHEDULING\" : \"TRANSFER\",\n                action_required: context.canRetry ? \"offer_alternative_slot\" : \"transfer_to_agent\",\n                voice_response: context.canRetry ? \"That time isn't available. How about [alternative]?\" : VOICE_TEMPLATES.transferOnFailure\n            };\n        case 'patient_not_found':\n            return {\n                ...baseGuidance,\n                current_state: \"SCHEDULING\",\n                next_state: \"SCHEDULING\",\n                action_required: \"recreate_patient_then_retry\",\n                voice_response: \"Let me verify your information.\",\n                CRITICAL: \"Patient does not exist in Cloud9. You MUST call chord_dso_patient action=create BEFORE booking.\",\n                recovery_steps: [\"1. Call chord_dso_patient with action=create\", \"2. Use returned patientGUID\", \"3. Retry book_child with new patientGUID\"]\n            };\n        case 'missing_slot_data':\n            return {\n                ...baseGuidance,\n                current_state: \"TRANSFER\",\n                next_state: \"TRANSFER\",\n                action_required: \"transfer_to_agent\",\n                transfer_reason: \"missing_scheduling_data\",\n                voice_response: VOICE_TEMPLATES.transferOnFailure\n            };\n        case 'booking_queued':\n            return {\n                ...baseGuidance,\n                current_state: \"BOOKING_QUEUED\",\n                next_state: \"CONFIRMATION_PENDING\",\n                action_required: \"inform_caller_queued\",\n                voice_response: \"Your appointment request is being processed. You will receive a confirmation shortly.\",\n                internal_note: \"Appointment was rate-limited and queued for async processing\",\n                chain_of_action: [\n                    \"1. Inform caller their request is being processed\",\n                    \"2. Reassure them confirmation will come shortly\",\n                    \"3. Ask if there's anything else you can help with\",\n                    \"4. End call gracefully\"\n                ],\n                never_do: [\"Mention rate limit\", \"Mention system issue\", \"Say booking failed\", \"Transfer to agent\"]\n            };\n        default:\n            return baseGuidance;\n    }\n}\n\n// v6: Add note to patient via SetPatientComment\nasync function addPatientNote(patientGUID, note) {\n    if (!note || !patientGUID) return { success: true, skipped: true };\n\n    try {\n        const xmlRequest = buildXmlRequest('SetPatientComment', {\n            patGUID: patientGUID,\n            patComment: note\n        });\n\n        node.warn(`[v6] Adding note to patient ${patientGUID.substring(0, 8)}...: ${note.substring(0, 50)}...`);\n\n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 15000\n        });\n\n        if (!response.ok) {\n            node.warn(`[v6] SetPatientComment HTTP error: ${response.status}`);\n            return { success: false, error: `HTTP ${response.status}` };\n        }\n\n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n\n        if (parsed.status === 'Success') {\n            node.warn('[v6] Patient note added successfully');\n            return { success: true };\n        } else {\n            node.warn(`[v6] SetPatientComment failed: ${parsed.errorMessage || 'Unknown error'}`);\n            return { success: false, error: parsed.errorMessage };\n        }\n    } catch (error) {\n        node.warn(`[v6] SetPatientComment exception: ${error.message}`);\n        return { success: false, error: error.message };\n    }\n}\n\n// v63: Shared helper for booking a single child with retry and async queue fallback\nasync function bookChildWithRetry(patientGUID, child, uui, sessionId) {\n    // v63: Use same spacing logic as single-child (BOOKING_SPACING_MS = 10s)\n    const lastBookingTime = flow.get('lastSetAppointmentTime') || 0;\n    const elapsed = Date.now() - lastBookingTime;\n    let spacingWaitMs = 0;\n    if (elapsed < BOOKING_SPACING_MS && lastBookingTime > 0) {\n        spacingWaitMs = BOOKING_SPACING_MS - elapsed;\n        node.warn('[v63] Spacing: waiting ' + spacingWaitMs + 'ms before child ' + child.childName);\n        await delay(spacingWaitMs);\n    }\n\n    // Build XML request for this child\n    const childXmlRequest = buildXmlRequest('SetAppointment', {\n        PatientGUID: patientGUID,\n        StartTime: child.startTime,\n        ScheduleViewGUID: child.scheduleViewGUID,\n        ScheduleColumnGUID: '07687884-7e37-49aa-8028-d43b751c9034', // CHAIR 8 - HARDCODED\n        AppointmentTypeGUID: child.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n        Minutes: String(child.minutes || 45),\n        VendorUserName: CLOUD9.vendorUserName\n    });\n\n    // v63: Use same retry logic as single-child (2 retries with 5s delay)\n    let attempt = 0;\n    let lastError = null;\n    let parsed = null;\n    let xmlText = '';\n\n    while (attempt < RETRY_CONFIG.maxRetries) {\n        attempt++;\n        if (attempt > 1) {\n            const delayMs = RETRY_CONFIG.retryDelays[attempt - 2] || 5000;\n            node.warn('[v63] Child ' + child.childName + ' rate limit retry: waiting ' + delayMs + 'ms before attempt ' + attempt);\n            await delay(delayMs);\n        }\n\n        try {\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: childXmlRequest,\n                timeout: 45000\n            });\n\n            if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);\n            xmlText = await response.text();\n            parsed = parseXmlResponse(xmlText);\n\n            const isRateLimited = parsed.errorMessage && ERROR_PATTERNS.RATE_LIMIT.test(parsed.errorMessage);\n            if (isRateLimited && attempt < RETRY_CONFIG.maxRetries) {\n                node.warn('[v63] Child ' + child.childName + ' rate limit detected on attempt ' + attempt + ', will retry');\n                lastError = parsed.errorMessage;\n                continue;\n            }\n            break;\n        } catch (fetchError) {\n            lastError = fetchError.message;\n            if (attempt >= RETRY_CONFIG.maxRetries) {\n                flow.set('lastSetAppointmentTime', Date.now());\n\n                return {\n                    childName: child.childName,\n                    success: false,\n                    message: fetchError.message,\n                    error_type: 'EXCEPTION',\n                    attempts: attempt\n                };\n            }\n        }\n    }\n\n    // Update last booking time\n    flow.set('lastSetAppointmentTime', Date.now());\n\n    // v63: Check if we exhausted retries and still got rate limited - queue for async processing\n    const finalRateLimited = parsed?.errorMessage && ERROR_PATTERNS.RATE_LIMIT.test(parsed.errorMessage);\n    if (finalRateLimited && attempt >= RETRY_CONFIG.maxRetries) {\n        const operationId = 'op-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);\n        const pendingOps = flow.get('pendingOperations') || {};\n        pendingOps[operationId] = {\n            operationType: 'SetAppointment',\n            requestPayload: {\n                patientGUID: patientGUID,\n                startTime: child.startTime,\n                scheduleViewGUID: child.scheduleViewGUID,\n                scheduleColumnGUID: '07687884-7e37-49aa-8028-d43b751c9034',\n                appointmentTypeGUID: child.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n                minutes: String(child.minutes || 45),\n                childName: child.childName,\n                note: child.note\n            },\n            uui: uui || 'unknown',\n            sessionId: sessionId || null,\n            createdAt: new Date().toISOString(),\n            attemptCount: 0,\n            maxAttempts: 10,\n            nextRetryAt: new Date().toISOString(),\n            lastError: 'Rate limited after sync retries - queued for async',\n            status: 'pending'\n        };\n        flow.set('pendingOperations', pendingOps);\n        node.warn('[v63] QUEUED child ' + child.childName + ' for async processing: ' + operationId);\n\n        return {\n            childName: child.childName,\n            success: false,\n            queued: true,\n            operationId: operationId,\n            message: 'Appointment queued for processing due to high demand',\n            error_type: 'RATE_LIMITED_QUEUED',\n            attempts: attempt\n        };\n    }\n\n    // Process the response\n    const result = parsed?.records[0]?.Result || '';\n    const childApptGUID = result.match(/Appointment GUID Added:\\s*([A-Fa-f0-9-]+)/i)?.[1];\n    const childSuccess = result.includes('Added');\n\n    if (childSuccess) {\n        // v9: Phase 4A - Invalidate cache on successful child booking\n        await invalidateBookedSlot(child.startTime, '07687884-7e37-49aa-8028-d43b751c9034');\n\n        if (child.note) {\n            await addPatientNote(patientGUID, child.note);\n        }\n        const timeParts = child.startTime.split(' ');\n        const date = timeParts[0];\n        const time = timeParts.slice(1).join(' ');\n        return {\n            childName: child.childName,\n            success: true,\n            appointmentGUID: childApptGUID,\n            startTime: child.startTime,\n            date: date,\n            time: time,\n            day: getDayName(date),\n            attempts: attempt\n        };\n    } else {\n        \n        // v9: Phase 4B - Invalidate cache on slot-taken error\n        const childErrorType = detectErrorType(parsed?.errorMessage || result);\n        if (childErrorType === 'SLOT_NOT_AVAILABLE') {\n            await invalidateBookedSlot(child.startTime, '07687884-7e37-49aa-8028-d43b751c9034');\n        }\n\n        return {\n            childName: child.childName,\n            success: false,\n            message: result || 'Booking failed',\n            error_type: childErrorType,\n            attempts: attempt\n        };\n    }\n}\n\n// v7: Booking auth validation function (crypto loaded via libs array)\nfunction validateBookingAuth(params, sessionId) {\n    const BOOKING_SECRET = env.get('bookingAuthSecret') || 'CDH-Ortho-BookingAuth-2026';\n    const bookingSessions = flow.get('bookingSessions') || {};\n    const session = bookingSessions[sessionId];\n    \n    // Check 1: Token provided?\n    if (!params.bookingAuthToken) {\n        // Backward compat: Allow if session has matching GUID from same session\n        if (session && session.patientGUID === params.patientGUID) {\n            node.warn('[v7] BookingAuth: No token but session GUID matches - ALLOWED (backward compat)');\n            return { valid: true, authorizedPatientGUID: session.patientGUID, method: 'session_match' };\n        }\n        // No token and no matching session - check if patientGUID looks valid (existing patient case)\n        if (params.patientGUID && /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(params.patientGUID)) {\n            node.warn('[v7] BookingAuth: No token but patientGUID looks valid - ALLOWED (legacy/existing patient)');\n            return { valid: true, authorizedPatientGUID: params.patientGUID, method: 'legacy' };\n        }\n        return { valid: false, error: 'BOOKING_AUTH_MISSING', message: 'No bookingAuthToken provided' };\n    }\n    \n    // Check 2: Verify token signature\n    const tokenParts = params.bookingAuthToken.split('.');\n    if (tokenParts.length !== 2) {\n        return { valid: false, error: 'BOOKING_AUTH_MALFORMED', message: 'Token format invalid' };\n    }\n    const [payloadB64, signatureB64] = tokenParts;\n    const expectedSig = crypto.createHmac('sha256', BOOKING_SECRET).update(payloadB64).digest('base64url');\n    if (signatureB64 !== expectedSig) {\n        node.warn('[v7] BookingAuth: SIGNATURE MISMATCH');\n        return { valid: false, error: 'BOOKING_AUTH_SIGNATURE_INVALID', message: 'Token signature invalid' };\n    }\n    \n    // Check 3: Parse and validate token data\n    let tokenData;\n    try {\n        tokenData = JSON.parse(Buffer.from(payloadB64, 'base64url').toString('utf8'));\n    } catch (e) {\n        return { valid: false, error: 'BOOKING_AUTH_MALFORMED', message: 'Token payload invalid' };\n    }\n    \n    // Check 4: REMOVED in v61 - Token expiration check removed\n    // Reason: Token uniqueness is already guaranteed by nonce + signature\n    // The patientGUID match (Check 5 below) ensures token validity for the correct patient\n    // This prevents false \"Token expired\" errors from stale cache entries\n    \n    // Check 5: patientGUID matches token\n    if (params.patientGUID !== tokenData.patientGUID) {\n        node.warn('[v7] BookingAuth: GUID MISMATCH! Request: ' + params.patientGUID + ', Token: ' + tokenData.patientGUID);\n        return { \n            valid: false, \n            error: 'BOOKING_AUTH_GUID_MISMATCH', \n            message: 'patientGUID does not match token - use GUID from create response',\n            correctGUID: tokenData.patientGUID \n        };\n    }\n    \n    node.warn('[v7] BookingAuth: Token validated successfully for patient ' + tokenData.patientGUID.substring(0, 8) + '...');\n    return { valid: true, authorizedPatientGUID: tokenData.patientGUID, method: 'token' };\n}\n\nasync function createAppt() {\n    const requestTimestamp = new Date().toISOString();\n    try {\n        const params = msg.payload;\n\n        // v65: Check for batch booking early (children array present)\n        const isBatchBooking = params.children && Array.isArray(params.children) && params.children.length > 0;\n\n        // v9: SLOT DEDUPLICATION - Prevent same-session double-booking (NO MUTEX - instant check only)\n        const sessionId = params.sessionId || msg.payload.sessionId || params.uui || msg.payload.uui || 'unknown-session';\n        const slotKey = isBatchBooking ? null : (params.startTime + '|' + (params.scheduleColumnGUID || '07687884-7e37-49aa-8028-d43b751c9034'));\n\n        // Check if this slot was already booked in this session (skip for batch - each child checked individually)\n        const sessionSlotBookings = flow.get('sessionSlotBookings') || {};\n        const sessionSlots = sessionSlotBookings[sessionId] || [];\n\n        if (!isBatchBooking && sessionSlots.includes(slotKey)) {\n            node.warn('[v9 SLOT_DEDUP] BLOCKED duplicate booking for slot: ' + slotKey + ' in session: ' + sessionId);\n            msg.payload = {\n                success: false,\n                message: 'This time slot was already booked in this session',\n                _debug: {\n                    error_type: 'DUPLICATE_SLOT_BLOCKED',\n                    slot_key: slotKey,\n                    session_id: sessionId,\n                    already_booked_slots: sessionSlots,\n                    timestamp: requestTimestamp\n                },\n                llm_guidance: {\n                    error_type: 'duplicate_slot_attempt',\n                    voice_response: 'I already have that time booked for another child. Let me use a different time.',\n                    action_required: 'use_next_slot_from_booking_plan',\n                    CRITICAL: 'This slot is already booked for another child. Use the NEXT slot from booking_plan.',\n                    recovery_steps: [\n                        'Check booking_plan from getGroupedApptSlots response',\n                        'Each child must use a DIFFERENT slot',\n                        'Child 1 = slot 1, Child 2 = slot 2, etc.'\n                    ]\n                }\n            };\n            return msg;\n        }\n\n        \n        \n        // v11: ATOMIC RESERVATION - Uses SET-then-verify to eliminate TOCTOU race (skip for batch)\n        // v12: Optimistic cache invalidation - remove slot so other sessions don't offer it\n        if (!isBatchBooking) {\n            node.warn('[v12] Optimistic cache invalidation for slot: ' + params.startTime);\n            await invalidateBookedSlot(params.startTime, params.scheduleColumnGUID || '07687884-7e37-49aa-8028-d43b751c9034');\n        }\n\n                // v58: Look up session cache by patientGUID (most reliable) or fallback to UUI\n        // patientGUID is usually provided in book_child requests, so use that as primary lookup\n        const bookingSessions = flow.get('bookingSessions') || {};\n        const cachedSession = (params.patientGUID && bookingSessions[params.patientGUID]) \n            || bookingSessions[params.uui] \n            || null;\n\n        if (!params.bookingAuthToken && cachedSession && cachedSession.bookingAuthToken) {\n            // v62: Only auto-inject if cache entry's patientGUID matches request (prevents stale token injection)\n            if (!cachedSession.patientGUID || cachedSession.patientGUID === params.patientGUID) {\n                params.bookingAuthToken = cachedSession.bookingAuthToken;\n                node.warn('[v57] Auto-injected bookingAuthToken from session cache');\n            } else {\n                node.warn('[v62] Skipped auto-inject - cache patientGUID (' + cachedSession.patientGUID.substring(0,8) + '...) != request (' + params.patientGUID.substring(0,8) + '...) - will use legacy auth');\n            }\n        }\n\n        if (!params.patientGUID && cachedSession && cachedSession.patientGUID) {\n            params.patientGUID = cachedSession.patientGUID;\n            node.warn('[v57] Auto-injected patientGUID from session cache');\n        }\n\n        // v58: Validate booking authorization token (AFTER session auto-inject)\n        // Use patientGUID as the session key since we now store under patientGUID\n        const authResult = validateBookingAuth(params, params.patientGUID);\n        if (!authResult.valid) {\n            node.warn('[v7] BookingAuth REJECTED: ' + authResult.error);\n            msg.payload = {\n                success: false,\n                message: authResult.message,\n                _debug: {\n                    error_type: authResult.error,\n                    received_patientGUID: params.patientGUID,\n                    correct_patientGUID: authResult.correctGUID || null,\n                    timestamp: requestTimestamp\n                },\n                llm_guidance: {\n                    error_type: 'booking_auth_failed',\n                    voice_response: 'Let me verify your information.',\n                    CRITICAL: 'Call chord_ortho_patient action=create FIRST, then use the returned patientGUID AND bookingAuthToken in book_child call',\n                    correct_patientGUID: authResult.correctGUID,\n                    recovery_steps: [\n                        '1. Call chord_ortho_patient action=create with parent info',\n                        '2. Get patientGUID and bookingAuthToken from response',\n                        '3. Call book_child with BOTH patientGUID AND bookingAuthToken from step 2'\n                    ]\n                }\n            };\n            return msg;\n        }\n        // v7: Use the authorized patientGUID (prevents mismatch attacks)\n        params.patientGUID = authResult.authorizedPatientGUID;\n        node.warn('[v7] Using authorized patientGUID: ' + params.patientGUID.substring(0, 8) + '... (method: ' + authResult.method + ')');\n\n        // v63: CHILDREN ARRAY SUPPORT - Process multiple children in one call\n    // Uses shared bookChildWithRetry helper for consistent rate limiting and async queue handling\n    if (params.children && Array.isArray(params.children) && params.children.length > 0) {\n        node.warn('[v71] Processing ' + params.children.length + ' children in batch booking (INDIVIDUAL_PATIENT_PER_PERSON)');\n\n        // v71: Validate each child has patientGUID in INDIVIDUAL_PATIENT_PER_PERSON model\n        for (let i = 0; i < params.children.length; i++) {\n            if (!params.children[i].patientGUID) {\n                node.warn('[v71] WARNING: Child ' + (i+1) + ' (' + (params.children[i].childName || 'unknown') + ') has no patientGUID - will use parent GUID as fallback');\n            }\n        }\n\n        const results = [];\n        let allSuccess = true;\n        let anyQueued = false;\n\n        for (let i = 0; i < params.children.length; i++) {\n            const child = params.children[i];\n            node.warn('[v63] Processing child ' + (i + 1) + '/' + params.children.length + ': ' + child.childName);\n\n            // Validate child has required fields\n            if (!child.startTime || !child.scheduleViewGUID) {\n                results.push({\n                    childName: child.childName,\n                    success: false,\n                    message: 'Missing required fields (startTime or scheduleViewGUID)',\n                    error_type: 'VALIDATION_ERROR'\n                });\n                allSuccess = false;\n                continue;\n            }\n\n            // v63: Use shared helper for booking with retry and async queue fallback\n            // v12: Optimistic cache invalidation before booking attempt\n            node.warn('[v12] Optimistic cache invalidation for child: ' + child.childName + ' slot: ' + child.startTime);\n            await invalidateBookedSlot(child.startTime, child.scheduleColumnGUID || '07687884-7e37-49aa-8028-d43b751c9034');\n\n            const bookResult = await bookChildWithRetry(\n                child.patientGUID || params.patientGUID,\n                child,\n                msg.payload.uui,\n                msg.payload.sessionId\n            );\n\n            results.push(bookResult);\n\n            if (!bookResult.success) {\n                allSuccess = false;\n                if (bookResult.queued) {\n                    anyQueued = true;\n                    node.warn('[v63] Child ' + child.childName + ' queued for async processing');\n                } else {\n                    node.warn('[v63] Child ' + child.childName + ' booking FAILED: ' + bookResult.message);\n                }\n            } else {\n                node.warn('[v63] Child ' + child.childName + ' booked successfully: ' + bookResult.appointmentGUID);\n            }\n        }\n\n        // Build combined response\n        const successfulBookings = results.filter(r => r.success);\n        const failedBookings = results.filter(r => !r.success && !r.queued);\n        const queuedBookings = results.filter(r => r.queued);\n\n        msg.payload = {\n            success: allSuccess,\n            totalChildren: params.children.length,\n            successfulBookings: successfulBookings.length,\n            failedBookings: failedBookings.length,\n            queuedBookings: queuedBookings.length,\n            results: results,\n            _debug: {\n                batch_mode: true,\n                children_processed: params.children.length,\n                any_queued: anyQueued,\n                timestamp: requestTimestamp,\n                response_timestamp: new Date().toISOString()\n            },\n            llm_guidance: {\n                timestamp: new Date().toISOString(),\n                current_state: allSuccess ? 'CONFIRMATION' : (anyQueued ? 'BOOKING_QUEUED' : 'PARTIAL_SUCCESS'),\n                action_required: 'confirm_all_bookings_to_caller',\n                voice_response: allSuccess\n                    ? 'All appointments are confirmed! ' + successfulBookings.map(b => b.childName + ' on ' + b.day + ' ' + b.date + ' at ' + b.time).join('. And ')\n                    : (queuedBookings.length > 0\n                        ? 'I was able to book ' + successfulBookings.length + ' appointments. ' + queuedBookings.length + ' appointment' + (queuedBookings.length > 1 ? 's are' : ' is') + ' being processed and you will receive confirmation shortly.'\n                        : 'I was able to book ' + successfulBookings.length + ' of ' + params.children.length + ' appointments. ' +\n                          (failedBookings.length > 0 ? failedBookings.map(f => f.childName + ' could not be scheduled').join('. ') : '')),\n                chain_of_action: [\n                    '1. Confirm each successful booking with the caller',\n                    '2. For any queued bookings, reassure caller they will receive confirmation shortly',\n                    '3. For any failed bookings, offer alternative times',\n                    '4. Ask if they need the office address',\n                    '5. Mention legal guardian requirement',\n                    '6. Ask if there is anything else'\n                ],\n                successful_children: successfulBookings.map(b => b.childName),\n                queued_children: queuedBookings.map(q => q.childName),\n                failed_children: failedBookings.map(f => ({ name: f.childName, reason: f.message }))\n            }\n        };\n        return msg;\n    }\n\n    // Enhanced input validation with debugging\n        const missingFields = [];\n        if (!params.patientGUID) missingFields.push('patientGUID');\n        if (!params.startTime) missingFields.push('startTime');\n        if (!params.scheduleViewGUID) missingFields.push('scheduleViewGUID');\n        if (!params.scheduleColumnGUID) missingFields.push('scheduleColumnGUID');\n\n        if (missingFields.length > 0) {\n            const errorMsg = `Missing required fields: ${missingFields.join(', ')}`;\n            node.warn('CreateAppt validation failed: ' + errorMsg);\n            msg.payload = {\n                success: false,\n                message: errorMsg,\n                _debug: {\n                    error_type: 'VALIDATION_ERROR',\n                    missing_fields: missingFields,\n                    received_params: {\n                        patientGUID: params.patientGUID ? params.patientGUID.substring(0, 8) + '...' : null,\n                        startTime: params.startTime,\n                        scheduleViewGUID: params.scheduleViewGUID ? 'present' : null,\n                        scheduleColumnGUID: params.scheduleColumnGUID ? 'present' : null\n                    },\n                    timestamp: requestTimestamp\n                },\n                llm_guidance: createLlmGuidance('missing_slot_data')\n            };\n            return msg;\n        }\n\n        const xmlRequest = buildXmlRequest('SetAppointment', {\n            PatientGUID: params.patientGUID,\n            StartTime: params.startTime,\n            ScheduleViewGUID: params.scheduleViewGUID,\n            ScheduleColumnGUID: '07687884-7e37-49aa-8028-d43b751c9034', // CHAIR 8 - HARDCODED\n            AppointmentTypeGUID: params.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n            Minutes: String(params.minutes || 45),\n            VendorUserName: CLOUD9.vendorUserName\n        });\n\n        node.warn('Calling Cloud9 SetAppointment for patient: ' + params.patientGUID.substring(0, 8) + '...');\n\n        // v4 Layer 1: Automatic spacing - prevent rate limits by spacing consecutive calls\n        const lastBookingTime = flow.get('lastSetAppointmentTime') || 0;\n        const elapsed = Date.now() - lastBookingTime;\n        let spacingWaitMs = 0;\n\n        if (elapsed < BOOKING_SPACING_MS && lastBookingTime > 0) {\n            spacingWaitMs = BOOKING_SPACING_MS - elapsed;\n            node.warn(`Spacing: waiting ${spacingWaitMs}ms before SetAppointment (last call ${elapsed}ms ago)`);\n            await delay(spacingWaitMs);\n        }\n\n        // v4 Layer 2: Progressive retry with increasing delays\n        let attempt = 0;\n        let lastError = null;\n        let parsed = null;\n        let xmlText = '';\n\n        while (attempt < RETRY_CONFIG.maxRetries) {\n            attempt++;\n\n            // v4: Progressive delay before retry (not before first attempt)\n            if (attempt > 1) {\n                const delayMs = RETRY_CONFIG.retryDelays[attempt - 2] || 15000;\n                node.warn(`Rate limit retry: waiting ${delayMs}ms before attempt ${attempt}`);\n                await delay(delayMs);\n            }\n\n            try {\n                const response = await fetch(CLOUD9.endpoint, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/xml' },\n                    body: xmlRequest,\n                    timeout: 45000\n                });\n\n                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n                xmlText = await response.text();\n                parsed = parseXmlResponse(xmlText);\n\n                // v4: Check for rate limit error in response\n                const isRateLimited = parsed.errorMessage && ERROR_PATTERNS.RATE_LIMIT.test(parsed.errorMessage);\n\n                if (isRateLimited && attempt < RETRY_CONFIG.maxRetries) {\n                    node.warn(`Rate limit detected on attempt ${attempt}, will retry with progressive delay`);\n                    lastError = parsed.errorMessage;\n                    continue;  // Retry after delay\n                }\n\n                // Success or non-rate-limit error - exit retry loop\n                break;\n\n            } catch (fetchError) {\n                lastError = fetchError.message;\n                if (attempt >= RETRY_CONFIG.maxRetries) throw fetchError;\n            }\n        }\n\n        // v5: Check if we exhausted retries and still got rate limited - queue for async processing\n        const finalRateLimited = parsed?.errorMessage && ERROR_PATTERNS.RATE_LIMIT.test(parsed.errorMessage);\n        if (finalRateLimited && attempt >= RETRY_CONFIG.maxRetries) {\n            const operationId = `op-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n\n            // Store in flow context for async retry by timer loop\n            const pendingOps = flow.get('pendingOperations') || {};\n            pendingOps[operationId] = {\n                operationType: 'SetAppointment',\n                requestPayload: {\n                    patientGUID: params.patientGUID,\n                    startTime: params.startTime,\n                    scheduleViewGUID: params.scheduleViewGUID,\n                    scheduleColumnGUID: '07687884-7e37-49aa-8028-d43b751c9034', // CHAIR 8\n                    appointmentTypeGUID: params.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n                    minutes: String(params.minutes || 45),\n                    childName: params.childName,\n                    note: params.note  // v6: Include note for async processing\n                },\n                uui: msg.payload.uui || 'unknown',\n                sessionId: msg.payload.sessionId || null,\n                createdAt: new Date().toISOString(),\n                attemptCount: 0,\n                maxAttempts: 10,\n                nextRetryAt: new Date().toISOString(), // Ready immediately\n                lastError: 'Rate limited after sync retries - queued for async',\n                status: 'pending'\n            };\n            flow.set('pendingOperations', pendingOps);\n\n            node.warn(`QUEUED rate-limited SetAppointment for async processing: ${operationId}`);\n\n            msg.payload = {\n                success: false,\n                queued: true,\n                operationId: operationId,\n                message: 'Appointment request queued for processing due to high demand',\n                _debug: {\n                    error_type: 'RATE_LIMITED_QUEUED',\n                    sync_attempts: attempt,\n                    last_error: parsed.errorMessage,\n                    request_params: {\n                        patientGUID: params.patientGUID,\n                        startTime: params.startTime,\n                        scheduleViewGUID: params.scheduleViewGUID,\n                        scheduleColumnGUID: params.scheduleColumnGUID\n                    },\n                    timestamp: requestTimestamp\n                },\n                llm_guidance: createLlmGuidance('booking_queued')\n            };\n            return msg;\n        }\n\n        // v4: Update last booking time after API call completes\n        flow.set('lastSetAppointmentTime', Date.now());\n\n        node.warn(`SetAppointment completed after ${attempt} attempt(s)${spacingWaitMs > 0 ? ` (spacing wait: ${spacingWaitMs}ms)` : ''}`)\n\n        const result = parsed.records[0]?.Result || '';\n        const apptGUID = result.match(/Appointment GUID Added:\\s*([A-Fa-f0-9-]+)/i)?.[1];\n        const success = result.includes('Added');\n        const errorType = success ? null : detectErrorType(parsed.errorMessage || result);\n\n        const timeParts = params.startTime.split(' ');\n        const date = timeParts[0];\n        const time = timeParts.slice(1).join(' ');\n\n        // Log the actual Cloud9 response for debugging\n        if (!success) {\n            node.warn(`CreateAppt FAILED - Cloud9 Result: ${result || '(empty)'} | ErrorType: ${errorType}`);\n        }\n\n        // v6: Add note to patient if appointment was created successfully and note was provided\n        let noteResult = { skipped: true };\n        if (success && params.note) {\n            noteResult = await addPatientNote(params.patientGUID, params.note);\n        }\n\n        // v9: Phase 4A - Invalidate cache on successful booking\n        if (success) {\n            await invalidateBookedSlot(params.startTime, '07687884-7e37-49aa-8028-d43b751c9034');\n        }\n\n            // v9: SLOT_DEDUP - Track this slot as booked in session\n            const updatedSessionBookings = flow.get('sessionSlotBookings') || {};\n            const updatedSessionSlots = updatedSessionBookings[sessionId] || [];\n            if (!updatedSessionSlots.includes(slotKey)) {\n                updatedSessionSlots.push(slotKey);\n                updatedSessionBookings[sessionId] = updatedSessionSlots;\n                flow.set('sessionSlotBookings', updatedSessionBookings);\n                node.warn('[v9 SLOT_DEDUP] Tracked slot as booked: ' + slotKey + ' in session: ' + sessionId);\n\n\n            }\n\n\n        // v9: Phase 4B - Invalidate cache on slot-taken error (slot was booked by someone else)\n        if (!success && errorType === 'SLOT_NOT_AVAILABLE') {\n            await invalidateBookedSlot(params.startTime, '07687884-7e37-49aa-8028-d43b751c9034');\n        }\n\n        // Determine appropriate guidance based on error type\n        let guidance;\n        if (success) {\n            guidance = createLlmGuidance('booking_success', {\n                childName: params.childName || 'your child',\n                date: date,\n                time: time,\n                day: getDayName(date)\n            });\n        } else if (errorType === 'PATIENT_NOT_FOUND') {\n            guidance = createLlmGuidance('patient_not_found', { canRetry: true });\n        } else {\n            guidance = createLlmGuidance('booking_failed', {\n                childName: params.childName || 'your child',\n                date: date,\n                time: time,\n                day: getDayName(date),\n                canRetry: errorType === 'SLOT_NOT_AVAILABLE'\n            });\n        }\n\n        msg.payload = {\n            success: success,\n            appointmentGUID: apptGUID,\n            message: result,\n            noteAdded: !noteResult.skipped && noteResult.success,\n            _debug: {\n                cloud9_result: result,\n                cloud9_status: parsed.status,\n                cloud9_error_message: parsed.errorMessage,\n                error_type: errorType,\n                attempts: attempt,\n                retried: attempt > 1,\n                spacing_wait_ms: spacingWaitMs,\n                note_result: noteResult,\n                request_params: {\n                    patientGUID: params.patientGUID,\n                    startTime: params.startTime,\n                    scheduleViewGUID: params.scheduleViewGUID,\n                    scheduleColumnGUID: '07687884-7e37-49aa-8028-d43b751c9034', // CHAIR 8\n                    note: params.note ? params.note.substring(0, 50) + '...' : null\n                },\n                timestamp: requestTimestamp,\n                response_timestamp: new Date().toISOString()\n            },\n            llm_guidance: guidance\n        };\n\n        return msg;\n    } catch (error) {\n        node.error('Create appt error: ' + error.message, msg);\n        const isTimeout = ['timeout', 'ETIMEDOUT', 'ECONNRESET'].some(e => error.message.toLowerCase().includes(e.toLowerCase()));\n\n        msg.payload = {\n            success: false,\n            message: error.message,\n            _debug: {\n                error_type: isTimeout ? 'TIMEOUT' : 'EXCEPTION',\n                error_message: error.message,\n                timestamp: requestTimestamp\n            },\n            llm_guidance: {\n                ...createLlmGuidance('booking_failed', { canRetry: false }),\n                error_type: isTimeout ? 'timeout' : 'api_error',\n                voice_response: \"I want to connect you with a specialist who can assist you. One moment while I transfer your call.\",\n                action_required: \"transfer_to_agent\",\n                transfer_reason: isTimeout ? \"scheduling_timeout\" : \"api_failure\",\n                CRITICAL: \"Do NOT mention error, timeout, or system problems to caller. Transfer gracefully.\",\n                prohibited_responses: [\"error\", \"timeout\", \"problem\", \"issue\", \"failed\", \"system is down\", \"technical difficulties\", \"something went wrong\"]\n            }\n        };\n        return msg;\n    }\n}\n\nreturn createAppt();\n",
    "outputs": 1,
    "timeout": 90,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      },
      {
        "var": "crypto",
        "module": "crypto"
      }
    ],
    "x": 800,
    "y": 2000,
    "wires": [
      [
        "http-out-create-appt",
        "debug-create-appt-out"
      ]
    ]
  },
  {
    "id": "debug-create-appt-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-appt",
    "name": "Egress CreateAppt",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1110,
    "y": 1920,
    "wires": []
  },
  {
    "id": "http-out-create-appt",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-create-appt",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 2000,
    "wires": []
  },
  {
    "id": "inject-cancel-appt",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-cancel-appt",
    "name": "Test: Cancel Appt (needs real GUID)",
    "props": [
      {
        "p": "payload.appointmentGUID",
        "v": "GET_FROM_CREATE_APPT_RESPONSE",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "x": 150,
    "y": 2120,
    "wires": [
      [
        "func-cancel-appt",
        "debug-cancel-appt-in"
      ]
    ]
  },
  {
    "id": "http-in-cancel-appt",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-cancel-appt",
    "name": "",
    "url": "/chord/ortho-prd/cancelAppt",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 200,
    "y": 2200,
    "wires": [
      [
        "func-cancel-appt",
        "debug-cancel-appt-in"
      ]
    ]
  },
  {
    "id": "debug-cancel-appt-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-cancel-appt",
    "name": "Ingress CancelAppt",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 620,
    "y": 2120,
    "wires": []
  },
  {
    "id": "func-cancel-appt",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-cancel-appt",
    "name": "cancelAppt",
    "func": "// Ortho Cancel Appointment - Calls Cloud9 SetAppointmentStatusCanceled\n// v10: Phase 4G - Added revalidateSlot() to restore cancelled slots to cache\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace'),\n    defaultLocationGUID: env.get('defaultLocationGUID')\n};\n\n// v10: Redis configuration for cache revalidation\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\nconst DEFAULT_LOCATION_GUID = CLOUD9.defaultLocationGUID || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\n// v10: Phase 4G - Restore cancelled slot to cache\nasync function revalidateSlot(startTime, scheduleViewGUID, minutes) {\n    const TIERS = [1, 2, 3];\n    const locationGUID = DEFAULT_LOCATION_GUID;\n    const slotDateMatch = startTime ? startTime.match(/(\\\\d{1,2}\\\\/\\\\d{1,2}\\\\/\\\\d{4})/) : null;\n    if (!slotDateMatch) {\n        node.warn('[v10] CACHE_REVALIDATE: Cannot parse date from startTime: ' + startTime);\n        return;\n    }\n    const slotDateStr = slotDateMatch[1];\n    const slotDate = new Date(slotDateStr);\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const daysOut = Math.floor((slotDate - today) / (24 * 60 * 60 * 1000));\n    const tierDays = { 1: 30, 2: 60, 3: 90 };\n    node.warn('[v10] CACHE_REVALIDATE: Restoring slot ' + startTime + ' (' + daysOut + ' days out)');\n    for (const tier of TIERS) {\n        if (daysOut > tierDays[tier] || daysOut < 0) continue;\n        const redisKey = 'SlotCache-' + locationGUID + '-Tier' + tier;\n        try {\n            const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(redisKey);\n            const response = await fetch(getUrl, { method: 'GET', headers: { 'Authorization': REDIS_AUTH }, timeout: 5000 });\n            if (!response.ok) { node.warn('[v10] CACHE_REVALIDATE: GET failed for Tier ' + tier); continue; }\n            const text = await response.text();\n            if (!text || text === 'null') { continue; }\n            const cacheData = JSON.parse(text);\n            const exists = (cacheData.slots || []).some(s => (s.StartTime || s.startTime) === startTime && (s.ScheduleColumnGUID || s.scheduleColumnGUID) === CHAIR_8_GUID);\n            if (exists) { node.warn('[v10] CACHE_REVALIDATE: Slot already exists in Tier ' + tier); continue; }\n            const restoredSlot = { StartTime: startTime, startTime: startTime, ScheduleColumnGUID: CHAIR_8_GUID, scheduleColumnGUID: CHAIR_8_GUID, ScheduleViewGUID: scheduleViewGUID || '4c9e9333-4951-4eb0-8d97-e1ad83ef422d', scheduleViewGUID: scheduleViewGUID || '4c9e9333-4951-4eb0-8d97-e1ad83ef422d', Minutes: minutes || '45', minutes: minutes || '45', LocationGUID: locationGUID, AppointmentTypeGUID: 'f6c20c35-9abb-47c2-981a-342996016705', _restoredAt: new Date().toISOString(), _restoredReason: 'cancellation' };\n            cacheData.slots = cacheData.slots || [];\n            cacheData.slots.push(restoredSlot);\n            cacheData.slotCount = cacheData.slots.length;\n            cacheData.lastRestoredSlot = { startTime, at: new Date().toISOString() };\n            cacheData.slots.sort((a, b) => new Date(a.StartTime || a.startTime) - new Date(b.StartTime || b.startTime));\n            const setUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n            const setResponse = await fetch(setUrl, { method: 'POST', headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' }, body: JSON.stringify({ key: redisKey, value: cacheData }), timeout: 5000 });\n            if (setResponse.ok) { node.warn('[v10] CACHE_REVALIDATE: Restored slot to Tier ' + tier + ' (count: ' + cacheData.slotCount + ')'); }\n        } catch (e) { node.warn('[v10] CACHE_REVALIDATE: Error for Tier ' + tier + ' (non-fatal): ' + e.message); }\n    }\n}\n\nasync function cancelAppt() {\n    try {\n        const appointmentGUID = msg.payload.appointmentGUID;\n        const startTime = msg.payload.startTime;\n        const scheduleViewGUID = msg.payload.scheduleViewGUID;\n        const minutes = msg.payload.minutes;\n        if (!appointmentGUID) throw new Error('appointmentGUID required');\n        const xmlRequest = buildXmlRequest('SetAppointmentStatusCanceled', { apptGUID: appointmentGUID });\n        node.warn('[v10] Calling Cloud9 SetAppointmentStatusCanceled');\n        const response = await fetch(CLOUD9.endpoint, { method: 'POST', headers: { 'Content-Type': 'application/xml' }, body: xmlRequest, timeout: 45000 });\n        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        const success = !parsed.records[0]?.Result?.toLowerCase().includes('error');\n        if (success && startTime) {\n            node.warn('[v10] Cancellation successful, restoring slot to cache...');\n            await revalidateSlot(startTime, scheduleViewGUID, minutes);\n        }\n        msg.payload = { success: success, message: parsed.records[0]?.Result || 'Cancelled', _cacheRevalidated: success && startTime ? true : false };\n        return msg;\n    } catch (error) {\n        node.error('Cancel appt error: ' + error.message, msg);\n        msg.payload = { error: 'Failed to cancel appointment', message: error.message, timestamp: new Date().toISOString() };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn cancelAppt();",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 800,
    "y": 2200,
    "wires": [
      [
        "http-out-cancel-appt",
        "debug-cancel-appt-out"
      ]
    ]
  },
  {
    "id": "debug-cancel-appt-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-cancel-appt",
    "name": "Egress CancelAppt",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 1110,
    "y": 2120,
    "wires": []
  },
  {
    "id": "http-out-cancel-appt",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-cancel-appt",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 2200,
    "wires": []
  },
  {
    "id": "inject-retry-timer",
    "type": "inject",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-retry-queue",
    "name": "Retry Timer (30s)",
    "props": [
      {
        "p": "payload",
        "v": "",
        "vt": "date"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": true,
    "onceDelay": "10",
    "topic": "",
    "x": 140,
    "y": 2340,
    "wires": [
      [
        "func-retry-processor"
      ]
    ]
  },
  {
    "id": "func-retry-processor",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-retry-queue",
    "name": "processRetryQueue",
    "func": "// Async Retry Queue Processor - Runs every 30s via inject timer\n// v3: Added error handling, logging, env var guards\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace'),\n    vendorUserName: env.get('vendorUserName')\n};\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nasync function processQueue() {\n  try {\n    node.warn('RETRY PROCESSOR: tick at ' + new Date().toISOString());\n\n    // Guard: check required env vars\n    if (!CLOUD9.endpoint || !CLOUD9.clientId || !CLOUD9.userName || !CLOUD9.password) {\n        node.error('RETRY PROCESSOR: Missing Cloud9 env vars! endpoint=' + !!CLOUD9.endpoint + ' clientId=' + !!CLOUD9.clientId);\n        node.status({ fill: 'red', shape: 'ring', text: 'Missing env vars' });\n        return null;\n    }\n\n    const pendingOps = flow.get('pendingOperations') || {};\n    const now = Date.now();\n\n    // Count stats for status display\n    const stats = { pending: 0, processing: 0, completed: 0, failed: 0 };\n    for (const op of Object.values(pendingOps)) {\n        stats[op.status] = (stats[op.status] || 0) + 1;\n    }\n\n    // Find next operation ready for retry\n    let targetOp = null;\n    let targetId = null;\n\n    for (const [id, op] of Object.entries(pendingOps)) {\n        if (op.status === 'pending' && op.attemptCount < op.maxAttempts) {\n            const nextRetry = op.nextRetryAt ? new Date(op.nextRetryAt).getTime() : 0;\n            if (now >= nextRetry) {\n                targetOp = op;\n                targetId = id;\n                break;\n            }\n        }\n    }\n\n    if (!targetOp) {\n        node.status({ fill: 'grey', shape: 'ring', text: `Idle - P:${stats.pending} C:${stats.completed} F:${stats.failed}` });\n        return null;\n    }\n\n    node.warn('RETRY PROCESSOR: Found op ' + targetId + ' type=' + targetOp.operationType + ' attempts=' + targetOp.attemptCount);\n\n    // Mark as processing\n    targetOp.status = 'processing';\n    targetOp.attemptCount++;\n    pendingOps[targetId] = targetOp;\n    flow.set('pendingOperations', pendingOps);\n\n    node.status({ fill: 'blue', shape: 'dot', text: `Processing ${targetId.slice(-8)} (attempt ${targetOp.attemptCount})` });\n    node.warn(`RETRY QUEUE: Processing ${targetId} (attempt ${targetOp.attemptCount}/${targetOp.maxAttempts})`);\n\n    // Build Cloud9 XML request based on operation type\n    let xmlRequest;\n    \n    if (targetOp.operationType === 'SetPatient') {\n        // v67: SetPatient uses pre-built XML body from createPatient\n        xmlRequest = targetOp.requestPayload.xmlBody;\n        node.warn('RETRY QUEUE: Using stored SetPatient XML for ' + targetId);\n    } else {\n        // Default: SetAppointment (original behavior)\n        const params = targetOp.requestPayload;\n        xmlRequest = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GetDataRequest xmlns=\"' + CLOUD9.namespace + '\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <ClientID>' + CLOUD9.clientId + '</ClientID>\n    <UserName>' + CLOUD9.userName + '</UserName>\n    <Password>' + escapeXml(CLOUD9.password) + '</Password>\n    <Procedure>SetAppointment</Procedure>\n    <Parameters>\n        <PatientGUID>' + params.patientGUID + '</PatientGUID>\n        <StartTime>' + params.startTime + '</StartTime>\n        <ScheduleViewGUID>' + params.scheduleViewGUID + '</ScheduleViewGUID>\n        <ScheduleColumnGUID>' + params.scheduleColumnGUID + '</ScheduleColumnGUID>\n        <AppointmentTypeGUID>' + params.appointmentTypeGUID + '</AppointmentTypeGUID>\n        <Minutes>' + params.minutes + '</Minutes>\n        <VendorUserName>' + CLOUD9.vendorUserName + '</VendorUserName>\n    </Parameters>\n</GetDataRequest>';\n    }\n\n\n\n    try {\n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 45000\n        });\n\n        const xmlText = await response.text();\n\n        // Detect success based on operation type\n        const isRateLimit = /too many requests|rate limit/i.test(xmlText) || (!xmlText.trim());\n        let isSuccess = false;\n        let resultGUID = null;\n        let eventPayload = null;\n\n        if (targetOp.operationType === 'SetPatient') {\n            const patientMatch = xmlText.match(/Patient Added:s*([A-Fa-f0-9-]+)/i);\n            isSuccess = !!patientMatch;\n            resultGUID = patientMatch ? patientMatch[1] : null;\n            if (isSuccess) {\n                // Update session cache with new patient GUID\n                const rp = targetOp.requestPayload;\n                const sessions = flow.get('bookingSessions') || {};\n                if (rp.sessionId && rp.sessionId !== 'unknown') {\n                    sessions[rp.sessionId] = sessions[rp.sessionId] || {};\n                    if (rp.isChild) {\n                        // For child, just log - parent session stays\n                        node.warn('RETRY QUEUE: Child patient created: ' + resultGUID);\n                    } else {\n                        sessions[rp.sessionId].patientGUID = resultGUID;\n                        sessions[rp.sessionId].familyId = rp.familyId;\n                    }\n                    flow.set('bookingSessions', sessions);\n                }\n                eventPayload = {\n                    event: 'queue_success',\n                    operationType: 'SetPatient',\n                    operationId: targetId,\n                    patientGUID: resultGUID,\n                    patientName: rp.patientFirstName + ' ' + rp.patientLastName,\n                    isChild: rp.isChild,\n                    familyId: rp.familyId,\n                    attempts: targetOp.attemptCount\n                };\n            }\n        } else {\n            // SetAppointment (original)\n            const apptGuidMatch = xmlText.match(/Appointment GUID Added:s*([a-f0-9-]+)/i);\n            isSuccess = /<ResponseStatus>Success</ResponseStatus>/i.test(xmlText) && !!apptGuidMatch;\n            resultGUID = apptGuidMatch ? apptGuidMatch[1] : null;\n            if (isSuccess) {\n                const params = targetOp.requestPayload;\n                eventPayload = {\n                    event: 'queue_success',\n                    operationType: 'SetAppointment',\n                    operationId: targetId,\n                    appointmentGUID: resultGUID,\n                    childName: params.childName,\n                    startTime: params.startTime,\n                    attempts: targetOp.attemptCount\n                };\n            }\n        }\n\n        if (isSuccess && resultGUID) {\n            targetOp.status = 'completed';\n            targetOp.result = targetOp.operationType === 'SetPatient' \n                ? { patientGUID: resultGUID } \n                : { appointmentGUID: resultGUID };\n            targetOp.completedAt = new Date().toISOString();\n            pendingOps[targetId] = targetOp;\n            flow.set('pendingOperations', pendingOps);\n            node.status({ fill: 'green', shape: 'dot', text: 'Completed ' + targetId.slice(-8) });\n            node.warn('RETRY QUEUE SUCCESS: ' + targetId + ' completed - GUID: ' + resultGUID);\n            msg.payload = eventPayload;\n            return msg;\n        } else if (isRateLimit) {\n            // Still rate limited - schedule retry with exponential backoff\n            const backoffMs = Math.min(300000, 10000 * Math.pow(2, targetOp.attemptCount)); // Max 5 min\n            targetOp.status = 'pending';\n            targetOp.nextRetryAt = new Date(now + backoffMs).toISOString();\n            targetOp.lastError = 'Rate limited';\n            pendingOps[targetId] = targetOp;\n            flow.set('pendingOperations', pendingOps);\n\n            node.status({ fill: 'yellow', shape: 'ring', text:  });\n            node.warn();\n\n        } else {\n            // Other error - check if should retry or fail\n            const errorMsg = xmlText.substring(0, 200);\n            targetOp.lastError = errorMsg;\n\n            if (targetOp.attemptCount >= targetOp.maxAttempts) {\n                targetOp.status = 'failed';\n                targetOp.failedAt = new Date().toISOString();\n                node.error();\n            } else {\n                targetOp.status = 'pending';\n                targetOp.nextRetryAt = new Date(now + 30000).toISOString(); // Retry in 30s\n                node.warn();\n            }\n            pendingOps[targetId] = targetOp;\n            flow.set('pendingOperations', pendingOps);\n        }\n\n    } catch (error) {\n        // Network/timeout error - schedule retry with backoff\n        targetOp.lastError = error.message;\n\n        if (targetOp.attemptCount >= targetOp.maxAttempts) {\n            targetOp.status = 'failed';\n            targetOp.failedAt = new Date().toISOString();\n            node.error(`RETRY QUEUE FAILED: ${targetId} - ${error.message}`);\n        } else {\n            targetOp.status = 'pending';\n            const backoffMs = Math.min(300000, 10000 * Math.pow(2, targetOp.attemptCount));\n            targetOp.nextRetryAt = new Date(now + backoffMs).toISOString();\n            node.warn(`RETRY QUEUE: ${targetId} network error, retry in ${Math.round(backoffMs/1000)}s`);\n        }\n        pendingOps[targetId] = targetOp;\n        flow.set('pendingOperations', pendingOps);\n\n        node.status({ fill: 'red', shape: 'ring', text: `Error: ${error.message.slice(0, 30)}` });\n    }\n\n    return null;\n  } catch (outerErr) {\n    node.error('RETRY PROCESSOR CRASH: ' + (outerErr.message || outerErr));\n    node.status({ fill: 'red', shape: 'ring', text: 'CRASH: ' + String(outerErr.message || outerErr).slice(0, 30) });\n    return null;\n  }\n}\n\nreturn processQueue().catch(err => { node.error('RETRY PROCESSOR UNHANDLED: ' + err.message); return null; });",
    "outputs": 1,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 420,
    "y": 2340,
    "wires": [
      [
        "debug-retry-queue"
      ]
    ]
  },
  {
    "id": "debug-retry-queue",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-retry-queue",
    "name": "Retry Queue Events",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 690,
    "y": 2340,
    "wires": []
  },
  {
    "id": "http-in-queue-status",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-retry-queue",
    "name": "",
    "url": "/chord/ortho-prd/queue-status",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 200,
    "y": 2420,
    "wires": [
      [
        "func-queue-status"
      ]
    ]
  },
  {
    "id": "func-queue-status",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-retry-queue",
    "name": "getQueueStatus",
    "func": "// Queue Status Endpoint - Returns stats and operations list\nconst pendingOps = flow.get('pendingOperations') || {};\nconst stats = {\n    total: Object.keys(pendingOps).length,\n    pending: 0,\n    processing: 0,\n    completed: 0,\n    failed: 0,\n    operations: []\n};\n\nfor (const [id, op] of Object.entries(pendingOps)) {\n    stats[op.status] = (stats[op.status] || 0) + 1;\n    stats.operations.push({\n        id: id,\n        status: op.status,\n        attempts: op.attemptCount,\n        maxAttempts: op.maxAttempts,\n        createdAt: op.createdAt,\n        nextRetryAt: op.nextRetryAt,\n        completedAt: op.completedAt,\n        failedAt: op.failedAt,\n        lastError: op.lastError,\n        result: op.result,\n        childName: op.requestPayload?.childName,\n        startTime: op.requestPayload?.startTime\n    });\n}\n\n// Sort operations: pending first, then by createdAt\nstats.operations.sort((a, b) => {\n    if (a.status === 'pending' && b.status !== 'pending') return -1;\n    if (b.status === 'pending' && a.status !== 'pending') return 1;\n    return new Date(b.createdAt) - new Date(a.createdAt);\n});\n\nmsg.payload = stats;\nreturn msg;",
    "outputs": 1,
    "timeout": 5,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 480,
    "y": 2420,
    "wires": [
      [
        "http-out-queue-status"
      ]
    ]
  },
  {
    "id": "http-out-queue-status",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-retry-queue",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 730,
    "y": 2420,
    "wires": []
  },
  {
    "id": "slot-cache-test-tab",
    "type": "tab",
    "label": "Slot-Cache-Test",
    "disabled": false,
    "info": "Test harness for slot prefetch caching - Phase 1 validation",
    "env": []
  },
  {
    "id": "grp-slot-cache-test",
    "type": "group",
    "z": "slot-cache-test-tab",
    "name": "Slot Cache Test Endpoints",
    "style": {
      "label": true,
      "fill": "#ffcc00",
      "color": "#000000"
    },
    "nodes": [
      "http-in-cache-prefetch",
      "func-cache-prefetch",
      "http-out-cache-prefetch",
      "http-in-cache-status",
      "func-cache-status",
      "http-out-cache-status",
      "http-in-cache-query",
      "func-cache-query",
      "http-out-cache-query",
      "http-in-cache-clear",
      "func-cache-clear",
      "http-out-cache-clear",
      "debug-cache-ops"
    ],
    "x": 14,
    "y": 19,
    "w": 1012,
    "h": 422
  },
  {
    "id": "http-in-cache-prefetch",
    "type": "http in",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "url": "/test/slot-cache/prefetch",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 170,
    "y": 80,
    "wires": [
      [
        "func-cache-prefetch",
        "debug-cache-ops"
      ]
    ]
  },
  {
    "id": "func-cache-prefetch",
    "type": "function",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "prefetchSlots",
    "func": "// Slot Cache Test - PREFETCH endpoint\n// Fetches slots from Cloud9 and stores in flow context cache\n// v1: Initial test harness implementation\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx',\n    clientId: 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    userName: 'Intelepeer',\n    password: '$#1Nt-p33R-AwS#$',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    defaultLocationGUID: '1fef9297-7c8b-426b-b0d1-f2275136e48b'\n};\n\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction buildCacheKey(locationGUID, startDate, endDate) {\n    const normalizeDate = d => d.replace(/\\//g, '');\n    return `${locationGUID}_${normalizeDate(startDate)}_${normalizeDate(endDate)}`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function prefetchSlots() {\n    const startTime = Date.now();\n    const params = msg.payload;\n    \n    // Default dates: today to +30 days\n    const today = new Date();\n    const defaultStart = formatDate(today);\n    const defaultEnd = formatDate(new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000));\n    \n    const startDate = params.startDate || defaultStart;\n    const endDate = params.endDate || defaultEnd;\n    const locationGUID = params.locationGUID || CLOUD9.defaultLocationGUID;\n    \n    const cacheKey = buildCacheKey(locationGUID, startDate, endDate);\n    node.warn('[PREFETCH] Starting prefetch for: ' + cacheKey);\n    \n    try {\n        // Build Cloud9 XML request for GetOnlineReservations\n        const xmlRequest = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <ClientID>${CLOUD9.clientId}</ClientID>\n    <UserName>${CLOUD9.userName}</UserName>\n    <Password>${escapeXml(CLOUD9.password)}</Password>\n    <Procedure>GetOnlineReservations</Procedure>\n    <Parameters>\n        <startDate>${startDate} 7:00:00 AM</startDate>\n        <endDate>${endDate} 5:00:00 PM</endDate>\n        <morning>True</morning>\n        <afternoon>True</afternoon>\n    </Parameters>\n</GetDataRequest>`;\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 60000\n        });\n        \n        if (!response.ok) {\n            throw new Error('HTTP ' + response.status);\n        }\n        \n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        \n        // Filter by location\n        let filteredSlots = parsed.records.filter(slot => \n            slot.LocationGUID === locationGUID\n        );\n        \n        // Filter by Chair 8\n        filteredSlots = filteredSlots.filter(slot => \n            slot.ScheduleColumnGUID === CHAIR_8_GUID\n        );\n        \n        // Enrich slots with camelCase aliases\n        const enrichedSlots = filteredSlots.map(slot => ({\n            ...slot,\n            scheduleViewGUID: slot.ScheduleViewGUID,\n            scheduleColumnGUID: slot.ScheduleColumnGUID,\n            startTime: slot.StartTime,\n            minutes: slot.Minutes || '40',\n            appointmentTypeGUID: slot.AppointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705'\n        }));\n        \n        const fetchDurationMs = Date.now() - startTime;\n        \n        // Store in cache\n        const cachedSlots = flow.get('cachedSlots') || {};\n        cachedSlots[cacheKey] = {\n            locationGUID: locationGUID,\n            startDate: startDate,\n            endDate: endDate,\n            slots: enrichedSlots,\n            slotCount: enrichedSlots.length,\n            fetchedAt: new Date().toISOString(),\n            expiresAt: new Date(Date.now() + CACHE_TTL_MS).toISOString(),\n            fetchDurationMs: fetchDurationMs\n        };\n        flow.set('cachedSlots', cachedSlots);\n        \n        node.warn('[PREFETCH] Cached ' + enrichedSlots.length + ' slots in ' + fetchDurationMs + 'ms, key: ' + cacheKey);\n        \n        msg.payload = {\n            success: true,\n            cacheKey: cacheKey,\n            slotCount: enrichedSlots.length,\n            fetchDurationMs: fetchDurationMs,\n            expiresAt: cachedSlots[cacheKey].expiresAt,\n            _debug: {\n                rawRecords: parsed.records.length,\n                afterLocationFilter: parsed.records.filter(s => s.LocationGUID === locationGUID).length,\n                afterChairFilter: enrichedSlots.length\n            }\n        };\n        return msg;\n        \n    } catch (error) {\n        node.error('[PREFETCH] Error: ' + error.message);\n        msg.payload = {\n            success: false,\n            error: error.message,\n            fetchDurationMs: Date.now() - startTime\n        };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn prefetchSlots();",
    "outputs": 1,
    "timeout": 120,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 500,
    "y": 80,
    "wires": [
      [
        "http-out-cache-prefetch"
      ]
    ]
  },
  {
    "id": "http-out-cache-prefetch",
    "type": "http response",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 770,
    "y": 80,
    "wires": []
  },
  {
    "id": "http-in-cache-status",
    "type": "http in",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "url": "/test/slot-cache/status",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 170,
    "y": 160,
    "wires": [
      [
        "func-cache-status",
        "debug-cache-ops"
      ]
    ]
  },
  {
    "id": "func-cache-status",
    "type": "function",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "getCacheStatus",
    "func": "// Slot Cache Test - STATUS endpoint\n// Returns current cache contents and stats\nconst cachedSlots = flow.get('cachedSlots') || {};\nconst now = new Date();\n\nconst cacheKeys = Object.keys(cachedSlots);\nconst entries = [];\nlet validCount = 0;\nlet expiredCount = 0;\nlet totalSlots = 0;\n\nfor (const [key, entry] of Object.entries(cachedSlots)) {\n    const isExpired = new Date(entry.expiresAt) < now;\n    if (isExpired) {\n        expiredCount++;\n    } else {\n        validCount++;\n    }\n    totalSlots += entry.slotCount || 0;\n    \n    entries.push({\n        cacheKey: key,\n        slotCount: entry.slotCount,\n        fetchedAt: entry.fetchedAt,\n        expiresAt: entry.expiresAt,\n        isExpired: isExpired,\n        fetchDurationMs: entry.fetchDurationMs,\n        locationGUID: entry.locationGUID,\n        dateRange: entry.startDate + ' to ' + entry.endDate\n    });\n}\n\n// Sort by fetchedAt descending\nentries.sort((a, b) => new Date(b.fetchedAt) - new Date(a.fetchedAt));\n\nmsg.payload = {\n    cacheKeys: cacheKeys,\n    stats: {\n        totalEntries: cacheKeys.length,\n        validEntries: validCount,\n        expiredEntries: expiredCount,\n        totalSlotsCached: totalSlots\n    },\n    entries: entries\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": 5,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 160,
    "wires": [
      [
        "http-out-cache-status"
      ]
    ]
  },
  {
    "id": "http-out-cache-status",
    "type": "http response",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 770,
    "y": 160,
    "wires": []
  },
  {
    "id": "http-in-cache-query",
    "type": "http in",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "url": "/test/slot-cache/query",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 170,
    "y": 240,
    "wires": [
      [
        "func-cache-query",
        "debug-cache-ops"
      ]
    ]
  },
  {
    "id": "func-cache-query",
    "type": "function",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "queryWithCache",
    "func": "// Slot Cache Test - QUERY endpoint\n// Queries slots - checks cache first, falls back to API if miss/expired\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx',\n    clientId: 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    userName: 'Intelepeer',\n    password: '$#1Nt-p33R-AwS#$',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    defaultLocationGUID: '1fef9297-7c8b-426b-b0d1-f2275136e48b'\n};\n\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction buildCacheKey(locationGUID, startDate, endDate) {\n    const normalizeDate = d => d.replace(/\\//g, '');\n    return `${locationGUID}_${normalizeDate(startDate)}_${normalizeDate(endDate)}`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nasync function queryWithCache() {\n    const startTime = Date.now();\n    const params = msg.payload;\n    \n    // Default dates: today to +30 days\n    const today = new Date();\n    const defaultStart = formatDate(today);\n    const defaultEnd = formatDate(new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000));\n    \n    const startDate = params.startDate || defaultStart;\n    const endDate = params.endDate || defaultEnd;\n    const locationGUID = params.locationGUID || CLOUD9.defaultLocationGUID;\n    \n    const cacheKey = buildCacheKey(locationGUID, startDate, endDate);\n    \n    // CHECK CACHE FIRST\n    const cachedSlots = flow.get('cachedSlots') || {};\n    const cached = cachedSlots[cacheKey];\n    \n    if (cached && new Date(cached.expiresAt) > new Date()) {\n        // CACHE HIT!\n        const queryDurationMs = Date.now() - startTime;\n        node.warn('[QUERY] CACHE HIT - ' + cached.slotCount + ' slots in ' + queryDurationMs + 'ms');\n        \n        msg.payload = {\n            slots: cached.slots,\n            slotCount: cached.slotCount,\n            fromCache: true,\n            cacheKey: cacheKey,\n            cachedAt: cached.fetchedAt,\n            expiresAt: cached.expiresAt,\n            queryDurationMs: queryDurationMs,\n            originalFetchDurationMs: cached.fetchDurationMs\n        };\n        return msg;\n    }\n    \n    // CACHE MISS - Fetch from API\n    node.warn('[QUERY] CACHE MISS - fetching from Cloud9 API');\n    \n    try {\n        const xmlRequest = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <ClientID>${CLOUD9.clientId}</ClientID>\n    <UserName>${CLOUD9.userName}</UserName>\n    <Password>${escapeXml(CLOUD9.password)}</Password>\n    <Procedure>GetOnlineReservations</Procedure>\n    <Parameters>\n        <startDate>${startDate} 7:00:00 AM</startDate>\n        <endDate>${endDate} 5:00:00 PM</endDate>\n        <morning>True</morning>\n        <afternoon>True</afternoon>\n    </Parameters>\n</GetDataRequest>`;\n        \n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 60000\n        });\n        \n        if (!response.ok) {\n            throw new Error('HTTP ' + response.status);\n        }\n        \n        const xmlText = await response.text();\n        const parsed = parseXmlResponse(xmlText);\n        \n        // Filter by location and Chair 8\n        let filteredSlots = parsed.records.filter(slot => \n            slot.LocationGUID === locationGUID && slot.ScheduleColumnGUID === CHAIR_8_GUID\n        );\n        \n        // Enrich slots\n        const enrichedSlots = filteredSlots.map(slot => ({\n            ...slot,\n            scheduleViewGUID: slot.ScheduleViewGUID,\n            scheduleColumnGUID: slot.ScheduleColumnGUID,\n            startTime: slot.StartTime,\n            minutes: slot.Minutes || '40',\n            appointmentTypeGUID: slot.AppointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705'\n        }));\n        \n        const queryDurationMs = Date.now() - startTime;\n        \n        msg.payload = {\n            slots: enrichedSlots,\n            slotCount: enrichedSlots.length,\n            fromCache: false,\n            cacheKey: cacheKey,\n            queryDurationMs: queryDurationMs,\n            _missReason: cached ? 'expired' : 'not_found'\n        };\n        return msg;\n        \n    } catch (error) {\n        node.error('[QUERY] Error: ' + error.message);\n        msg.payload = {\n            success: false,\n            error: error.message,\n            fromCache: false,\n            queryDurationMs: Date.now() - startTime\n        };\n        msg.statusCode = 500;\n        return msg;\n    }\n}\n\nreturn queryWithCache();",
    "outputs": 1,
    "timeout": 120,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 520,
    "y": 240,
    "wires": [
      [
        "http-out-cache-query"
      ]
    ]
  },
  {
    "id": "http-out-cache-query",
    "type": "http response",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 770,
    "y": 240,
    "wires": []
  },
  {
    "id": "http-in-cache-clear",
    "type": "http in",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "url": "/test/slot-cache/clear",
    "method": "delete",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 500,
    "wires": [
      [
        "func-cache-clear",
        "debug-cache-ops"
      ]
    ]
  },
  {
    "id": "func-cache-clear",
    "type": "function",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "clearCache",
    "func": "// Slot Cache Test - CLEAR endpoint\n// Clears all cached slots or a specific cache key\nconst params = msg.payload || {};\nconst cachedSlots = flow.get('cachedSlots') || {};\n\nlet entriesRemoved = 0;\nlet keysRemoved = [];\n\nif (params.cacheKey) {\n    // Clear specific key\n    if (cachedSlots[params.cacheKey]) {\n        keysRemoved.push(params.cacheKey);\n        delete cachedSlots[params.cacheKey];\n        entriesRemoved = 1;\n    }\n} else {\n    // Clear all\n    keysRemoved = Object.keys(cachedSlots);\n    entriesRemoved = keysRemoved.length;\n}\n\nflow.set('cachedSlots', params.cacheKey ? cachedSlots : {});\n\nnode.warn('[CLEAR] Removed ' + entriesRemoved + ' cache entries');\n\nmsg.payload = {\n    cleared: true,\n    entriesRemoved: entriesRemoved,\n    keysRemoved: keysRemoved\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": 5,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 500,
    "wires": [
      [
        "http-out-cache-clear"
      ]
    ]
  },
  {
    "id": "http-out-cache-clear",
    "type": "http response",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 700,
    "y": 500,
    "wires": []
  },
  {
    "id": "debug-cache-ops",
    "type": "debug",
    "z": "slot-cache-test-tab",
    "g": "grp-slot-cache-test",
    "name": "Cache Operations",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "x": 530,
    "y": 400,
    "wires": []
  },
  {
    "id": "slot-cache-redis-tab",
    "type": "tab",
    "label": "Slot-Cache-Redis",
    "disabled": false,
    "info": "Redis-based slot cache with auto-refresh every 5 minutes during business hours (7am-5pm CST, Mon-Fri). Includes startup pre-warming on deploy. (7am-5pm CST, Mon-Fri)",
    "env": []
  },
  {
    "id": "grp-slot-cache-redis-refresh",
    "type": "group",
    "z": "slot-cache-redis-tab",
    "name": "Auto-Refresh (Every 5 min during business hours)",
    "style": {
      "label": true,
      "fill": "#2eb398",
      "color": "#ffffff"
    },
    "nodes": [
      "inject-slot-refresh",
      "func-check-business-hours",
      "func-fetch-tier1",
      "func-fetch-tier2",
      "func-fetch-tier3",
      "redis-store-tier1",
      "redis-store-tier2",
      "redis-store-tier3",
      "debug-redis-refresh",
      "inject-startup-prewarm"
    ],
    "x": 14,
    "y": 20,
    "w": 1100,
    "h": 260
  },
  {
    "id": "grp-slot-cache-redis-test",
    "type": "group",
    "z": "slot-cache-redis-tab",
    "name": "Redis Cache Test Endpoints",
    "style": {
      "label": true,
      "fill": "#ff6600",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-redis-trigger",
      "func-redis-trigger",
      "http-out-redis-trigger",
      "http-in-redis-status",
      "func-redis-status",
      "http-out-redis-status",
      "http-in-redis-clear",
      "func-redis-clear",
      "http-out-redis-clear",
      "debug-redis-test"
    ],
    "x": 14,
    "y": 300,
    "w": 750,
    "h": 240
  },
  {
    "id": "inject-slot-refresh",
    "type": "inject",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Auto-Refresh Every 5min (cron)",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "*/5 * * * *",
    "once": true,
    "onceDelay": "30",
    "topic": "slot-cache-refresh",
    "payload": "{}",
    "payloadType": "json",
    "x": 100,
    "y": 100,
    "wires": [
      [
        "func-check-business-hours"
      ]
    ]
  },
  {
    "id": "func-check-business-hours",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Check Business Hours + Redis Lock (Phase 4E v2)",
    "func": "// Phase 4E v2: Business Hours Check with Redis Distributed Lock\n// v2: Added Redis lock to prevent duplicate refreshes from load-balanced instances\n\nconst BYPASS_BUSINESS_HOURS = true; // Set to false for production\n\n// Redis lock configuration\nconst LOCK_KEY = 'SlotCache-RefreshLock';\nconst LOCK_TTL_SECONDS = 120; // Lock expires after 2 minutes (refresh takes ~45s)\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n\n// Sequential delay between tier triggers\nconst TIER_DELAY_MS = 12000; // 12 seconds between tiers\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\n// Try to acquire distributed lock using Redis\nasync function tryAcquireLock() {\n    const lockValue = Date.now() + '-' + Math.random().toString(36).substring(7);\n\n    try {\n        // First check if lock exists\n        const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(LOCK_KEY);\n        const getResp = await fetch(getUrl, {\n            method: 'GET',\n            headers: { 'Authorization': REDIS_AUTH },\n            timeout: 5000\n        });\n\n        if (getResp.ok) {\n            const text = await getResp.text();\n            if (text && text !== 'null') {\n                const existing = JSON.parse(text);\n                const lockAge = Date.now() - existing.timestamp;\n\n                // If lock is fresh (< TTL), another instance is refreshing\n                if (lockAge < LOCK_TTL_SECONDS * 1000) {\n                    node.warn('[REFRESH_LOCK] Lock held by another instance (age: ' + Math.round(lockAge/1000) + 's). Skipping refresh.');\n                    return { acquired: false, reason: 'lock_held' };\n                }\n                // Lock is stale, we can take over\n                node.warn('[REFRESH_LOCK] Stale lock detected (age: ' + Math.round(lockAge/1000) + 's). Taking over.');\n            }\n        }\n\n        // Acquire the lock\n        const setUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n        const setResp = await fetch(setUrl, {\n            method: 'POST',\n            headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                key: LOCK_KEY,\n                value: { timestamp: Date.now(), instance: lockValue },\n                ttl: LOCK_TTL_SECONDS\n            }),\n            timeout: 5000\n        });\n\n        if (setResp.ok) {\n            node.warn('[REFRESH_LOCK] Lock acquired: ' + lockValue);\n            return { acquired: true, lockValue: lockValue };\n        }\n\n        return { acquired: false, reason: 'set_failed' };\n    } catch (e) {\n        node.warn('[REFRESH_LOCK] Lock error: ' + e.message + '. Proceeding anyway.');\n        return { acquired: true, lockValue: 'error-fallback' }; // Proceed on error to avoid deadlock\n    }\n}\n\nasync function releaseLock(lockValue) {\n    try {\n        const setUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n        await fetch(setUrl, {\n            method: 'POST',\n            headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                key: LOCK_KEY,\n                value: null,\n                ttl: 1\n            }),\n            timeout: 5000\n        });\n        node.warn('[REFRESH_LOCK] Lock released');\n    } catch (e) {\n        node.warn('[REFRESH_LOCK] Release error: ' + e.message);\n    }\n}\n\nasync function runSequentialRefresh() {\n    // Try to acquire distributed lock first\n    const lock = await tryAcquireLock();\n    if (!lock.acquired) {\n        return null; // Another instance is handling refresh\n    }\n\n    const lockValue = lock.lockValue;\n\n    // Enhanced logging: cycle lifecycle\n    const cycleStartTime = Date.now();\n    flow.set('slotCacheRefreshCycleStart', cycleStartTime);\n    node.warn('[SLOT_CACHE] === REFRESH CYCLE START === at ' + new Date().toISOString());\n\n    try {\n        if (BYPASS_BUSINESS_HOURS) {\n            node.warn('[SLOT_CACHE] BYPASS_BUSINESS_HOURS=true - proceeding with refresh (SEQUENTIAL)');\n            msg.refreshState = {\n                startTime: Date.now(),\n                timestamp: new Date().toISOString() + ' (bypass)',\n                tiers: [30, 60, 90],\n                results: [],\n                sequential: true,\n                bypassBusinessHours: true\n            };\n\n            node.send([[msg], null, null]);\n            await delay(TIER_DELAY_MS);\n            node.warn('[SLOT_CACHE] Triggering Tier 2 after ' + TIER_DELAY_MS + 'ms delay');\n            node.send([null, [msg], null]);\n            await delay(TIER_DELAY_MS);\n            node.warn('[SLOT_CACHE] Triggering Tier 3 after ' + TIER_DELAY_MS + 'ms delay');\n            node.send([null, null, [msg]]);\n\n            await delay(5000);\n            node.warn('[SLOT_CACHE] === REFRESH CYCLE DISPATCHED === all 3 tiers triggered, elapsed: ' + Math.round((Date.now() - cycleStartTime)/1000) + 's');\n            await releaseLock(lockValue);\n            return null;\n        }\n\n        if (msg.forcedRefresh || msg.bypassBusinessHours) {\n            node.warn('[SLOT_CACHE] Force refresh - bypassing business hours check (SEQUENTIAL)');\n            msg.refreshState = {\n                startTime: Date.now(),\n                timestamp: new Date().toISOString() + ' (forced)',\n                tiers: [30, 60, 90],\n                results: [],\n                sequential: true\n            };\n\n            node.send([[msg], null, null]);\n            await delay(TIER_DELAY_MS);\n            node.send([null, [msg], null]);\n            await delay(TIER_DELAY_MS);\n            node.send([null, null, [msg]]);\n\n            await delay(5000);\n            node.warn('[SLOT_CACHE] === REFRESH CYCLE DISPATCHED === all 3 tiers triggered, elapsed: ' + Math.round((Date.now() - cycleStartTime)/1000) + 's');\n            await releaseLock(lockValue);\n            return null;\n        }\n\n        const isStartupPrewarm = msg.topic === 'startup-prewarm';\n        if (isStartupPrewarm) {\n            node.warn('[SLOT_CACHE] Startup pre-warm - bypassing business hours check (SEQUENTIAL)');\n            msg.refreshState = {\n                startTime: Date.now(),\n                timestamp: new Date().toISOString() + ' (startup)',\n                tiers: [30, 60, 90],\n                results: [],\n                isStartupPrewarm: true,\n                sequential: true\n            };\n\n            node.send([[msg], null, null]);\n            await delay(TIER_DELAY_MS);\n            node.send([null, [msg], null]);\n            await delay(TIER_DELAY_MS);\n            node.send([null, null, [msg]]);\n\n            await delay(5000);\n            node.warn('[SLOT_CACHE] === REFRESH CYCLE DISPATCHED === all 3 tiers triggered, elapsed: ' + Math.round((Date.now() - cycleStartTime)/1000) + 's');\n            await releaseLock(lockValue);\n            return null;\n        }\n\n        // Check business hours (CST)\n        const now = new Date();\n        const cstOffset = -6 * 60;\n        const utc = now.getTime() + (now.getTimezoneOffset() * 60000);\n        const cstTime = new Date(utc + (cstOffset * 60000));\n\n        const hour = cstTime.getHours();\n        const dayOfWeek = cstTime.getDay();\n        const isWeekday = dayOfWeek >= 1 && dayOfWeek <= 5;\n        const isBusinessHours = hour >= 7 && hour < 17;\n\n        const timestamp = cstTime.toISOString().replace('T', ' ').substring(0, 19) + ' CST';\n\n        if (!isWeekday) {\n            node.warn('[SLOT_CACHE] ' + timestamp + ' - Weekend, skipping refresh');\n            await releaseLock(lockValue);\n            return null;\n        }\n\n        if (!isBusinessHours) {\n            node.warn('[SLOT_CACHE] ' + timestamp + ' - Outside business hours, skipping refresh');\n            await releaseLock(lockValue);\n            return null;\n        }\n\n        node.warn('[SLOT_CACHE] ' + timestamp + ' - Business hours, proceeding with refresh');\n\n        msg.refreshState = {\n            startTime: Date.now(),\n            timestamp: timestamp,\n            tiers: [30, 60, 90],\n            results: [],\n            sequential: true\n        };\n\n        node.send([[msg], null, null]);\n        await delay(TIER_DELAY_MS);\n        node.send([null, [msg], null]);\n        await delay(TIER_DELAY_MS);\n        node.send([null, null, [msg]]);\n\n        await delay(5000);\n            node.warn('[SLOT_CACHE] === REFRESH CYCLE DISPATCHED === all 3 tiers triggered, elapsed: ' + Math.round((Date.now() - cycleStartTime)/1000) + 's');\n            await releaseLock(lockValue);\n        return null;\n\n    } catch (e) {\n        node.error('[SLOT_CACHE] Error in refresh: ' + e.message);\n        await releaseLock(lockValue);\n        return null;\n    }\n}\n\nreturn runSequentialRefresh();",
    "outputs": 3,
    "timeout": 60,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 350,
    "y": 135,
    "wires": [
      [
        "func-fetch-tier1"
      ],
      [
        "func-fetch-tier2"
      ],
      [
        "func-fetch-tier3"
      ]
    ]
  },
  {
    "id": "func-fetch-tier1",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Fetch Tier 1 (30 days)",
    "func": "// Fetch slots for Tier 1 (30 days) and store in Redis\n// v11: Phase 4H - Added refresh history logging\n// v10: Phase 4F - Added retry logic, rate limit handling, Redis verification, health tracking\nconst TIER = 1;\nconst TIER_DAYS = 30;\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx',\n    clientId: 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    userName: 'Intelepeer',\n    password: '$#1Nt-p33R-AwS#$',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    defaultLocationGUID: '1fef9297-7c8b-426b-b0d1-f2275136e48b'\n};\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\n// v10: Retry configuration\nconst RETRY_CONFIG = {\n    maxAttempts: 3,\n    baseDelayMs: 5000,      // 5s initial delay\n    maxDelayMs: 30000,      // 30s max delay\n    rateLimitDelayMs: 15000 // 15s delay on rate limit\n};\n\n// v10: Redis configuration for verification\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const errorCodeMatch = xmlText.match(/<ErrorCode>([^<]+)<\\/ErrorCode>/);\n    const errorCode = errorCodeMatch ? parseInt(errorCodeMatch[1]) : null;\n    const errorMsgMatch = xmlText.match(/<ErrorMessage>([^<]+)<\\/ErrorMessage>/);\n    const errorMessage = errorMsgMatch ? errorMsgMatch[1] : null;\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, errorCode, errorMessage, records };\n}\n\nfunction groupSlotsByDate(slots) {\n    const grouped = {};\n    slots.forEach(slot => {\n        const dateMatch = (slot.startTime || slot.StartTime || '').match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n        if (dateMatch) {\n            const date = dateMatch[1];\n            if (!grouped[date]) grouped[date] = [];\n            grouped[date].push(slot);\n        }\n    });\n    return Object.entries(grouped).map(([date, slots]) => ({\n        date: date,\n        slots: slots,\n        slotCount: slots.length\n    })).sort((a, b) => new Date(a.date) - new Date(b.date));\n}\n\n// v10: Verify Redis write by reading back\nasync function verifyRedisWrite(key, expectedSlotCount) {\n    try {\n        const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(key);\n        const response = await fetch(getUrl, {\n            method: 'GET',\n            headers: { 'Authorization': REDIS_AUTH },\n            timeout: 5000\n        });\n        if (!response.ok) return { verified: false, error: 'HTTP ' + response.status };\n        const text = await response.text();\n        if (!text || text === 'null') return { verified: false, error: 'Empty response' };\n        const data = JSON.parse(text);\n        if (data.slotCount === expectedSlotCount) {\n            return { verified: true, slotCount: data.slotCount };\n        }\n        return { verified: false, error: 'Count mismatch: expected ' + expectedSlotCount + ', got ' + data.slotCount };\n    } catch (e) {\n        return { verified: false, error: e.message };\n    }\n}\n\n// v10: Track health in flow context\nfunction updateHealthTracking(success, error) {\n    const healthKey = 'slotCacheHealth_Tier' + TIER;\n    const health = flow.get(healthKey) || { consecutiveFailures: 0, lastSuccess: null, lastError: null };\n\n    if (success) {\n        health.consecutiveFailures = 0;\n        health.lastSuccess = new Date().toISOString();\n        health.lastError = null;\n    } else {\n        health.consecutiveFailures++;\n        health.lastError = { timestamp: new Date().toISOString(), message: error };\n    }\n\n    flow.set(healthKey, health);\n\n    // Warn if 3+ consecutive failures\n    if (health.consecutiveFailures >= 3) {\n        node.error('[SLOT_CACHE] ALERT: Tier ' + TIER + ' has failed ' + health.consecutiveFailures + ' consecutive times!');\n    }\n\n    return health;\n}\n\nasync function fetchAndCacheTier() {\n    const startTime = Date.now();\n    const today = new Date();\n    const startDate = formatDate(today);\n    const endDate = formatDate(new Date(today.getTime() + TIER_DAYS * 24 * 60 * 60 * 1000));\n    const locationGUID = CLOUD9.defaultLocationGUID;\n\n    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Fetching ' + startDate + ' to ' + endDate);\n\n    let lastError = null;\n    let attempt = 0;\n\n    // v10: Retry loop with exponential backoff\n    while (attempt < RETRY_CONFIG.maxAttempts) {\n        attempt++;\n\n        if (attempt > 1) {\n            // Calculate delay with exponential backoff\n            const backoffDelay = Math.min(\n                RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt - 2),\n                RETRY_CONFIG.maxDelayMs\n            );\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Retry ' + attempt + '/' + RETRY_CONFIG.maxAttempts + ' after ' + backoffDelay + 'ms');\n            await delay(backoffDelay);\n        }\n\n        try {\n            const xmlRequest = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <ClientID>${CLOUD9.clientId}</ClientID>\n    <UserName>${CLOUD9.userName}</UserName>\n    <Password>${escapeXml(CLOUD9.password)}</Password>\n    <Procedure>GetOnlineReservations</Procedure>\n    <Parameters>\n        <startDate>${startDate} 7:00:00 AM</startDate>\n        <endDate>${endDate} 5:00:00 PM</endDate>\n        <morning>True</morning>\n        <afternoon>True</afternoon>\n    </Parameters>\n</GetDataRequest>`;\n\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xmlRequest,\n                timeout: 120000\n            });\n\n            if (!response.ok) {\n                throw new Error('HTTP ' + response.status);\n            }\n\n            const xmlText = await response.text();\n            const parsed = parseXmlResponse(xmlText);\n\n            // v10: Check for Cloud9 error codes\n            if (parsed.status !== 'Success') {\n                // ErrorCode 8 = Rate limit\n                if (parsed.errorCode === 8) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Rate limited (ErrorCode 8), waiting ' + RETRY_CONFIG.rateLimitDelayMs + 'ms');\n                    lastError = 'Rate limit (ErrorCode 8): ' + parsed.errorMessage;\n                    await delay(RETRY_CONFIG.rateLimitDelayMs);\n                    continue; // Retry\n                }\n                throw new Error('Cloud9 Error ' + parsed.errorCode + ': ' + parsed.errorMessage);\n            }\n\n            // Filter by location\n            let filteredSlots = parsed.records.filter(slot =>\n                slot.LocationGUID === locationGUID\n            );\n\n            // Filter by Chair 8\n            filteredSlots = filteredSlots.filter(slot =>\n                slot.ScheduleColumnGUID === CHAIR_8_GUID\n            );\n\n            // Filter by minimum duration (40 minutes)\n            filteredSlots = filteredSlots.filter(slot =>\n                parseInt(slot.Minutes || '0') >= 40\n            );\n\n            // Enrich slots with camelCase aliases\n            const enrichedSlots = filteredSlots.map(slot => ({\n                ...slot,\n                scheduleViewGUID: slot.ScheduleViewGUID,\n                scheduleColumnGUID: slot.ScheduleColumnGUID,\n                startTime: slot.StartTime,\n                minutes: slot.Minutes || '40',\n                appointmentTypeGUID: slot.AppointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705'\n            }));\n\n            // Group by date\n            const groupedSlots = groupSlotsByDate(enrichedSlots);\n\n            const fetchDurationMs = Date.now() - startTime;\n\n            // Build Redis cache payload\n            const redisKey = 'SlotCache-' + locationGUID + '-Tier' + TIER;\n            const cachePayload = {\n                locationGUID: locationGUID,\n                scheduleViewGUID: enrichedSlots.length > 0 ? enrichedSlots[0].scheduleViewGUID : null,\n                slots: enrichedSlots,\n                groupedSlots: groupedSlots,\n                fetchedAt: new Date().toISOString(),\n                slotCount: enrichedSlots.length,\n                tier: TIER,\n                tierDays: TIER_DAYS,\n                dateRange: { start: startDate, end: endDate },\n                fetchDurationMs: fetchDurationMs,\n                attempts: attempt\n            };\n\n            \n    // Store summary in flow context for cache-health endpoint (no loopback)\n    const summaryKey = 'slotCacheSummary_Tier' + TIER;\n    const slotsByDate = {};\n    enrichedSlots.forEach(slot => {\n        const startTime = slot.StartTime || slot.startTime || '';\n        const dateMatch = startTime.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n        if (dateMatch) {\n            const date = dateMatch[1];\n            if (!slotsByDate[date]) slotsByDate[date] = 0;\n            slotsByDate[date]++;\n        }\n    });\n    const slotsByDateArray = Object.entries(slotsByDate)\n        .map(([date, count]) => ({ date, count }))\n        .sort((a, b) => new Date(a.date) - new Date(b.date))\n        .slice(0, 14);\n\n    flow.set(summaryKey, {\n        slotCount: enrichedSlots.length,\n        fetchedAt: new Date().toISOString(),\n        tierDays: TIER_DAYS,\n        dateRange: { start: startDate, end: endDate },\n        slotsByDate: slotsByDateArray\n    });\\n\\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Fetched ' + enrichedSlots.length + ' slots in ' + fetchDurationMs + 'ms (attempt ' + attempt + ')');\n\n            // v12: Rate limit detection - don't store if 0 slots + fast response\n            const MIN_EXPECTED_DURATION_MS = 1000; // Real Cloud9 queries take >1s\n            if (enrichedSlots.length === 0 && fetchDurationMs < MIN_EXPECTED_DURATION_MS) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': RATE LIMIT DETECTED - 0 slots in ' + fetchDurationMs + 'ms (too fast). NOT storing.');\n                updateHealthTracking(false, 'Rate limit (0 slots + fast response)');\n                msg.tierResult = { tier: TIER, success: false, error: 'Rate limit detected', rateLimit: true };\n                return null; // Don't store empty cache\n            }\n\n            // Prepare for Redis storage\n            msg.payload = {\n                key: redisKey,\n                value: cachePayload\n            };\n            msg.tierResult = {\n                tier: TIER,\n                slotCount: enrichedSlots.length,\n                fetchDurationMs: fetchDurationMs,\n                success: true,\n                attempts: attempt\n            };\n\n            // v10: Store verification callback for after Redis write\n            msg._verifyRedis = {\n                key: redisKey,\n                expectedSlotCount: enrichedSlots.length\n            };\n\n            // v10: Update health tracking\n            updateHealthTracking(true, null);\n\n            // v11: Phase 4H - Log refresh attempt to history\n            const history = flow.get('slotCacheRefreshHistory') || [];\n            history.push({ timestamp: new Date().toISOString(), tier: TIER, success: true, slotCount: enrichedSlots.length, error: null });\n            if (history.length > 100) history.shift();\n            flow.set('slotCacheRefreshHistory', history);\n\n            // v20: Invalidate pre-grouped cache so next request rebuilds from fresh flat data\n            const preGroupedKey = 'SlotCache-' + locationGUID + '-Tier' + TIER + '-PreGrouped';\n            const redisDELUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n            try {\n                const delResp = await fetch(redisDELUrl, {\n                    method: 'POST',\n                    headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ key: preGroupedKey, value: { invalidated: true }, ttl: 1 }),\n                    timeout: 3000\n                });\n                if (delResp.ok) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Invalidated pre-grouped cache key: ' + preGroupedKey);\n                }\n            } catch (pgErr) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': Failed to invalidate pre-grouped cache: ' + pgErr.message);\n            }\n\n            // Enhanced logging: Redis write confirmation\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write pending  ' + enrichedSlots.length + ' slots, key=' + redisKey + ', fetchedAt=' + cachePayload.fetchedAt);\n            const cycleStart = flow.get('slotCacheRefreshCycleStart');\n            if (cycleStart) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': Cycle elapsed: ' + Math.round((Date.now() - cycleStart)/1000) + 's');\n            }\n\n            // Verify Redis write after a short delay (downstream redis-store node)\n            setTimeout(async () => {\n                try {\n                    const verify = await verifyRedisWrite(redisKey, enrichedSlots.length);\n                    if (verify.verified) {\n                        node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write VERIFIED OK  ' + verify.slotCount + ' slots confirmed in key=' + redisKey);\n                    } else {\n                        node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write VERIFY FAILED  ' + verify.error);\n                    }\n                } catch (e) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis verify error: ' + e.message);\n                }\n\n                // Log refresh cycle summary if this is Tier 3 (last tier)\n                if (TIER === 3 && cycleStart) {\n                    const t1 = flow.get('slotCacheSummary_Tier1');\n                    const t2 = flow.get('slotCacheSummary_Tier2');\n                    const t3 = flow.get('slotCacheSummary_Tier3');\n                    node.warn('[SLOT_CACHE] Refresh cycle complete  T1:' + (t1 ? t1.slotCount : '?') + ' T2:' + (t2 ? t2.slotCount : '?') + ' T3:' + (t3 ? t3.slotCount : '?') + ' slots stored at ' + new Date().toISOString() + ' (total elapsed: ' + Math.round((Date.now() - cycleStart)/1000) + 's)');\n                }\n            }, 3000);\n\n            return msg;\n\n        } catch (error) {\n            lastError = error.message;\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Attempt ' + attempt + ' failed: ' + error.message);\n\n            if (attempt >= RETRY_CONFIG.maxAttempts) {\n                break;\n            }\n        }\n    }\n\n    // All retries exhausted\n    node.error('[SLOT_CACHE] Tier ' + TIER + ' FAILED after ' + attempt + ' attempts: ' + lastError);\n\n    // v10: Update health tracking\n    const health = updateHealthTracking(false, lastError);\n\n    // v11: Phase 4H - Log refresh failure to history\n    const failHistory = flow.get('slotCacheRefreshHistory') || [];\n    failHistory.push({ timestamp: new Date().toISOString(), tier: TIER, success: false, slotCount: 0, error: lastError });\n    if (failHistory.length > 100) failHistory.shift();\n    flow.set('slotCacheRefreshHistory', failHistory);\n\n    msg.tierResult = {\n        tier: TIER,\n        success: false,\n        error: lastError,\n        attempts: attempt,\n        consecutiveFailures: health.consecutiveFailures,\n        fetchDurationMs: Date.now() - startTime\n    };\n\n    return null; // Don't store on error\n}\n\nreturn fetchAndCacheTier();",
    "outputs": 1,
    "timeout": 180,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 600,
    "y": 65,
    "wires": [
      [
        "redis-store-tier1",
        "debug-redis-refresh"
      ]
    ]
  },
  {
    "id": "func-fetch-tier2",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Fetch Tier 2 (60 days)",
    "func": "// Fetch slots for Tier 2 (60 days) and store in Redis\n// v10: Phase 4F - Added retry logic, rate limit handling, Redis verification, health tracking\nconst TIER = 2;\nconst TIER_DAYS = 60;\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx',\n    clientId: 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    userName: 'Intelepeer',\n    password: '$#1Nt-p33R-AwS#$',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    defaultLocationGUID: '1fef9297-7c8b-426b-b0d1-f2275136e48b'\n};\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\n// v10: Retry configuration\nconst RETRY_CONFIG = {\n    maxAttempts: 3,\n    baseDelayMs: 5000,      // 5s initial delay\n    maxDelayMs: 30000,      // 30s max delay\n    rateLimitDelayMs: 15000 // 15s delay on rate limit\n};\n\n// v10: Redis configuration for verification\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const errorCodeMatch = xmlText.match(/<ErrorCode>([^<]+)<\\/ErrorCode>/);\n    const errorCode = errorCodeMatch ? parseInt(errorCodeMatch[1]) : null;\n    const errorMsgMatch = xmlText.match(/<ErrorMessage>([^<]+)<\\/ErrorMessage>/);\n    const errorMessage = errorMsgMatch ? errorMsgMatch[1] : null;\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, errorCode, errorMessage, records };\n}\n\nfunction groupSlotsByDate(slots) {\n    const grouped = {};\n    slots.forEach(slot => {\n        const dateMatch = (slot.startTime || slot.StartTime || '').match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n        if (dateMatch) {\n            const date = dateMatch[1];\n            if (!grouped[date]) grouped[date] = [];\n            grouped[date].push(slot);\n        }\n    });\n    return Object.entries(grouped).map(([date, slots]) => ({\n        date: date,\n        slots: slots,\n        slotCount: slots.length\n    })).sort((a, b) => new Date(a.date) - new Date(b.date));\n}\n\n// v10: Verify Redis write by reading back\nasync function verifyRedisWrite(key, expectedSlotCount) {\n    try {\n        const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(key);\n        const response = await fetch(getUrl, {\n            method: 'GET',\n            headers: { 'Authorization': REDIS_AUTH },\n            timeout: 5000\n        });\n        if (!response.ok) return { verified: false, error: 'HTTP ' + response.status };\n        const text = await response.text();\n        if (!text || text === 'null') return { verified: false, error: 'Empty response' };\n        const data = JSON.parse(text);\n        if (data.slotCount === expectedSlotCount) {\n            return { verified: true, slotCount: data.slotCount };\n        }\n        return { verified: false, error: 'Count mismatch: expected ' + expectedSlotCount + ', got ' + data.slotCount };\n    } catch (e) {\n        return { verified: false, error: e.message };\n    }\n}\n\n// v10: Track health in flow context\nfunction updateHealthTracking(success, error) {\n    const healthKey = 'slotCacheHealth_Tier' + TIER;\n    const health = flow.get(healthKey) || { consecutiveFailures: 0, lastSuccess: null, lastError: null };\n\n    if (success) {\n        health.consecutiveFailures = 0;\n        health.lastSuccess = new Date().toISOString();\n        health.lastError = null;\n    } else {\n        health.consecutiveFailures++;\n        health.lastError = { timestamp: new Date().toISOString(), message: error };\n    }\n\n    flow.set(healthKey, health);\n\n    // Warn if 3+ consecutive failures\n    if (health.consecutiveFailures >= 3) {\n        node.error('[SLOT_CACHE] ALERT: Tier ' + TIER + ' has failed ' + health.consecutiveFailures + ' consecutive times!');\n    }\n\n    return health;\n}\n\nasync function fetchAndCacheTier() {\n    const startTime = Date.now();\n    const today = new Date();\n    const startDate = formatDate(today);\n    const endDate = formatDate(new Date(today.getTime() + TIER_DAYS * 24 * 60 * 60 * 1000));\n    const locationGUID = CLOUD9.defaultLocationGUID;\n\n    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Fetching ' + startDate + ' to ' + endDate);\n\n    let lastError = null;\n    let attempt = 0;\n\n    // v10: Retry loop with exponential backoff\n    while (attempt < RETRY_CONFIG.maxAttempts) {\n        attempt++;\n\n        if (attempt > 1) {\n            // Calculate delay with exponential backoff\n            const backoffDelay = Math.min(\n                RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt - 2),\n                RETRY_CONFIG.maxDelayMs\n            );\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Retry ' + attempt + '/' + RETRY_CONFIG.maxAttempts + ' after ' + backoffDelay + 'ms');\n            await delay(backoffDelay);\n        }\n\n        try {\n            const xmlRequest = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <ClientID>${CLOUD9.clientId}</ClientID>\n    <UserName>${CLOUD9.userName}</UserName>\n    <Password>${escapeXml(CLOUD9.password)}</Password>\n    <Procedure>GetOnlineReservations</Procedure>\n    <Parameters>\n        <startDate>${startDate} 7:00:00 AM</startDate>\n        <endDate>${endDate} 5:00:00 PM</endDate>\n        <morning>True</morning>\n        <afternoon>True</afternoon>\n    </Parameters>\n</GetDataRequest>`;\n\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xmlRequest,\n                timeout: 120000\n            });\n\n            if (!response.ok) {\n                throw new Error('HTTP ' + response.status);\n            }\n\n            const xmlText = await response.text();\n            const parsed = parseXmlResponse(xmlText);\n\n            // v10: Check for Cloud9 error codes\n            if (parsed.status !== 'Success') {\n                // ErrorCode 8 = Rate limit\n                if (parsed.errorCode === 8) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Rate limited (ErrorCode 8), waiting ' + RETRY_CONFIG.rateLimitDelayMs + 'ms');\n                    lastError = 'Rate limit (ErrorCode 8): ' + parsed.errorMessage;\n                    await delay(RETRY_CONFIG.rateLimitDelayMs);\n                    continue; // Retry\n                }\n                throw new Error('Cloud9 Error ' + parsed.errorCode + ': ' + parsed.errorMessage);\n            }\n\n            // Filter by location\n            let filteredSlots = parsed.records.filter(slot =>\n                slot.LocationGUID === locationGUID\n            );\n\n            // Filter by Chair 8\n            filteredSlots = filteredSlots.filter(slot =>\n                slot.ScheduleColumnGUID === CHAIR_8_GUID\n            );\n\n            // Filter by minimum duration (40 minutes)\n            filteredSlots = filteredSlots.filter(slot =>\n                parseInt(slot.Minutes || '0') >= 40\n            );\n\n            // Enrich slots with camelCase aliases\n            const enrichedSlots = filteredSlots.map(slot => ({\n                ...slot,\n                scheduleViewGUID: slot.ScheduleViewGUID,\n                scheduleColumnGUID: slot.ScheduleColumnGUID,\n                startTime: slot.StartTime,\n                minutes: slot.Minutes || '40',\n                appointmentTypeGUID: slot.AppointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705'\n            }));\n\n            // Group by date\n            const groupedSlots = groupSlotsByDate(enrichedSlots);\n\n            const fetchDurationMs = Date.now() - startTime;\n\n            // Build Redis cache payload\n            const redisKey = 'SlotCache-' + locationGUID + '-Tier' + TIER;\n            const cachePayload = {\n                locationGUID: locationGUID,\n                scheduleViewGUID: enrichedSlots.length > 0 ? enrichedSlots[0].scheduleViewGUID : null,\n                slots: enrichedSlots,\n                groupedSlots: groupedSlots,\n                fetchedAt: new Date().toISOString(),\n                slotCount: enrichedSlots.length,\n                tier: TIER,\n                tierDays: TIER_DAYS,\n                dateRange: { start: startDate, end: endDate },\n                fetchDurationMs: fetchDurationMs,\n                attempts: attempt\n            };\n\n            \n    // Store summary in flow context for cache-health endpoint (no loopback)\n    const summaryKey = 'slotCacheSummary_Tier' + TIER;\n    const slotsByDate = {};\n    enrichedSlots.forEach(slot => {\n        const startTime = slot.StartTime || slot.startTime || '';\n        const dateMatch = startTime.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n        if (dateMatch) {\n            const date = dateMatch[1];\n            if (!slotsByDate[date]) slotsByDate[date] = 0;\n            slotsByDate[date]++;\n        }\n    });\n    const slotsByDateArray = Object.entries(slotsByDate)\n        .map(([date, count]) => ({ date, count }))\n        .sort((a, b) => new Date(a.date) - new Date(b.date))\n        .slice(0, 14);\n\n    flow.set(summaryKey, {\n        slotCount: enrichedSlots.length,\n        fetchedAt: new Date().toISOString(),\n        tierDays: TIER_DAYS,\n        dateRange: { start: startDate, end: endDate },\n        slotsByDate: slotsByDateArray\n    });\\n\\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Fetched ' + enrichedSlots.length + ' slots in ' + fetchDurationMs + 'ms (attempt ' + attempt + ')');\n\n            // v12: Rate limit detection - don't store if 0 slots + fast response\n            const MIN_EXPECTED_DURATION_MS = 1000; // Real Cloud9 queries take >1s\n            if (enrichedSlots.length === 0 && fetchDurationMs < MIN_EXPECTED_DURATION_MS) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': RATE LIMIT DETECTED - 0 slots in ' + fetchDurationMs + 'ms (too fast). NOT storing.');\n                updateHealthTracking(false, 'Rate limit (0 slots + fast response)');\n                msg.tierResult = { tier: TIER, success: false, error: 'Rate limit detected', rateLimit: true };\n                return null; // Don't store empty cache\n            }\n\n            // Prepare for Redis storage\n            msg.payload = {\n                key: redisKey,\n                value: cachePayload\n            };\n            msg.tierResult = {\n                tier: TIER,\n                slotCount: enrichedSlots.length,\n                fetchDurationMs: fetchDurationMs,\n                success: true,\n                attempts: attempt\n            };\n\n            // v10: Store verification callback for after Redis write\n            msg._verifyRedis = {\n                key: redisKey,\n                expectedSlotCount: enrichedSlots.length\n            };\n\n            // v10: Update health tracking\n            updateHealthTracking(true, null);\n\n            // v11: Phase 4H - Log refresh attempt to history\n            const history = flow.get('slotCacheRefreshHistory') || [];\n            history.push({ timestamp: new Date().toISOString(), tier: TIER, success: true, slotCount: enrichedSlots.length, error: null });\n            if (history.length > 100) history.shift();\n            flow.set('slotCacheRefreshHistory', history);\n\n            // v20: Invalidate pre-grouped cache so next request rebuilds from fresh flat data\n            const preGroupedKey = 'SlotCache-' + locationGUID + '-Tier' + TIER + '-PreGrouped';\n            const redisDELUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n            try {\n                const delResp = await fetch(redisDELUrl, {\n                    method: 'POST',\n                    headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ key: preGroupedKey, value: { invalidated: true }, ttl: 1 }),\n                    timeout: 3000\n                });\n                if (delResp.ok) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Invalidated pre-grouped cache key: ' + preGroupedKey);\n                }\n            } catch (pgErr) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': Failed to invalidate pre-grouped cache: ' + pgErr.message);\n            }\n\n            // Enhanced logging: Redis write confirmation\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write pending  ' + enrichedSlots.length + ' slots, key=' + redisKey + ', fetchedAt=' + cachePayload.fetchedAt);\n            const cycleStart = flow.get('slotCacheRefreshCycleStart');\n            if (cycleStart) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': Cycle elapsed: ' + Math.round((Date.now() - cycleStart)/1000) + 's');\n            }\n\n            // Verify Redis write after a short delay (downstream redis-store node)\n            setTimeout(async () => {\n                try {\n                    const verify = await verifyRedisWrite(redisKey, enrichedSlots.length);\n                    if (verify.verified) {\n                        node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write VERIFIED OK  ' + verify.slotCount + ' slots confirmed in key=' + redisKey);\n                    } else {\n                        node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write VERIFY FAILED  ' + verify.error);\n                    }\n                } catch (e) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis verify error: ' + e.message);\n                }\n\n                // Log refresh cycle summary if this is Tier 3 (last tier)\n                if (TIER === 3 && cycleStart) {\n                    const t1 = flow.get('slotCacheSummary_Tier1');\n                    const t2 = flow.get('slotCacheSummary_Tier2');\n                    const t3 = flow.get('slotCacheSummary_Tier3');\n                    node.warn('[SLOT_CACHE] Refresh cycle complete  T1:' + (t1 ? t1.slotCount : '?') + ' T2:' + (t2 ? t2.slotCount : '?') + ' T3:' + (t3 ? t3.slotCount : '?') + ' slots stored at ' + new Date().toISOString() + ' (total elapsed: ' + Math.round((Date.now() - cycleStart)/1000) + 's)');\n                }\n            }, 3000);\n\n            return msg;\n\n        } catch (error) {\n            lastError = error.message;\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Attempt ' + attempt + ' failed: ' + error.message);\n\n            if (attempt >= RETRY_CONFIG.maxAttempts) {\n                break;\n            }\n        }\n    }\n\n    // All retries exhausted\n    node.error('[SLOT_CACHE] Tier ' + TIER + ' FAILED after ' + attempt + ' attempts: ' + lastError);\n\n    // v10: Update health tracking\n    const health = updateHealthTracking(false, lastError);\n\n    // v11: Phase 4H - Log refresh failure to history\n    const failHistory = flow.get('slotCacheRefreshHistory') || [];\n    failHistory.push({ timestamp: new Date().toISOString(), tier: TIER, success: false, slotCount: 0, error: lastError });\n    if (failHistory.length > 100) failHistory.shift();\n    flow.set('slotCacheRefreshHistory', failHistory);\n\n    msg.tierResult = {\n        tier: TIER,\n        success: false,\n        error: lastError,\n        attempts: attempt,\n        consecutiveFailures: health.consecutiveFailures,\n        fetchDurationMs: Date.now() - startTime\n    };\n\n    return null; // Don't store on error\n}\n\nreturn fetchAndCacheTier();",
    "outputs": 1,
    "timeout": 180,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 600,
    "y": 135,
    "wires": [
      [
        "redis-store-tier2",
        "debug-redis-refresh"
      ]
    ]
  },
  {
    "id": "func-fetch-tier3",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Fetch Tier 3 (90 days)",
    "func": "// Fetch slots for Tier 3 (90 days) and store in Redis\n// v10: Phase 4F - Added retry logic, rate limit handling, Redis verification, health tracking\nconst TIER = 3;\nconst TIER_DAYS = 90;\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx',\n    clientId: 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    userName: 'Intelepeer',\n    password: '$#1Nt-p33R-AwS#$',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    defaultLocationGUID: '1fef9297-7c8b-426b-b0d1-f2275136e48b'\n};\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\n// v10: Retry configuration\nconst RETRY_CONFIG = {\n    maxAttempts: 3,\n    baseDelayMs: 5000,      // 5s initial delay\n    maxDelayMs: 30000,      // 30s max delay\n    rateLimitDelayMs: 15000 // 15s delay on rate limit\n};\n\n// v10: Redis configuration for verification\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const errorCodeMatch = xmlText.match(/<ErrorCode>([^<]+)<\\/ErrorCode>/);\n    const errorCode = errorCodeMatch ? parseInt(errorCodeMatch[1]) : null;\n    const errorMsgMatch = xmlText.match(/<ErrorMessage>([^<]+)<\\/ErrorMessage>/);\n    const errorMessage = errorMsgMatch ? errorMsgMatch[1] : null;\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, errorCode, errorMessage, records };\n}\n\nfunction groupSlotsByDate(slots) {\n    const grouped = {};\n    slots.forEach(slot => {\n        const dateMatch = (slot.startTime || slot.StartTime || '').match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n        if (dateMatch) {\n            const date = dateMatch[1];\n            if (!grouped[date]) grouped[date] = [];\n            grouped[date].push(slot);\n        }\n    });\n    return Object.entries(grouped).map(([date, slots]) => ({\n        date: date,\n        slots: slots,\n        slotCount: slots.length\n    })).sort((a, b) => new Date(a.date) - new Date(b.date));\n}\n\n// v10: Verify Redis write by reading back\nasync function verifyRedisWrite(key, expectedSlotCount) {\n    try {\n        const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(key);\n        const response = await fetch(getUrl, {\n            method: 'GET',\n            headers: { 'Authorization': REDIS_AUTH },\n            timeout: 5000\n        });\n        if (!response.ok) return { verified: false, error: 'HTTP ' + response.status };\n        const text = await response.text();\n        if (!text || text === 'null') return { verified: false, error: 'Empty response' };\n        const data = JSON.parse(text);\n        if (data.slotCount === expectedSlotCount) {\n            return { verified: true, slotCount: data.slotCount };\n        }\n        return { verified: false, error: 'Count mismatch: expected ' + expectedSlotCount + ', got ' + data.slotCount };\n    } catch (e) {\n        return { verified: false, error: e.message };\n    }\n}\n\n// v10: Track health in flow context\nfunction updateHealthTracking(success, error) {\n    const healthKey = 'slotCacheHealth_Tier' + TIER;\n    const health = flow.get(healthKey) || { consecutiveFailures: 0, lastSuccess: null, lastError: null };\n\n    if (success) {\n        health.consecutiveFailures = 0;\n        health.lastSuccess = new Date().toISOString();\n        health.lastError = null;\n    } else {\n        health.consecutiveFailures++;\n        health.lastError = { timestamp: new Date().toISOString(), message: error };\n    }\n\n    flow.set(healthKey, health);\n\n    // Warn if 3+ consecutive failures\n    if (health.consecutiveFailures >= 3) {\n        node.error('[SLOT_CACHE] ALERT: Tier ' + TIER + ' has failed ' + health.consecutiveFailures + ' consecutive times!');\n    }\n\n    return health;\n}\n\nasync function fetchAndCacheTier() {\n    const startTime = Date.now();\n    const today = new Date();\n    const startDate = formatDate(today);\n    const endDate = formatDate(new Date(today.getTime() + TIER_DAYS * 24 * 60 * 60 * 1000));\n    const locationGUID = CLOUD9.defaultLocationGUID;\n\n    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Fetching ' + startDate + ' to ' + endDate);\n\n    let lastError = null;\n    let attempt = 0;\n\n    // v10: Retry loop with exponential backoff\n    while (attempt < RETRY_CONFIG.maxAttempts) {\n        attempt++;\n\n        if (attempt > 1) {\n            // Calculate delay with exponential backoff\n            const backoffDelay = Math.min(\n                RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt - 2),\n                RETRY_CONFIG.maxDelayMs\n            );\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Retry ' + attempt + '/' + RETRY_CONFIG.maxAttempts + ' after ' + backoffDelay + 'ms');\n            await delay(backoffDelay);\n        }\n\n        try {\n            const xmlRequest = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <ClientID>${CLOUD9.clientId}</ClientID>\n    <UserName>${CLOUD9.userName}</UserName>\n    <Password>${escapeXml(CLOUD9.password)}</Password>\n    <Procedure>GetOnlineReservations</Procedure>\n    <Parameters>\n        <startDate>${startDate} 7:00:00 AM</startDate>\n        <endDate>${endDate} 5:00:00 PM</endDate>\n        <morning>True</morning>\n        <afternoon>True</afternoon>\n    </Parameters>\n</GetDataRequest>`;\n\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xmlRequest,\n                timeout: 120000\n            });\n\n            if (!response.ok) {\n                throw new Error('HTTP ' + response.status);\n            }\n\n            const xmlText = await response.text();\n            const parsed = parseXmlResponse(xmlText);\n\n            // v10: Check for Cloud9 error codes\n            if (parsed.status !== 'Success') {\n                // ErrorCode 8 = Rate limit\n                if (parsed.errorCode === 8) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Rate limited (ErrorCode 8), waiting ' + RETRY_CONFIG.rateLimitDelayMs + 'ms');\n                    lastError = 'Rate limit (ErrorCode 8): ' + parsed.errorMessage;\n                    await delay(RETRY_CONFIG.rateLimitDelayMs);\n                    continue; // Retry\n                }\n                throw new Error('Cloud9 Error ' + parsed.errorCode + ': ' + parsed.errorMessage);\n            }\n\n            // Filter by location\n            let filteredSlots = parsed.records.filter(slot =>\n                slot.LocationGUID === locationGUID\n            );\n\n            // Filter by Chair 8\n            filteredSlots = filteredSlots.filter(slot =>\n                slot.ScheduleColumnGUID === CHAIR_8_GUID\n            );\n\n            // Filter by minimum duration (40 minutes)\n            filteredSlots = filteredSlots.filter(slot =>\n                parseInt(slot.Minutes || '0') >= 40\n            );\n\n            // Enrich slots with camelCase aliases\n            const enrichedSlots = filteredSlots.map(slot => ({\n                ...slot,\n                scheduleViewGUID: slot.ScheduleViewGUID,\n                scheduleColumnGUID: slot.ScheduleColumnGUID,\n                startTime: slot.StartTime,\n                minutes: slot.Minutes || '40',\n                appointmentTypeGUID: slot.AppointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705'\n            }));\n\n            // Group by date\n            const groupedSlots = groupSlotsByDate(enrichedSlots);\n\n            const fetchDurationMs = Date.now() - startTime;\n\n            // Build Redis cache payload\n            const redisKey = 'SlotCache-' + locationGUID + '-Tier' + TIER;\n            const cachePayload = {\n                locationGUID: locationGUID,\n                scheduleViewGUID: enrichedSlots.length > 0 ? enrichedSlots[0].scheduleViewGUID : null,\n                slots: enrichedSlots,\n                groupedSlots: groupedSlots,\n                fetchedAt: new Date().toISOString(),\n                slotCount: enrichedSlots.length,\n                tier: TIER,\n                tierDays: TIER_DAYS,\n                dateRange: { start: startDate, end: endDate },\n                fetchDurationMs: fetchDurationMs,\n                attempts: attempt\n            };\n\n            \n    // Store summary in flow context for cache-health endpoint (no loopback)\n    const summaryKey = 'slotCacheSummary_Tier' + TIER;\n    const slotsByDate = {};\n    enrichedSlots.forEach(slot => {\n        const startTime = slot.StartTime || slot.startTime || '';\n        const dateMatch = startTime.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n        if (dateMatch) {\n            const date = dateMatch[1];\n            if (!slotsByDate[date]) slotsByDate[date] = 0;\n            slotsByDate[date]++;\n        }\n    });\n    const slotsByDateArray = Object.entries(slotsByDate)\n        .map(([date, count]) => ({ date, count }))\n        .sort((a, b) => new Date(a.date) - new Date(b.date))\n        .slice(0, 14);\n\n    flow.set(summaryKey, {\n        slotCount: enrichedSlots.length,\n        fetchedAt: new Date().toISOString(),\n        tierDays: TIER_DAYS,\n        dateRange: { start: startDate, end: endDate },\n        slotsByDate: slotsByDateArray\n    });\\n\\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Fetched ' + enrichedSlots.length + ' slots in ' + fetchDurationMs + 'ms (attempt ' + attempt + ')');\n\n            // v12: Rate limit detection - don't store if 0 slots + fast response\n            const MIN_EXPECTED_DURATION_MS = 1000; // Real Cloud9 queries take >1s\n            if (enrichedSlots.length === 0 && fetchDurationMs < MIN_EXPECTED_DURATION_MS) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': RATE LIMIT DETECTED - 0 slots in ' + fetchDurationMs + 'ms (too fast). NOT storing.');\n                updateHealthTracking(false, 'Rate limit (0 slots + fast response)');\n                msg.tierResult = { tier: TIER, success: false, error: 'Rate limit detected', rateLimit: true };\n                return null; // Don't store empty cache\n            }\n\n            // Prepare for Redis storage\n            msg.payload = {\n                key: redisKey,\n                value: cachePayload\n            };\n            msg.tierResult = {\n                tier: TIER,\n                slotCount: enrichedSlots.length,\n                fetchDurationMs: fetchDurationMs,\n                success: true,\n                attempts: attempt\n            };\n\n            // v10: Store verification callback for after Redis write\n            msg._verifyRedis = {\n                key: redisKey,\n                expectedSlotCount: enrichedSlots.length\n            };\n\n            // v10: Update health tracking\n            updateHealthTracking(true, null);\n\n            // v11: Phase 4H - Log refresh attempt to history\n            const history = flow.get('slotCacheRefreshHistory') || [];\n            history.push({ timestamp: new Date().toISOString(), tier: TIER, success: true, slotCount: enrichedSlots.length, error: null });\n            if (history.length > 100) history.shift();\n            flow.set('slotCacheRefreshHistory', history);\n\n            // v20: Invalidate pre-grouped cache so next request rebuilds from fresh flat data\n            const preGroupedKey = 'SlotCache-' + locationGUID + '-Tier' + TIER + '-PreGrouped';\n            const redisDELUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n            try {\n                const delResp = await fetch(redisDELUrl, {\n                    method: 'POST',\n                    headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ key: preGroupedKey, value: { invalidated: true }, ttl: 1 }),\n                    timeout: 3000\n                });\n                if (delResp.ok) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Invalidated pre-grouped cache key: ' + preGroupedKey);\n                }\n            } catch (pgErr) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': Failed to invalidate pre-grouped cache: ' + pgErr.message);\n            }\n\n            // Enhanced logging: Redis write confirmation\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write pending  ' + enrichedSlots.length + ' slots, key=' + redisKey + ', fetchedAt=' + cachePayload.fetchedAt);\n            const cycleStart = flow.get('slotCacheRefreshCycleStart');\n            if (cycleStart) {\n                node.warn('[SLOT_CACHE] Tier ' + TIER + ': Cycle elapsed: ' + Math.round((Date.now() - cycleStart)/1000) + 's');\n            }\n\n            // Verify Redis write after a short delay (downstream redis-store node)\n            setTimeout(async () => {\n                try {\n                    const verify = await verifyRedisWrite(redisKey, enrichedSlots.length);\n                    if (verify.verified) {\n                        node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write VERIFIED OK  ' + verify.slotCount + ' slots confirmed in key=' + redisKey);\n                    } else {\n                        node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis write VERIFY FAILED  ' + verify.error);\n                    }\n                } catch (e) {\n                    node.warn('[SLOT_CACHE] Tier ' + TIER + ': Redis verify error: ' + e.message);\n                }\n\n                // Log refresh cycle summary if this is Tier 3 (last tier)\n                if (TIER === 3 && cycleStart) {\n                    const t1 = flow.get('slotCacheSummary_Tier1');\n                    const t2 = flow.get('slotCacheSummary_Tier2');\n                    const t3 = flow.get('slotCacheSummary_Tier3');\n                    node.warn('[SLOT_CACHE] Refresh cycle complete  T1:' + (t1 ? t1.slotCount : '?') + ' T2:' + (t2 ? t2.slotCount : '?') + ' T3:' + (t3 ? t3.slotCount : '?') + ' slots stored at ' + new Date().toISOString() + ' (total elapsed: ' + Math.round((Date.now() - cycleStart)/1000) + 's)');\n                }\n            }, 3000);\n\n            return msg;\n\n        } catch (error) {\n            lastError = error.message;\n            node.warn('[SLOT_CACHE] Tier ' + TIER + ': Attempt ' + attempt + ' failed: ' + error.message);\n\n            if (attempt >= RETRY_CONFIG.maxAttempts) {\n                break;\n            }\n        }\n    }\n\n    // All retries exhausted\n    node.error('[SLOT_CACHE] Tier ' + TIER + ' FAILED after ' + attempt + ' attempts: ' + lastError);\n\n    // v10: Update health tracking\n    const health = updateHealthTracking(false, lastError);\n\n    // v11: Phase 4H - Log refresh failure to history\n    const failHistory = flow.get('slotCacheRefreshHistory') || [];\n    failHistory.push({ timestamp: new Date().toISOString(), tier: TIER, success: false, slotCount: 0, error: lastError });\n    if (failHistory.length > 100) failHistory.shift();\n    flow.set('slotCacheRefreshHistory', failHistory);\n\n    msg.tierResult = {\n        tier: TIER,\n        success: false,\n        error: lastError,\n        attempts: attempt,\n        consecutiveFailures: health.consecutiveFailures,\n        fetchDurationMs: Date.now() - startTime\n    };\n\n    return null; // Don't store on error\n}\n\nreturn fetchAndCacheTier();",
    "outputs": 1,
    "timeout": 180,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 600,
    "y": 205,
    "wires": [
      [
        "redis-store-tier3",
        "debug-redis-refresh"
      ]
    ]
  },
  {
    "id": "redis-store-tier1",
    "type": "redis-variable",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Store Tier 1",
    "redisConfig": "ca11676be357e7d6",
    "operation": "set",
    "x": 850,
    "y": 65,
    "wires": [
      []
    ]
  },
  {
    "id": "redis-store-tier2",
    "type": "redis-variable",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Store Tier 2",
    "redisConfig": "ca11676be357e7d6",
    "operation": "set",
    "x": 850,
    "y": 135,
    "wires": [
      []
    ]
  },
  {
    "id": "redis-store-tier3",
    "type": "redis-variable",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Store Tier 3",
    "redisConfig": "ca11676be357e7d6",
    "operation": "set",
    "x": 850,
    "y": 205,
    "wires": [
      []
    ]
  },
  {
    "id": "debug-redis-refresh",
    "type": "debug",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Redis Refresh Log",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "tierResult",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1050,
    "y": 135,
    "wires": []
  },
  {
    "id": "http-in-redis-trigger",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "",
    "url": "/test/redis-slot-cache/trigger",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 360,
    "wires": [
      [
        "func-redis-trigger",
        "debug-redis-test"
      ]
    ]
  },
  {
    "id": "func-redis-trigger",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "Manual Trigger v2 (Retry + HTTP Redis)",
    "func": "// Manual trigger endpoint - bypasses business hours check\n// v2: Added retry logic with 5s delays, fixed Redis writes via HTTP endpoint\n// Useful for testing and initial cache population\n\nconst TIERS = [1, 2, 3];\nconst TIER_DAYS = [30, 60, 90];\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx',\n    clientId: 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    userName: 'Intelepeer',\n    password: '$#1Nt-p33R-AwS#$',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    defaultLocationGUID: '1fef9297-7c8b-426b-b0d1-f2275136e48b'\n};\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\n// v2: Retry configuration\nconst RETRY_CONFIG = {\n    maxRetries: 3,\n    retryDelayMs: 5000,         // 5 seconds between retries\n    retryOnZeroResults: true,\n    delayBetweenTiersMs: 5000   // 5 seconds between tier fetches\n};\n\n// v2: Redis SET endpoint (internal call)\nconst REDIS_SET_URL = 'http://127.0.0.1:1880/FabricWorkflow/api/chord/ortho-prd/redisSet';\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return `${month}/${day}/${d.getFullYear()}`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\nfunction groupSlotsByDate(slots) {\n    const grouped = {};\n    slots.forEach(slot => {\n        const dateMatch = (slot.startTime || slot.StartTime || '').match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n        if (dateMatch) {\n            const date = dateMatch[1];\n            if (!grouped[date]) grouped[date] = [];\n            grouped[date].push(slot);\n        }\n    });\n    return Object.entries(grouped).map(([date, slots]) => ({\n        date: date,\n        slots: slots,\n        slotCount: slots.length\n    })).sort((a, b) => new Date(a.date) - new Date(b.date));\n}\n\n// v2: Fetch with retry logic\nasync function fetchCloud9WithRetry(tier, tierDays) {\n    const today = new Date();\n    const startDate = formatDate(today);\n    const endDate = formatDate(new Date(today.getTime() + tierDays * 24 * 60 * 60 * 1000));\n    const locationGUID = CLOUD9.defaultLocationGUID;\n\n    const xmlRequest = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <ClientID>${CLOUD9.clientId}</ClientID>\n    <UserName>${CLOUD9.userName}</UserName>\n    <Password>${escapeXml(CLOUD9.password)}</Password>\n    <Procedure>GetOnlineReservations</Procedure>\n    <Parameters>\n        <startDate>${startDate} 7:00:00 AM</startDate>\n        <endDate>${endDate} 5:00:00 PM</endDate>\n        <morning>True</morning>\n        <afternoon>True</afternoon>\n    </Parameters>\n</GetDataRequest>`;\n\n    let lastError = null;\n    let records = [];\n    let totalRetries = 0;\n\n    for (let retry = 0; retry <= RETRY_CONFIG.maxRetries; retry++) {\n        try {\n            if (retry > 0) {\n                node.warn(`[v2 RETRY] Tier ${tier} - Retry ${retry}/${RETRY_CONFIG.maxRetries}, waiting 5s...`);\n                await delay(RETRY_CONFIG.retryDelayMs);\n            }\n\n            const fetchStart = Date.now();\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xmlRequest,\n                timeout: 120000\n            });\n\n            if (!response.ok) {\n                throw new Error('HTTP ' + response.status);\n            }\n\n            const xmlText = await response.text();\n            const parsed = parseXmlResponse(xmlText);\n            records = parsed.records;\n\n            // Check for zero-result rate limiting\n            if (RETRY_CONFIG.retryOnZeroResults && records.length === 0 && retry < RETRY_CONFIG.maxRetries) {\n                node.warn(`[v2 RETRY] Tier ${tier} - Got 0 results (possible rate limit), will retry...`);\n                totalRetries++;\n                continue;\n            }\n\n            // Success!\n            return {\n                success: true,\n                records: records,\n                totalRecords: records.length,\n                retries: totalRetries,\n                fetchDurationMs: Date.now() - fetchStart,\n                startDate: startDate,\n                endDate: endDate\n            };\n\n        } catch (error) {\n            lastError = error;\n            totalRetries++;\n            node.warn(`[v2 RETRY] Tier ${tier} - Error: ${error.message}`);\n        }\n    }\n\n    return {\n        success: false,\n        error: lastError?.message || 'All retries exhausted',\n        records: records,\n        retries: totalRetries\n    };\n}\n\n// v2: Store in Redis via HTTP endpoint instead of global context\nasync function storeInRedis(key, value) {\n    try {\n        const response = await fetch(REDIS_SET_URL, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ key, value }),\n            timeout: 30000\n        });\n\n        if (!response.ok) {\n            throw new Error('HTTP ' + response.status);\n        }\n\n        const result = await response.json();\n        return result.success === true;\n    } catch (error) {\n        node.error(`[v2] Redis store failed for ${key}: ${error.message}`);\n        return false;\n    }\n}\n\nasync function fetchTier(tier, tierDays) {\n    const startTime = Date.now();\n    const locationGUID = CLOUD9.defaultLocationGUID;\n\n    // Fetch with retry\n    const fetchResult = await fetchCloud9WithRetry(tier, tierDays);\n\n    if (!fetchResult.success) {\n        return {\n            tier: tier,\n            tierDays: tierDays,\n            success: false,\n            error: fetchResult.error,\n            retries: fetchResult.retries,\n            fetchDurationMs: Date.now() - startTime\n        };\n    }\n\n    // Filter slots\n    let filteredSlots = fetchResult.records.filter(slot =>\n        slot.LocationGUID === locationGUID &&\n        slot.ScheduleColumnGUID === CHAIR_8_GUID &&\n        parseInt(slot.Minutes || '0') >= 40\n    );\n\n    node.warn(`[v2] Tier ${tier}: ${fetchResult.totalRecords} total -> ${filteredSlots.length} Chair 8 slots (${fetchResult.retries} retries)`);\n\n    const enrichedSlots = filteredSlots.map(slot => ({\n        ...slot,\n        scheduleViewGUID: slot.ScheduleViewGUID,\n        scheduleColumnGUID: slot.ScheduleColumnGUID,\n        startTime: slot.StartTime,\n        minutes: slot.Minutes || '40',\n        appointmentTypeGUID: slot.AppointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705'\n    }));\n\n    const redisKey = `SlotCache-${locationGUID}-Tier${tier}`;\n    const payload = {\n        locationGUID: locationGUID,\n        scheduleViewGUID: enrichedSlots.length > 0 ? enrichedSlots[0].scheduleViewGUID : null,\n        slots: enrichedSlots,\n        groupedSlots: groupSlotsByDate(enrichedSlots),\n        fetchedAt: new Date().toISOString(),\n        slotCount: enrichedSlots.length,\n        tier: tier,\n        tierDays: tierDays,\n        dateRange: { start: fetchResult.startDate, end: fetchResult.endDate },\n        fetchDurationMs: Date.now() - startTime,\n        retries: fetchResult.retries,\n        source: 'manual-trigger-v2'\n    };\n\n    // v2: Store via HTTP endpoint\n    const stored = await storeInRedis(redisKey, payload);\n\n    return {\n        tier: tier,\n        tierDays: tierDays,\n        redisKey: redisKey,\n        success: true,\n        slotCount: enrichedSlots.length,\n        fetchDurationMs: Date.now() - startTime,\n        retries: fetchResult.retries,\n        redisStored: stored\n    };\n}\n\nasync function triggerRefresh() {\n    const startTime = Date.now();\n    const results = [];\n\n    node.warn('[v2 MANUAL_TRIGGER] Starting cache refresh with retry logic...');\n\n    // Fetch all tiers sequentially with 5s delay between each\n    for (let i = 0; i < TIERS.length; i++) {\n        if (i > 0) {\n            node.warn(`[v2] Waiting ${RETRY_CONFIG.delayBetweenTiersMs / 1000}s before Tier ${TIERS[i]}...`);\n            await delay(RETRY_CONFIG.delayBetweenTiersMs);\n        }\n\n        const result = await fetchTier(TIERS[i], TIER_DAYS[i]);\n        results.push(result);\n\n        if (result.success) {\n            node.warn(`[v2] Tier ${result.tier}: ${result.slotCount} slots, stored=${result.redisStored}`);\n        } else {\n            node.warn(`[v2] Tier ${result.tier}: FAILED - ${result.error}`);\n        }\n    }\n\n    const totalDurationMs = Date.now() - startTime;\n    const totalSlots = results.filter(r => r.success).reduce((sum, r) => sum + r.slotCount, 0);\n    const totalRetries = results.reduce((sum, r) => sum + (r.retries || 0), 0);\n\n    node.warn(`[v2 MANUAL_TRIGGER] Complete: ${totalSlots} slots in ${totalDurationMs}ms (${totalRetries} total retries)`);\n\n    msg.payload = {\n        success: results.every(r => r.success),\n        totalDurationMs: totalDurationMs,\n        totalSlotsCached: totalSlots,\n        totalRetries: totalRetries,\n        tiers: results.map(r => ({\n            tier: r.tier,\n            tierDays: r.tierDays,\n            success: r.success,\n            slotCount: r.slotCount || 0,\n            fetchDurationMs: r.fetchDurationMs,\n            retries: r.retries || 0,\n            redisKey: r.redisKey,\n            redisStored: r.redisStored,\n            error: r.error\n        }))\n    };\n\n    return msg;\n}\n\nreturn triggerRefresh();\n",
    "outputs": 1,
    "timeout": 600,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 400,
    "y": 360,
    "wires": [
      [
        "http-out-redis-trigger"
      ]
    ]
  },
  {
    "id": "http-out-redis-trigger",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 700,
    "y": 360,
    "wires": []
  },
  {
    "id": "http-in-redis-status",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "",
    "url": "/test/redis-slot-cache/status",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 430,
    "wires": [
      [
        "func-redis-status",
        "debug-redis-test"
      ]
    ]
  },
  {
    "id": "func-redis-status",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "Get Redis Cache Status",
    "func": "// Returns status of all Redis slot cache keys\n// This will be enhanced to actually read from Redis\n\nconst TIERS = [1, 2, 3];\nconst locationGUID = '1fef9297-7c8b-426b-b0d1-f2275136e48b';\n\nconst MAX_CACHE_AGE_MS = 5 * 60 * 1000; // 5 minutes\n\n// For now, return placeholder - the actual Redis read will be done via redis-variable node\nmsg.redisTiers = TIERS.map(tier => ({\n    tier: tier,\n    redisKey: `SlotCache-${locationGUID}-Tier${tier}`,\n    status: 'checking'\n}));\n\n// Set up the response structure that will be filled by subsequent redis reads\nmsg.pendingReads = TIERS.length;\nmsg.cacheStatus = {\n    timestamp: new Date().toISOString(),\n    maxCacheAgeMs: MAX_CACHE_AGE_MS,\n    tiers: []\n};\n\n// For the HTTP response, we'll return a simple status\nmsg.payload = {\n    message: 'Use POST /test/redis-slot-cache/status/full for detailed status',\n    cacheKeys: TIERS.map(t => `SlotCache-${locationGUID}-Tier${t}`),\n    hint: 'Redis status endpoint - cache keys listed above'\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": 10,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 430,
    "wires": [
      [
        "http-out-redis-status"
      ]
    ]
  },
  {
    "id": "http-out-redis-status",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 700,
    "y": 430,
    "wires": []
  },
  {
    "id": "http-in-redis-clear",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "",
    "url": "/test/redis-slot-cache/clear",
    "method": "delete",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 500,
    "wires": [
      [
        "func-redis-clear",
        "debug-redis-test"
      ]
    ]
  },
  {
    "id": "func-redis-clear",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "Clear Redis Cache",
    "func": "// Clears Redis slot cache keys\n// Note: Actual deletion will be done via redis-variable node with DEL operation\n\nconst TIERS = [1, 2, 3];\nconst locationGUID = '1fef9297-7c8b-426b-b0d1-f2275136e48b';\n\nconst keysToDelete = TIERS.map(tier => `SlotCache-${locationGUID}-Tier${tier}`);\n\nnode.warn('[REDIS_CLEAR] Clearing cache keys: ' + keysToDelete.join(', '));\n\nmsg.payload = {\n    cleared: true,\n    keysCleared: keysToDelete,\n    message: 'Cache keys marked for deletion (Redis DEL operation will be performed)'\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": 10,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 500,
    "wires": [
      [
        "http-out-redis-clear"
      ]
    ]
  },
  {
    "id": "http-out-redis-clear",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 700,
    "y": 500,
    "wires": []
  },
  {
    "id": "debug-redis-test",
    "type": "debug",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-test",
    "name": "Redis Test Ops",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "statusVal": "",
    "statusType": "auto",
    "x": 800,
    "y": 500,
    "wires": []
  },
  {
    "id": "grp-redis-get-endpoint",
    "type": "group",
    "z": "slot-cache-redis-tab",
    "name": "Redis GET Endpoint (for Flowise Tool)",
    "style": {
      "label": true,
      "fill": "#3366cc",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-redis-get",
      "func-redis-get-prepare",
      "redis-get-slot-cache",
      "func-redis-get-format",
      "http-out-redis-get",
      "debug-redis-get"
    ],
    "x": 14,
    "y": 600,
    "w": 920,
    "h": 200
  },
  {
    "id": "http-in-redis-get",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-get-endpoint",
    "name": "",
    "url": "/chord/ortho-prd/redisGet",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 680,
    "wires": [
      [
        "func-redis-get-prepare",
        "debug-redis-get"
      ]
    ]
  },
  {
    "id": "func-redis-get-prepare",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-get-endpoint",
    "name": "Prepare Redis GET",
    "func": "// Prepare Redis GET request\n// Endpoint: GET /chord/ortho-prd/redisGet?key=SlotCache-{locationGUID}-Tier{1|2|3}\n\nconst key = msg.req.query.key;\n\nif (!key) {\n    msg.payload = { error: 'Missing required query parameter: key' };\n    msg.statusCode = 400;\n    return [null, msg];\n}\n\nnode.warn('[REDIS_GET] Fetching key: ' + key);\n\n// Set the key for the redis-variable node\nmsg.redisKey = key;\nmsg.payload = key;\n\nreturn [msg, null];",
    "outputs": 2,
    "timeout": 5,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 330,
    "y": 680,
    "wires": [
      [
        "redis-get-slot-cache"
      ],
      [
        "http-out-redis-get"
      ]
    ]
  },
  {
    "id": "redis-get-slot-cache",
    "type": "redis-variable",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-get-endpoint",
    "name": "GET from Redis",
    "redisConfig": "ca11676be357e7d6",
    "operation": "get",
    "x": 530,
    "y": 680,
    "wires": [
      [
        "func-redis-get-format"
      ]
    ]
  },
  {
    "id": "func-redis-get-format",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-get-endpoint",
    "name": "Format Response",
    "func": "// Format Redis GET response\n\nif (msg.payload === null || msg.payload === undefined) {\n    node.warn('[REDIS_GET] Key not found: ' + msg.redisKey);\n    msg.payload = null;\n    msg.statusCode = 200; // Return 200 with null payload for cache miss\n} else {\n    node.warn('[REDIS_GET] Found key: ' + msg.redisKey + ' (' + (typeof msg.payload === 'string' ? msg.payload.length : 0) + ' bytes)');\n    // Payload is already the cached value - return as-is\n    // The tool will parse the JSON\n}\n\nreturn msg;",
    "outputs": 1,
    "timeout": 5,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 730,
    "y": 680,
    "wires": [
      [
        "http-out-redis-get"
      ]
    ]
  },
  {
    "id": "http-out-redis-get",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-get-endpoint",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 930,
    "y": 680,
    "wires": []
  },
  {
    "id": "debug-redis-get",
    "type": "debug",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-get-endpoint",
    "name": "Redis GET Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "statusVal": "",
    "statusType": "auto",
    "x": 530,
    "y": 750,
    "wires": []
  },
  {
    "id": "grp-redis-set-endpoint",
    "type": "group",
    "z": "slot-cache-redis-tab",
    "name": "Redis SET Endpoint (for External Cache Population)",
    "style": {
      "label": true,
      "fill": "#cc6633",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-redis-set",
      "func-redis-set-prepare",
      "redis-set-slot-cache",
      "func-redis-set-format",
      "http-out-redis-set",
      "debug-redis-set"
    ],
    "x": 14,
    "y": 1190,
    "w": 920,
    "h": 180
  },
  {
    "id": "http-in-redis-set",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-set-endpoint",
    "name": "",
    "url": "/chord/ortho-prd/redisSet",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 1250,
    "wires": [
      [
        "func-redis-set-prepare",
        "debug-redis-set"
      ]
    ]
  },
  {
    "id": "func-redis-set-prepare",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-set-endpoint",
    "name": "Prepare Redis SET",
    "func": "// Prepare Redis SET request\n// Endpoint: POST /chord/ortho-prd/redisSet\n// Body: { key: 'SlotCache-{locationGUID}-Tier{1|2|3}', value: {...cachePayload} }\n//\n// CRITICAL: Use msg.payload.key and msg.payload.value format\n// (This matches the working production pattern in GaidStreamHandler)\n\nconst inputKey = msg.payload.key;\nconst inputValue = msg.payload.value;\n\nif (!inputKey) {\n    msg.payload = { error: 'Missing required field: key' };\n    msg.statusCode = 400;\n    return [null, msg];\n}\n\nif (!inputValue) {\n    msg.payload = { error: 'Missing required field: value' };\n    msg.statusCode = 400;\n    return [null, msg];\n}\n\n// Store for response formatting\nmsg.redisKey = inputKey;\n\n// redis-variable SET expects msg.payload.key and msg.payload.value\nconst valueStr = typeof inputValue === 'string' ? inputValue : JSON.stringify(inputValue);\nnode.warn('[REDIS_SET] Storing key: ' + inputKey + ' (' + valueStr.length + ' bytes)');\n\nmsg.payload = {\n    key: inputKey,\n    value: valueStr\n};\n\nreturn [msg, null];",
    "outputs": 2,
    "timeout": 30,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 330,
    "y": 1250,
    "wires": [
      [
        "redis-set-slot-cache"
      ],
      [
        "http-out-redis-set"
      ]
    ]
  },
  {
    "id": "redis-set-slot-cache",
    "type": "redis-variable",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-set-endpoint",
    "name": "SET to Redis",
    "redisConfig": "ca11676be357e7d6",
    "operation": "set",
    "x": 530,
    "y": 1250,
    "wires": [
      [
        "func-redis-set-format"
      ]
    ]
  },
  {
    "id": "func-redis-set-format",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-set-endpoint",
    "name": "Format Response",
    "func": "// Format Redis SET response\n\nnode.warn('[REDIS_SET] Stored key: ' + msg.redisKey);\n\nmsg.payload = {\n    success: true,\n    key: msg.redisKey,\n    message: 'Key stored successfully'\n};\nmsg.statusCode = 200;\n\nreturn msg;",
    "outputs": 1,
    "timeout": 5,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 730,
    "y": 1250,
    "wires": [
      [
        "http-out-redis-set"
      ]
    ]
  },
  {
    "id": "http-out-redis-set",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-set-endpoint",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 930,
    "y": 1250,
    "wires": []
  },
  {
    "id": "debug-redis-set",
    "type": "debug",
    "z": "slot-cache-redis-tab",
    "g": "grp-redis-set-endpoint",
    "name": "Redis SET Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "statusVal": "",
    "statusType": "auto",
    "x": 530,
    "y": 1320,
    "wires": []
  },
  {
    "id": "ca11676be357e7d6",
    "type": "redis-variable-config",
    "name": "Slot-Cache-Redis",
    "cluster": false,
    "host": "10.118.1.5",
    "hostType": "str",
    "hostContext": "",
    "port": "6378",
    "portType": "str",
    "portContext": "",
    "database": "0",
    "databaseType": "str",
    "databaseContext": "",
    "passwordType": "str",
    "passwordContext": "",
    "usernameType": "str",
    "usernameContext": "",
    "enableTLS": true,
    "tlsRejectUnauthorized": false,
    "tlsCertType": "env",
    "tlsCertContext": "",
    "tlsKeyType": "str",
    "tlsKeyContext": "",
    "tlsCaType": "str",
    "tlsCaContext": "",
    "options": "{}",
    "optionsType": "json",
    "optionsContext": ""
  },
  {
    "id": "inject-startup-prewarm",
    "type": "inject",
    "z": "slot-cache-redis-tab",
    "g": "grp-slot-cache-redis-refresh",
    "name": "Startup Pre-warm (10s after deploy)",
    "props": [
      {
        "p": "topic",
        "vt": "str",
        "v": "startup-prewarm"
      },
      {
        "p": "payload",
        "v": "",
        "vt": "date"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "10",
    "topic": "startup-prewarm",
    "x": 100,
    "y": 170,
    "wires": [
      [
        "func-check-business-hours"
      ]
    ]
  },
  {
    "id": "grp-cache-operations",
    "type": "group",
    "z": "slot-cache-redis-tab",
    "name": "Cache Health & Operations (Phase 4H/4I)",
    "style": {
      "label": true,
      "fill": "#00aaff",
      "color": "#ffffff"
    },
    "nodes": [
      "http-in-cache-health",
      "func-cache-health",
      "http-out-cache-health",
      "http-in-cache-force-refresh",
      "func-cache-force-refresh",
      "http-out-cache-force-refresh",
      "http-in-cache-clear-all",
      "func-cache-clear-all",
      "http-out-cache-clear-all",
      "http-in-cache-trigger",
      "func-cache-trigger",
      "http-out-cache-trigger"
    ],
    "x": 14,
    "y": 820,
    "w": 750,
    "h": 330
  },
  {
    "id": "http-in-cache-health",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "",
    "url": "/chord/ortho-prd/cache-health",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 950,
    "wires": [
      [
        "func-cache-health"
      ]
    ]
  },
  {
    "id": "func-cache-health",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "Get Cache Health (Phase 4H v2 - Redis)",
    "func": "// Phase 4H v2: Cache Health Monitoring - Reads from Redis directly (load-balancer safe)\n// v2: Fixed to read from shared Redis instead of per-instance flow context\n\nconst TIERS = [1, 2, 3];\nconst MAX_CACHE_AGE_MS = 5 * 60 * 1000;  // 5 min\nconst HARD_STALE_MS = 10 * 60 * 1000;    // 10 min\n\nconst LOCATION_GUID = env.get('defaultLocationGUID') || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n\nasync function fetchFromRedis(tier) {\n    const key = 'SlotCache-' + LOCATION_GUID + '-Tier' + tier;\n    const url = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(key);\n\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: { 'Authorization': REDIS_AUTH },\n            timeout: 5000\n        });\n\n        if (!response.ok) {\n            node.warn('[SLOT_CACHE] Health: Redis fetch FAILED for Tier ' + tier + '  HTTP ' + response.status);\n            return { tier, error: 'HTTP ' + response.status };\n        }\n\n        const text = await response.text();\n        if (!text || text === 'null') {\n            return { tier, data: null };\n        }\n\n        return { tier, data: JSON.parse(text) };\n    } catch (e) {\n        node.warn('[SLOT_CACHE] Health: Redis fetch ERROR for Tier ' + tier + '  ' + e.message);\n        return { tier, error: e.message };\n    }\n}\n\nasync function getCacheHealth() {\n    // Fetch all tiers from Redis in parallel\n    const results = await Promise.all(TIERS.map(tier => fetchFromRedis(tier)));\n\n    const tierResults = [];\n    let overallStatus = 'healthy';\n    let totalSlots = 0;\n    let staleTiers = 0;\n    let criticalStaleTiers = 0;\n    let failedTiers = 0;\n\n    // Still read refresh history from flow context (acceptable as it's informational)\n    const refreshHistory = flow.get('slotCacheRefreshHistory') || [];\n\n    for (const result of results) {\n        const tier = result.tier;\n        const tierDays = tier === 1 ? 30 : (tier === 2 ? 60 : 90);\n\n        // Read health tracking from flow context (informational only)\n        const healthKey = 'slotCacheHealth_Tier' + tier;\n        const health = flow.get(healthKey) || {\n            consecutiveFailures: 0,\n            lastSuccess: null,\n            lastError: null\n        };\n\n        if (result.error) {\n            failedTiers++;\n            tierResults.push({\n                tier: tier,\n                tierDays: tierDays,\n                status: 'error',\n                slotCount: 0,\n                ageSeconds: 0,\n                fetchedAt: null,\n                dateRange: null,\n                consecutiveFailures: health.consecutiveFailures,\n                lastSuccess: health.lastSuccess,\n                lastError: result.error,\n                slotsByDate: []\n            });\n            continue;\n        }\n\n        const data = result.data;\n        if (!data || !data.fetchedAt) {\n            tierResults.push({\n                tier: tier,\n                tierDays: tierDays,\n                status: 'empty',\n                slotCount: 0,\n                ageSeconds: 0,\n                fetchedAt: null,\n                dateRange: null,\n                consecutiveFailures: health.consecutiveFailures,\n                lastSuccess: health.lastSuccess,\n                lastError: health.lastError,\n                slotsByDate: []\n            });\n            continue;\n        }\n\n        const cacheAge = Date.now() - new Date(data.fetchedAt).getTime();\n        const isStale = cacheAge > MAX_CACHE_AGE_MS;\n        const isCriticalStale = cacheAge > HARD_STALE_MS;\n\n        if (isStale) staleTiers++;\n        if (isCriticalStale) criticalStaleTiers++;\n        totalSlots += data.slotCount || 0;\n\n        let status = 'fresh';\n        if (isCriticalStale) status = 'critical_stale';\n        else if (isStale) status = 'stale';\n\n        // Build slotsByDate from Redis data\n        const slotsByDate = [];\n        if (data.slots && Array.isArray(data.slots)) {\n            const dateCount = {};\n            data.slots.forEach(slot => {\n                const st = slot.StartTime || slot.startTime || '';\n                const datePart = st.split(' ')[0];\n                if (datePart && datePart.includes('/')) {\n                    dateCount[datePart] = (dateCount[datePart] || 0) + 1;\n                }\n            });\n            Object.entries(dateCount)\n                .sort((a, b) => new Date(a[0]) - new Date(b[0]))\n                .slice(0, 14)\n                .forEach(([date, count]) => slotsByDate.push({ date, count }));\n        }\n\n        tierResults.push({\n            tier: tier,\n            tierDays: data.tierDays || tierDays,\n            status: status,\n            slotCount: data.slotCount || 0,\n            ageSeconds: Math.round(cacheAge / 1000),\n            fetchedAt: data.fetchedAt,\n            dateRange: data.dateRange,\n            consecutiveFailures: health.consecutiveFailures,\n            lastSuccess: health.lastSuccess,\n            lastError: health.lastError,\n            lastInvalidation: data.lastInvalidation || null,\n            lastInvalidatedSlot: data.lastInvalidatedSlot || null,\n            lastRestoration: data.lastRestoration || null,\n            slotsByDate: slotsByDate\n        });\n    }\n\n    // Determine overall status\n    if (failedTiers >= 2 || criticalStaleTiers >= 2) overallStatus = 'unhealthy';\n    else if (failedTiers > 0 || staleTiers > 0 || criticalStaleTiers > 0) overallStatus = 'degraded';\n\n    const maxConsecutiveFailures = Math.max(...tierResults.map(t => t.consecutiveFailures || 0), 0);\n    if (maxConsecutiveFailures >= 3) overallStatus = 'unhealthy';\n\n    // Calculate refresh stats from flow context (informational)\n    const last20 = refreshHistory.slice(-20);\n    const successCount = last20.filter(r => r.success).length;\n    const failureCount = last20.filter(r => !r.success).length;\n\n    // Enhanced logging: health check diagnostics\n    const oldestAge = Math.max(...tierResults.map(t => t.ageSeconds || 0), 0);\n    node.warn('[SLOT_CACHE] Health check: status=' + overallStatus + ', staleTiers=' + staleTiers + ', oldestCacheAge=' + oldestAge + 's, totalSlots=' + totalSlots);\n\n    // Log details for any problematic tiers\n    tierResults.forEach(t => {\n        if (t.status === 'critical_stale' || t.status === 'error') {\n            node.warn('[SLOT_CACHE] Health ALERT: Tier ' + t.tier + ' status=' + t.status + ', age=' + t.ageSeconds + 's, slots=' + t.slotCount + ', failures=' + t.consecutiveFailures);\n        }\n    });\n\n    msg.payload = {\n        status: overallStatus,\n        timestamp: new Date().toISOString(),\n        summary: {\n            totalSlots: totalSlots,\n            staleTiers: staleTiers,\n            criticalStaleTiers: criticalStaleTiers,\n            failedTiers: failedTiers,\n            maxConsecutiveFailures: maxConsecutiveFailures\n        },\n        tiers: tierResults,\n        refreshStats: {\n            last20Refreshes: {\n                success: successCount,\n                failure: failureCount,\n                successRate: last20.length > 0 ? Math.round((successCount / last20.length) * 100) + '%' : 'N/A'\n            }\n        },\n        refreshHistory: last20.reverse().slice(0, 10),\n        config: {\n            maxCacheAgeMs: MAX_CACHE_AGE_MS,\n            hardStaleMs: HARD_STALE_MS,\n            refreshIntervalMs: 5 * 60 * 1000,\n            businessHours: 'Mon-Fri 7am-5pm CST'\n        }\n    };\n\n    msg.statusCode = overallStatus === 'healthy' ? 200 : (overallStatus === 'degraded' ? 200 : 503);\n    node.send(msg);\n}\n\ngetCacheHealth();\nreturn null;",
    "outputs": 1,
    "timeout": 30,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 400,
    "y": 950,
    "wires": [
      [
        "http-out-cache-health"
      ]
    ]
  },
  {
    "id": "http-out-cache-health",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 700,
    "y": 950,
    "wires": []
  },
  {
    "id": "http-in-cache-force-refresh",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "",
    "url": "/chord/ortho-prd/cache/refresh",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 1020,
    "wires": [
      [
        "func-cache-force-refresh"
      ]
    ]
  },
  {
    "id": "func-cache-force-refresh",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "Force Refresh (Phase 4I)",
    "func": "// Phase 4I v2: Force cache refresh - Sequential with retry logic\n// v2: Fixed parallel execution bug - now runs tiers SEQUENTIALLY\n// v2: Added retry logic for rate limit protection (retry on 0 slots)\n// v2: Added 5s delay between tier fetches\n\nconst TIERS = [\n    { tier: 1, days: 30 },\n    { tier: 2, days: 60 },\n    { tier: 3, days: 90 }\n];\n\n// GLOBAL RULE: Cloud9 queries must run sequentially with delays\nconst CLOUD9_RATE_LIMIT = {\n    delayBetweenCallsMs: 5000,  // 5s between Cloud9 API calls\n    maxRetries: 3,              // Retry up to 3 times\n    retryDelayMs: 5000,         // 5s before retry\n    retryOnZeroSlots: true      // Retry if tier 2/3 returns 0 (they should have slots)\n};\n\n// Read from flow environment variables (set in flow properties)\nconst locationGUID = env.get('defaultLocationGUID') || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\nconst CLOUD9_URL = env.get('cloud9Endpoint') || 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx';\nconst CLOUD9_CREDS = {\n    clientId: env.get('cloud9ClientId') || 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    user: env.get('cloud9UserName') || 'Intelepeer',\n    pass: env.get('cloud9Password') || '$#1Nt-p33R-AwS#$'\n};\n\nconst params = msg.payload || {};\nconst tierToRefresh = params.tier || 'all';\n\nnode.warn('[CACHE_OPS] Force refresh triggered for tier: ' + tierToRefresh + ' (v2 sequential)');\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nasync function fetchFromCloud9(tierConfig) {\n    const { tier, days } = tierConfig;\n    const today = new Date();\n    const endDate = new Date(today);\n    endDate.setDate(today.getDate() + days);\n\n    const formatDate = (d) => (d.getMonth()+1) + '/' + d.getDate() + '/' + d.getFullYear();\n    const startStr = formatDate(today);\n    const endStr = formatDate(endDate);\n\n    const xml = '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n        '<GetDataRequest xmlns=\"http://schemas.practica.ws/cloud9/partners/\">' +\n        '<ClientID>' + CLOUD9_CREDS.clientId + '</ClientID>' +\n        '<UserName>' + CLOUD9_CREDS.user + '</UserName>' +\n        '<Password>' + CLOUD9_CREDS.pass + '</Password>' +\n        '<Procedure>GetOnlineReservations</Procedure>' +\n        '<Parameters><startDate>' + startStr + '</startDate>' +\n        '<endDate>' + endStr + '</endDate></Parameters>' +\n        '</GetDataRequest>';\n\n    const response = await fetch(CLOUD9_URL, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/xml' },\n        body: xml,\n        timeout: 60000\n    });\n\n    if (!response.ok) throw new Error('Cloud9 HTTP ' + response.status);\n    const text = await response.text();\n\n    // Parse slots from XML with Location + Chair 8 filtering\n    const slots = [];\n    const CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(text)) !== null) {\n        const rec = match[1];\n        const getValue = (tag) => { const m = rec.match(new RegExp('<' + tag + '>([^<]*)</' + tag + '>')); return m ? m[1] : ''; };\n        const slotLocationGUID = getValue('LocationGUID');\n        const scheduleColumnGUID = getValue('ScheduleColumnGUID');\n        if (slotLocationGUID !== locationGUID) continue;\n        if (scheduleColumnGUID !== CHAIR_8_GUID) continue;\n        slots.push({\n            StartTime: getValue('StartTime'),\n            EndTime: getValue('EndTime'),\n            ScheduleColumnGUID: scheduleColumnGUID,\n            ScheduleViewGUID: getValue('ScheduleViewGUID'),\n            Minutes: getValue('Minutes'),\n            LocationGUID: getValue('LocationGUID') || locationGUID,\n            AppointmentTypeGUID: 'f6c20c35-9abb-47c2-981a-342996016705'\n        });\n    }\n\n    return { slots, startStr, endStr };\n}\n\nasync function fetchAndCacheTier(tierConfig, attempt = 1) {\n    const { tier, days } = tierConfig;\n\n    try {\n        const { slots, startStr, endStr } = await fetchFromCloud9(tierConfig);\n\n        // v2: Retry logic - if tier 2/3 returns 0 slots, likely rate limited\n        const shouldRetry = CLOUD9_RATE_LIMIT.retryOnZeroSlots &&\n                           slots.length === 0 &&\n                           tier >= 2 &&\n                           attempt < CLOUD9_RATE_LIMIT.maxRetries;\n\n        if (shouldRetry) {\n            node.warn('[CACHE_OPS] Tier ' + tier + ' returned 0 slots (attempt ' + attempt + '), retrying after delay...');\n            await delay(CLOUD9_RATE_LIMIT.retryDelayMs);\n            return fetchAndCacheTier(tierConfig, attempt + 1);\n        }\n\n        // Store in Redis\n        const redisKey = 'SlotCache-' + locationGUID + '-Tier' + tier;\n        const cacheData = {\n            locationGUID: locationGUID,\n            slots: slots,\n            slotCount: slots.length,\n            fetchedAt: new Date().toISOString(),\n            tier: tier,\n            tierDays: days,\n            dateRange: { start: startStr, end: endStr },\n            source: 'force-refresh-v2',\n            retries: attempt - 1\n        };\n\n        const setUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n        await fetch(setUrl, {\n            method: 'POST',\n            headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n            body: JSON.stringify({ key: redisKey, value: cacheData }),\n            timeout: 10000\n        });\n\n        // Store summary in flow context for cache-health\n        const slotsByDate = {};\n        slots.forEach(slot => {\n            const st = slot.StartTime || '';\n            const datePart = st.split(' ')[0];\n            if (datePart && datePart.includes('/')) {\n                if (!slotsByDate[datePart]) slotsByDate[datePart] = 0;\n                slotsByDate[datePart]++;\n            }\n        });\n        flow.set('slotCacheSummary_Tier' + tier, {\n            slotCount: slots.length,\n            fetchedAt: cacheData.fetchedAt,\n            tierDays: days,\n            dateRange: cacheData.dateRange,\n            slotsByDate: Object.entries(slotsByDate).map(([date, count]) => ({ date, count })).slice(0, 14)\n        });\n\n        node.warn('[CACHE_OPS] Tier ' + tier + ': Cached ' + slots.length + ' slots (attempts: ' + attempt + ')');\n        return { tier, success: true, slotCount: slots.length, retries: attempt - 1 };\n    } catch (e) {\n        node.warn('[CACHE_OPS] Tier ' + tier + ' error: ' + e.message);\n        return { tier, success: false, error: e.message, retries: attempt - 1 };\n    }\n}\n\nasync function doRefresh() {\n    const tiersToFetch = tierToRefresh === 'all' ? TIERS : TIERS.filter(t => t.tier === parseInt(tierToRefresh));\n    const results = [];\n\n    // v2: SEQUENTIAL execution with delays (NOT parallel)\n    for (let i = 0; i < tiersToFetch.length; i++) {\n        const tierConfig = tiersToFetch[i];\n\n        // Add delay before each tier fetch (except first)\n        if (i > 0) {\n            node.warn('[CACHE_OPS] Waiting ' + CLOUD9_RATE_LIMIT.delayBetweenCallsMs + 'ms before tier ' + tierConfig.tier);\n            await delay(CLOUD9_RATE_LIMIT.delayBetweenCallsMs);\n        }\n\n        const result = await fetchAndCacheTier(tierConfig);\n        results.push(result);\n    }\n\n    // Log refresh to history\n    const history = flow.get('slotCacheRefreshHistory') || [];\n    results.forEach(r => {\n        history.push({ timestamp: new Date().toISOString(), tier: r.tier, success: r.success, slotCount: r.slotCount || 0, error: r.error || null, retries: r.retries || 0 });\n    });\n    if (history.length > 100) history.splice(0, history.length - 100);\n    flow.set('slotCacheRefreshHistory', history);\n\n    msg.payload = {\n        success: results.every(r => r.success),\n        message: 'Cache refresh completed (v2 sequential)',\n        timestamp: new Date().toISOString(),\n        results: results\n    };\n    node.send(msg);\n}\n\ndoRefresh();\nreturn null;",
    "outputs": 1,
    "timeout": 120,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 400,
    "y": 1020,
    "wires": [
      [
        "http-out-cache-force-refresh"
      ]
    ]
  },
  {
    "id": "http-out-cache-force-refresh",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 700,
    "y": 1020,
    "wires": []
  },
  {
    "id": "http-in-cache-clear-all",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "",
    "url": "/chord/ortho-prd/cache",
    "method": "delete",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 1090,
    "wires": [
      [
        "func-cache-clear-all"
      ]
    ]
  },
  {
    "id": "func-cache-clear-all",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "Clear All Cache (Phase 4I)",
    "func": "// Phase 4I: Clear all cache tiers\n// DELETE /chord/ortho-prd/cache\n// Optional query: ?tier=1|2|3 to clear specific tier\n\nconst TIERS = [1, 2, 3];\nconst locationGUID = '1fef9297-7c8b-426b-b0d1-f2275136e48b';\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n\nasync function clearCache() {\n    const params = msg.req?.query || {};\n    const tierToClear = params.tier || 'all';\n    const results = [];\n\n    const tiersToProcess = tierToClear === 'all' ? TIERS : [parseInt(tierToClear)];\n\n    node.warn('[CACHE_OPS] Clearing cache for tier(s): ' + tiersToProcess.join(', '));\n\n    for (const tier of tiersToProcess) {\n        const redisKey = 'SlotCache-' + locationGUID + '-Tier' + tier;\n\n        try {\n            const emptyCache = {\n                locationGUID: locationGUID,\n                slots: [],\n                slotCount: 0,\n                clearedAt: new Date().toISOString(),\n                clearedBy: 'manual_operation',\n                tier: tier\n            };\n\n            const setUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n            const response = await fetch(setUrl, {\n                method: 'POST',\n                headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n                body: JSON.stringify({ key: redisKey, value: emptyCache }),\n                timeout: 5000\n            });\n\n            if (response.ok) {\n                results.push({ tier: tier, status: 'cleared' });\n                node.warn('[CACHE_OPS] Cleared Tier ' + tier);\n            } else {\n                results.push({ tier: tier, status: 'error', error: 'HTTP ' + response.status });\n            }\n        } catch (e) {\n            results.push({ tier: tier, status: 'error', error: e.message });\n        }\n    }\n\n    msg.payload = {\n        success: results.every(r => r.status === 'cleared'),\n        timestamp: new Date().toISOString(),\n        results: results,\n        note: 'Cache cleared. Next request will fall back to Cloud9 API. Use POST /cache/refresh to repopulate.'\n    };\n\n    return msg;\n}\n\nreturn clearCache();",
    "outputs": 1,
    "timeout": 30,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 400,
    "y": 1090,
    "wires": [
      [
        "http-out-cache-clear-all"
      ]
    ]
  },
  {
    "id": "http-out-cache-clear-all",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 700,
    "y": 1090,
    "wires": []
  },
  {
    "id": "http-in-cache-trigger",
    "type": "http in",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "POST /cache/trigger",
    "url": "/chord/ortho-prd/cache/trigger",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 100,
    "y": 880,
    "wires": [
      [
        "func-cache-trigger"
      ]
    ]
  },
  {
    "id": "func-cache-trigger",
    "type": "function",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "Trigger Cache Fill",
    "func": "// Manual cache trigger v9 - Retry failed tiers\n// Adds retry logic for rate-limited requests to handle cold start scenarios\n// v9 changes: Auto-retry on rate limit (error code 7 or 0 slots)\n\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partner.cloud9ortho.com/GetData.ashx',\n    clientId: 'b42c51be-2529-4d31-92cb-50fd1a58c084',\n    userName: 'Intelepeer',\n    password: '$#1Nt-p33R-AwS#$',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    locationGUID: '1fef9297-7c8b-426b-b0d1-f2275136e48b'\n};\nconst CHAIR_8_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\nconst TIERS = [\n    { tier: 1, days: 30 },\n    { tier: 2, days: 60 },\n    { tier: 3, days: 90 }\n];\nconst TIER_DELAY_MS = 15000; // 15s between tiers\nconst RETRY_DELAY_MS = 30000; // 30s wait before retry on rate limit\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    return month + '/' + day + '/' + d.getFullYear();\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const errorCodeMatch = xmlText.match(/<ErrorCode>([^<]+)<\\/ErrorCode>/);\n    const errorCode = errorCodeMatch ? parseInt(errorCodeMatch[1]) : null;\n    const errorMsgMatch = xmlText.match(/<ErrorMessage>([^<]+)<\\/ErrorMessage>/);\n    const errorMessage = errorMsgMatch ? errorMsgMatch[1] : null;\n\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, errorCode, errorMessage, records };\n}\n\n// v9.1: Detect if error is rate-limit related (FIXED: added ErrorCode 8)\nfunction isRateLimitError(result) {\n    if (!result || result.success) return false;\n    // Error code 7 = \"Not authorized to collect data outside of allowance window\"\n    // Error code 8 = \"Too many requests within timeframe\" (actual rate limit)\n    if (result.errorCode === 7 || result.errorCode === 8) return true;\n    const error = (result.error || '').toLowerCase();\n    // Also check for rate limit indicators in error message\n    if (error.includes('rate') || error.includes('limit') || error.includes('allowance') || error.includes('too many')) return true;\n    return false;\n}\n\nasync function fetchTier(tierNum, tierDays, nodeRef, flowRef, isRetry = false) {\n    const retryLabel = isRetry ? ' [RETRY]' : '';\n    const today = new Date();\n    const startDate = formatDate(today);\n    const endDate = formatDate(new Date(today.getTime() + tierDays * 24 * 60 * 60 * 1000));\n\n    nodeRef.warn('[CACHE_v9]' + retryLabel + ' Fetching Tier ' + tierNum + ' (' + tierDays + 'd): ' + startDate + ' to ' + endDate);\n\n    const xmlRequest = '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n        '<GetDataRequest xmlns=\"' + CLOUD9.namespace + '\">' +\n        '<ClientID>' + CLOUD9.clientId + '</ClientID>' +\n        '<UserName>' + CLOUD9.userName + '</UserName>' +\n        '<Password>' + escapeXml(CLOUD9.password) + '</Password>' +\n        '<Procedure>GetOnlineReservations</Procedure>' +\n        '<Parameters>' +\n        '<startDate>' + startDate + ' 7:00:00 AM</startDate>' +\n        '<endDate>' + endDate + ' 5:00:00 PM</endDate>' +\n        '<morning>True</morning>' +\n        '<afternoon>True</afternoon>' +\n        '</Parameters>' +\n        '</GetDataRequest>';\n\n    try {\n        const fetchStart = Date.now();\n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xmlRequest,\n            timeout: 120000\n        });\n\n        if (!response.ok) throw new Error('HTTP ' + response.status);\n\n        const xmlText = await response.text();\n        const fetchDurationMs = Date.now() - fetchStart;\n        const parsed = parseXmlResponse(xmlText);\n\n        if (parsed.status !== 'Success') {\n            const errorDetail = 'ErrorCode=' + (parsed.errorCode || '?') + ' Msg=' + (parsed.errorMessage || parsed.status);\n            const history = flowRef.get('slotCacheRefreshHistory') || [];\n            history.push({\n                timestamp: new Date().toISOString(),\n                tier: tierNum,\n                success: false,\n                slotCount: 0,\n                error: errorDetail,\n                errorCode: parsed.errorCode,\n                errorMessage: parsed.errorMessage,\n                dateRange: startDate + ' to ' + endDate,\n                isRetry: isRetry,\n                fetchDurationMs: fetchDurationMs\n            });\n            if (history.length > 100) history.shift();\n            flowRef.set('slotCacheRefreshHistory', history);\n            return { success: false, error: errorDetail, errorCode: parsed.errorCode };\n        }\n\n        let slots = parsed.records.filter(slot =>\n            slot.LocationGUID === CLOUD9.locationGUID &&\n            slot.ScheduleColumnGUID === CHAIR_8_GUID &&\n            parseInt(slot.Minutes || '0') >= 40\n        );\n\n        slots = slots.map(slot => ({\n            ...slot,\n            scheduleViewGUID: slot.ScheduleViewGUID,\n            scheduleColumnGUID: slot.ScheduleColumnGUID,\n            startTime: slot.StartTime,\n            minutes: slot.Minutes || '40',\n            appointmentTypeGUID: slot.AppointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705'\n        }));\n\n        const slotsByDate = {};\n        slots.forEach(slot => {\n            const st = slot.StartTime || slot.startTime || '';\n            const m = st.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/);\n            if (m) {\n                if (!slotsByDate[m[1]]) slotsByDate[m[1]] = 0;\n                slotsByDate[m[1]]++;\n            }\n        });\n        const slotsByDateArray = Object.entries(slotsByDate)\n            .map(([date, count]) => ({ date, count }))\n            .sort((a, b) => new Date(a.date) - new Date(b.date))\n            .slice(0, 14);\n\n        flowRef.set('slotCacheSummary_Tier' + tierNum, {\n            slotCount: slots.length,\n            fetchedAt: new Date().toISOString(),\n            tierDays: tierDays,\n            dateRange: { start: startDate, end: endDate },\n            slotsByDate: slotsByDateArray\n        });\n\n        const history = flowRef.get('slotCacheRefreshHistory') || [];\n        history.push({\n            timestamp: new Date().toISOString(),\n            tier: tierNum,\n            success: true,\n            slotCount: slots.length,\n            error: null,\n            dateRange: startDate + ' to ' + endDate,\n            isRetry: isRetry,\n            fetchDurationMs: fetchDurationMs\n        });\n        if (history.length > 100) history.shift();\n        flowRef.set('slotCacheRefreshHistory', history);\n\n        nodeRef.warn('[CACHE_v9]' + retryLabel + ' Tier ' + tierNum + ': ' + slots.length + ' slots stored (' + fetchDurationMs + 'ms)');\n        return { success: true, slotCount: slots.length };\n\n    } catch (e) {\n        nodeRef.warn('[CACHE_v9]' + retryLabel + ' Tier ' + tierNum + ' FAILED: ' + e.message);\n        const history = flowRef.get('slotCacheRefreshHistory') || [];\n        history.push({\n            timestamp: new Date().toISOString(),\n            tier: tierNum,\n            success: false,\n            slotCount: 0,\n            error: e.message,\n            dateRange: startDate + ' to ' + endDate,\n            isRetry: isRetry\n        });\n        if (history.length > 100) history.shift();\n        flowRef.set('slotCacheRefreshHistory', history);\n        return { success: false, error: e.message };\n    }\n}\n\nconst nodeRef = node;\nconst flowRef = flow;\n\nnode.warn('[CACHE_v9] Trigger received');\n\nsetTimeout(async () => {\n    nodeRef.warn('[CACHE_v9] Background fetch starting...');\n    const startTime = Date.now();\n    let retriesAttempted = 0;\n    let retriesSucceeded = 0;\n\n    for (let i = 0; i < TIERS.length; i++) {\n        if (i > 0) {\n            nodeRef.warn('[CACHE_v9] Waiting ' + TIER_DELAY_MS + 'ms before Tier ' + TIERS[i].tier);\n            await new Promise(r => setTimeout(r, TIER_DELAY_MS));\n        }\n        \n        let result = await fetchTier(TIERS[i].tier, TIERS[i].days, nodeRef, flowRef, false);\n        \n        // v9: RETRY LOGIC - If failed with rate limit, wait longer and retry once\n        if (!result.success && isRateLimitError(result)) {\n            retriesAttempted++;\n            nodeRef.warn('[CACHE_v9] Tier ' + TIERS[i].tier + ' rate limited - waiting ' + RETRY_DELAY_MS + 'ms and retrying...');\n            await new Promise(r => setTimeout(r, RETRY_DELAY_MS));\n            result = await fetchTier(TIERS[i].tier, TIERS[i].days, nodeRef, flowRef, true);\n            \n            if (result.success) {\n                retriesSucceeded++;\n                nodeRef.warn('[CACHE_v9] Tier ' + TIERS[i].tier + ' RETRY SUCCEEDED: ' + result.slotCount + ' slots');\n            } else {\n                nodeRef.warn('[CACHE_v9] Tier ' + TIERS[i].tier + ' RETRY FAILED: ' + result.error);\n            }\n        }\n    }\n\n    const totalTime = Date.now() - startTime;\n    nodeRef.warn('[CACHE_v9] All tiers complete in ' + totalTime + 'ms (retries: ' + retriesAttempted + ' attempted, ' + retriesSucceeded + ' succeeded)');\n}, 100);\n\nmsg.payload = {\n    success: true,\n    message: 'Cache fill triggered (v9) - fetching 3 tiers in background with auto-retry on rate limit',\n    triggeredAt: new Date().toISOString(),\n    note: 'Check /cache-health in ~50-80 seconds for results (longer if retries needed)'\n};\nreturn msg;",
    "outputs": 1,
    "timeout": 300,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      }
    ],
    "x": 400,
    "y": 880,
    "wires": [
      [
        "http-out-cache-trigger"
      ]
    ]
  },
  {
    "id": "http-out-cache-trigger",
    "type": "http response",
    "z": "slot-cache-redis-tab",
    "g": "grp-cache-operations",
    "name": "",
    "statusCode": "200",
    "headers": {},
    "x": 700,
    "y": 880,
    "wires": []
  },
  {
    "id": "grp-ortho-book-consultation",
    "type": "group",
    "z": "cloud9-ortho-tab",
    "name": "Ortho BookConsultation (Atomic)",
    "style": {
      "label": true,
      "fill": "#d3e8f3",
      "color": "#777777"
    },
    "nodes": [
      "http-in-book-consultation",
      "func-book-consultation",
      "http-out-book-consultation",
      "debug-book-consultation-in",
      "debug-book-consultation-out"
    ],
    "x": -66,
    "y": 2499,
    "w": 1312,
    "h": 162
  },
  {
    "id": "http-in-book-consultation",
    "type": "http in",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-book-consultation",
    "name": "",
    "url": "/chord/ortho-prd/bookConsultation",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 210,
    "y": 2560,
    "wires": [
      [
        "func-book-consultation",
        "debug-book-consultation-in"
      ]
    ]
  },
  {
    "id": "debug-book-consultation-in",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-book-consultation",
    "name": "bookConsultation IN",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 500,
    "y": 2620,
    "wires": []
  },
  {
    "id": "func-book-consultation",
    "type": "function",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-book-consultation",
    "name": "bookConsultation v6",
    "func": "// Ortho Book Consultation v6 - ATOMIC create+book pipeline with CHILD DEDUPLICATION + CACHE FIX\n// Creates parent + children + books all appointments in one HTTP call\n// v6: FIX CACHE INVALIDATION - Normalize time/GUID before comparison, better error handling\n//     - normalizeTimeString() for time format normalization (handles leading zeros, whitespace)\n//     - Case-insensitive GUID comparison using toLowerCase()\n//     - Pre-grouped cache deleted AFTER main cache update succeeds\n//     - Added success/failure logging for debugging\n// v5: CHILD DEDUPLICATION - Check session cache before creating child patients\n//     Prevents duplicate child records when booking is retried (e.g., user changes date)\n//     Child dedup key: firstName|lastName|DOB (normalized, case-insensitive)\n// v4: DECOUPLE patient creation from slot dedup - always create patient record even if slot is taken\n//     When slot is taken, return patientGUID so LLM can retry with a different slot\n//     Prevents the bug where Child 2 never gets a patient record when slot is duplicate\n// v3: Removed slot reservation system, use optimistic cache invalidation instead\n// v2: Fixed missing env vars, regex, DOB format, added async queue, cache invalidation\n// v1: Initial implementation\nconst CLOUD9 = {\n    endpoint: env.get('cloud9Endpoint'),\n    clientId: env.get('cloud9ClientId'),\n    userName: env.get('cloud9UserName'),\n    password: env.get('cloud9Password'),\n    namespace: env.get('cloud9Namespace'),\n    vendorUserName: env.get('vendorUserName'),\n    defaultApptTypeGUID: env.get('defaultApptTypeGUID'),\n    defaultProviderGUID: env.get('defaultProviderGUID'),\n    defaultLocationGUID: env.get('defaultLocationGUID')\n};\n\n// Redis configuration for slot reservation + cache invalidation\nconst REDIS_BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api';\nconst REDIS_AUTH = 'Basic ' + Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\nconst DEFAULT_LOCATION_GUID = CLOUD9.defaultLocationGUID || '1fef9297-7c8b-426b-b0d1-f2275136e48b';\nconst DEFAULT_CHAIR_GUID = '07687884-7e37-49aa-8028-d43b751c9034';\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({'<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'}[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n    const errorMatch = xmlText.match(/<ErrorMessage>([^<]+)<\\/ErrorMessage>/);\n    const errorMessage = errorMatch ? errorMatch[1] : null;\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, errorMessage, records };\n}\n\nfunction extractGuidFromResult(result, pattern) {\n    if (!result) return null;\n    const match = result.match(pattern);\n    return match ? match[1] : null;\n}\n\nfunction generateUUID() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0;\n        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    });\n}\n\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nconst SETPATIENT_SPACING_MS = 5000;\nconst SETAPPOINTMENT_SPACING_MS = 10000;\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 5000;\n\n// v5: Normalize child dedup key - lowercase, trim whitespace, normalize DOB format\nfunction normalizeChildDedupKey(firstName, lastName, dob) {\n    const normFirst = (firstName || '').trim().toLowerCase();\n    const normLast = (lastName || '').trim().toLowerCase();\n    // Normalize DOB to MM/DD/YYYY format (strip time, handle various formats)\n    let normDob = '';\n    if (dob) {\n        const dobStr = String(dob).trim();\n        // Try to extract date part (handles \"MM/DD/YYYY 12:00:00 AM\" or \"MM/DD/YYYY\")\n        const dateMatch = dobStr.match(/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/);\n        if (dateMatch) {\n            normDob = dateMatch[1].padStart(2, '0') + '/' + dateMatch[2].padStart(2, '0') + '/' + dateMatch[3];\n        } else {\n            normDob = dobStr.toLowerCase();\n        }\n    }\n    return normFirst + '|' + normLast + '|' + normDob;\n}\n\n// v6: Normalize time string for cache comparison\n// Handles: \"3/12/2026 2:20:00 PM\" vs \"03/12/2026 02:20:00 PM\"\nfunction normalizeTimeString(timeStr) {\n    if (!timeStr) return '';\n    const str = String(timeStr).trim();\n    // Parse: M/D/YYYY H:MM:SS AM/PM\n    const match = str.match(/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})\\s+(\\d{1,2}):(\\d{2}):(\\d{2})\\s*(AM|PM)/i);\n    if (!match) {\n        // Try without seconds: M/D/YYYY H:MM AM/PM\n        const match2 = str.match(/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})\\s+(\\d{1,2}):(\\d{2})\\s*(AM|PM)/i);\n        if (match2) {\n            const [, month, day, year, hour, minute, ampm] = match2;\n            return `${month}/${day}/${year} ${hour}:${minute}:00 ${ampm.toUpperCase()}`;\n        }\n        return str.toLowerCase();\n    }\n    const [, month, day, year, hour, minute, second, ampm] = match;\n    // Return normalized format without leading zeros (matches Cloud9 format)\n    return `${parseInt(month)}/${parseInt(day)}/${year} ${parseInt(hour)}:${minute}:${second} ${ampm.toUpperCase()}`;\n}\n\n// v6: Cache invalidation with NORMALIZATION (fixes time format and GUID case issues)\nasync function invalidateBookedSlot(startTime, scheduleColumnGUID) {\n    const TIERS = [1, 2, 3];\n    const normalizedTime = normalizeTimeString(startTime);\n    const normalizedColumn = scheduleColumnGUID ? scheduleColumnGUID.toLowerCase() : null;\n\n    node.warn('[bookConsultation v6] CACHE_INVALIDATE: ' + startTime + ' (normalized: ' + normalizedTime + ')');\n\n    let successCount = 0;\n    let failCount = 0;\n    const preGroupedKeysToDelete = []; // v6: Delete AFTER main cache updates succeed\n\n    for (const tier of TIERS) {\n        const redisKey = 'SlotCache-' + DEFAULT_LOCATION_GUID + '-Tier' + tier;\n        try {\n            const getUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisGet?key=' + encodeURIComponent(redisKey);\n            const getResponse = await fetch(getUrl, { method: 'GET', headers: { 'Authorization': REDIS_AUTH }, timeout: 5000 });\n            if (!getResponse.ok) {\n                node.warn('[bookConsultation v6] Tier ' + tier + ' GET failed: HTTP ' + getResponse.status);\n                failCount++;\n                continue;\n            }\n            const responseText = await getResponse.text();\n            if (!responseText || responseText === 'null' || responseText === '') {\n                node.warn('[bookConsultation v6] Tier ' + tier + ' cache empty');\n                continue;\n            }\n            let cacheData;\n            try { cacheData = JSON.parse(responseText); } catch (e) {\n                node.warn('[bookConsultation v6] Tier ' + tier + ' JSON parse error: ' + e.message);\n                failCount++;\n                continue;\n            }\n            if (!cacheData.slots || cacheData.slots.length === 0) {\n                node.warn('[bookConsultation v6] Tier ' + tier + ' has no slots');\n                continue;\n            }\n            const originalCount = cacheData.slots.length;\n\n            // v6: Filter using NORMALIZED comparison\n            cacheData.slots = cacheData.slots.filter(slot => {\n                const slotStartTime = slot.StartTime || slot.startTime;\n                const slotColumnGUID = slot.ScheduleColumnGUID || slot.scheduleColumnGUID;\n\n                // Normalize both sides for comparison\n                const normalizedSlotTime = normalizeTimeString(slotStartTime);\n                const normalizedSlotColumn = slotColumnGUID ? slotColumnGUID.toLowerCase() : null;\n\n                const timeMatches = normalizedSlotTime === normalizedTime;\n                const columnMatches = !normalizedColumn || normalizedSlotColumn === normalizedColumn;\n\n                if (timeMatches && columnMatches) {\n                    node.warn('[bookConsultation v6] MATCH FOUND in Tier ' + tier + ': ' + slotStartTime);\n                }\n\n                return !(timeMatches && columnMatches);\n            });\n\n            if (cacheData.slots.length < originalCount) {\n                const removedCount = originalCount - cacheData.slots.length;\n                cacheData.slotCount = cacheData.slots.length;\n                cacheData.invalidatedAt = new Date().toISOString();\n                cacheData.lastInvalidatedSlot = startTime;\n\n                const setUrl = REDIS_BASE_URL + '/chord/ortho-prd/redisSet';\n                const setResponse = await fetch(setUrl, {\n                    method: 'POST',\n                    headers: { 'Authorization': REDIS_AUTH, 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ key: redisKey, value: cacheData }),\n                    timeout: 5000\n                });\n\n                if (setResponse.ok) {\n                    node.warn('[bookConsultation v6] SUCCESS: Removed ' + removedCount + ' slot(s) from Tier ' + tier + ' cache');\n                    successCount++;\n                    // Queue pre-grouped deletion for AFTER main cache update succeeds\n                    preGroupedKeysToDelete.push(redisKey + '-PreGrouped');\n                } else {\n                    node.warn('[bookConsultation v6] FAILED: Could not update Tier ' + tier + ' cache: HTTP ' + setResponse.status);\n                    failCount++;\n                }\n            } else {\n                node.warn('[bookConsultation v6] Tier ' + tier + ': No matching slot found (searched ' + originalCount + ' slots)');\n            }\n        } catch (e) {\n            node.warn('[bookConsultation v6] Cache invalidate error Tier ' + tier + ': ' + e.message);\n            failCount++;\n        }\n    }\n\n    // v6: Clear pre-grouped caches AFTER main cache updates succeeded\n    for (const preGroupedKey of preGroupedKeysToDelete) {\n        try {\n            await fetch(REDIS_BASE_URL + '/chord/ortho-prd/redisDelete?key=' + encodeURIComponent(preGroupedKey), {\n                method: 'DELETE', headers: { 'Authorization': REDIS_AUTH }, timeout: 3000\n            });\n            node.warn('[bookConsultation v6] Cleared pre-grouped cache: ' + preGroupedKey.split('-').pop());\n        } catch (e) {\n            node.warn('[bookConsultation v6] Pre-grouped delete failed: ' + e.message);\n        }\n    }\n\n    node.warn('[bookConsultation v6] CACHE_INVALIDATE complete: ' + successCount + ' tiers updated, ' + failCount + ' failed');\n    return { success: successCount > 0, updated: successCount, failed: failCount };\n}\n\n// Rate-limited SetPatient call with retry + async queue fallback\nasync function callSetPatient(apiParams, sessionId) {\n    const lastCall = flow.get('lastSetPatientTime') || 0;\n    const elapsed = Date.now() - lastCall;\n    if (elapsed < SETPATIENT_SPACING_MS) {\n        await delay(SETPATIENT_SPACING_MS - elapsed);\n    }\n\n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n        flow.set('lastSetPatientTime', Date.now());\n        const xml = buildXmlRequest('SetPatient', apiParams);\n        node.warn('[bookConsultation v6] SetPatient attempt ' + attempt + ' for ' + apiParams.patientFirstName);\n\n        try {\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xml,\n                timeout: 30000\n            });\n            const responseText = await response.text();\n            node.warn('[bookConsultation v6] SetPatient raw response (attempt ' + attempt + '): ' + responseText.substring(0, 300));\n            const parsed = parseXmlResponse(responseText);\n\n            if (parsed.status === 'Success' && parsed.records.length > 0) {\n                const resultField = parsed.records[0].Result || parsed.records[0].result || '';\n                const patientGUID = extractGuidFromResult(resultField, /Patient Added:\\s*([A-Fa-f0-9-]+)/i)\n                    || extractGuidFromResult(resultField, /([A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12})/);\n                if (patientGUID) {\n                    node.warn('[bookConsultation v6] SetPatient SUCCESS: ' + patientGUID.substring(0, 8) + '...');\n                    return { success: true, patientGUID: patientGUID };\n                }\n            }\n\n            node.warn('[bookConsultation v6] SetPatient attempt ' + attempt + ' failed: status=' + parsed.status + ' error=' + (parsed.errorMessage || 'none'));\n            if (attempt < MAX_RETRIES) await delay(RETRY_DELAY_MS);\n        } catch (e) {\n            node.warn('[bookConsultation v6] SetPatient error: ' + e.message);\n            if (attempt < MAX_RETRIES) await delay(RETRY_DELAY_MS);\n        }\n    }\n\n    // v2: Async queue fallback (mirrors createPatient v67)\n    const operationId = 'op-bc-pat-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);\n    const pendingOps = flow.get('pendingOperations') || {};\n    pendingOps[operationId] = {\n        operationType: 'SetPatient',\n        source: 'bookConsultation',\n        requestPayload: {\n            xmlBody: buildXmlRequest('SetPatient', apiParams),\n            apiParams: apiParams,\n            sessionId: sessionId,\n            patientFirstName: apiParams.patientFirstName,\n            patientLastName: apiParams.patientLastName,\n            phoneNumber: apiParams.phoneNumber\n        },\n        attemptCount: 0,\n        maxAttempts: 10,\n        nextRetryAt: new Date().toISOString(),\n        status: 'pending',\n        createdAt: new Date().toISOString()\n    };\n    flow.set('pendingOperations', pendingOps);\n    node.warn('[bookConsultation v6] All sync retries failed. Queued SetPatient as ' + operationId);\n\n    return { success: false, queued: true, operationId: operationId, error: 'SetPatient failed after ' + MAX_RETRIES + ' attempts - queued for async' };\n}\n\n// Rate-limited SetAppointment call with retry + async queue fallback\nasync function callSetAppointment(apiParams, sessionId, childName) {\n    const lastCall = flow.get('lastSetAppointmentTime') || 0;\n    const elapsed = Date.now() - lastCall;\n    if (elapsed < SETAPPOINTMENT_SPACING_MS) {\n        await delay(SETAPPOINTMENT_SPACING_MS - elapsed);\n    }\n\n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n        flow.set('lastSetAppointmentTime', Date.now());\n        const xml = buildXmlRequest('SetAppointment', apiParams);\n        node.warn('[bookConsultation v6] SetAppointment attempt ' + attempt + ' for ' + (childName || 'child'));\n\n        try {\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xml,\n                timeout: 60000\n            });\n            const responseText = await response.text();\n            node.warn('[bookConsultation v6] SetAppointment raw (attempt ' + attempt + '): ' + responseText.substring(0, 300));\n            const parsed = parseXmlResponse(responseText);\n\n            if (parsed.status === 'Success' && parsed.records.length > 0) {\n                const resultField = parsed.records[0].Result || parsed.records[0].result || '';\n                const appointmentGUID = extractGuidFromResult(resultField, /Appointment GUID Added:\\s*([A-Fa-f0-9-]+)/i)\n                    || extractGuidFromResult(resultField, /([A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12})/);\n                if (appointmentGUID) {\n                    node.warn('[bookConsultation v6] SetAppointment SUCCESS: ' + appointmentGUID.substring(0, 8) + '...');\n                    return { success: true, appointmentGUID: appointmentGUID };\n                }\n            }\n\n            // Check for rate limiting\n            const isRateLimited = parsed.errorMessage && /too many requests|rate limit/i.test(parsed.errorMessage);\n            node.warn('[bookConsultation v6] SetAppointment attempt ' + attempt + ' failed: ' + (parsed.errorMessage || parsed.status) + (isRateLimited ? ' (RATE LIMITED)' : ''));\n            if (attempt < MAX_RETRIES) await delay(RETRY_DELAY_MS);\n        } catch (e) {\n            node.warn('[bookConsultation v6] SetAppointment error: ' + e.message);\n            if (attempt < MAX_RETRIES) await delay(RETRY_DELAY_MS);\n        }\n    }\n\n    // v2: Async queue fallback\n    const operationId = 'op-bc-appt-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);\n    const pendingOps = flow.get('pendingOperations') || {};\n    pendingOps[operationId] = {\n        operationType: 'SetAppointment',\n        source: 'bookConsultation',\n        requestPayload: apiParams,\n        sessionId: sessionId,\n        childName: childName,\n        attemptCount: 0,\n        maxAttempts: 10,\n        nextRetryAt: new Date().toISOString(),\n        status: 'pending',\n        createdAt: new Date().toISOString()\n    };\n    flow.set('pendingOperations', pendingOps);\n    node.warn('[bookConsultation v6] Queued SetAppointment as ' + operationId);\n\n    return { success: false, queued: true, operationId: operationId, error: 'SetAppointment failed after retries - queued for async' };\n}\n\n// Set patient comment (child info + insurance)\nasync function setPatientComment(patientGUID, comment) {\n    try {\n        const xml = buildXmlRequest('SetPatientComment', {\n            patGUID: patientGUID,\n            patComment: comment\n        });\n        const response = await fetch(CLOUD9.endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/xml' },\n            body: xml,\n            timeout: 15000\n        });\n        return { success: response.ok };\n    } catch (e) {\n        node.warn('[bookConsultation v6] SetPatientComment error: ' + e.message);\n        return { success: false };\n    }\n}\n\nasync function bookConsultation() {\n    const params = msg.payload;\n    const startTime = Date.now();\n\n    // Validate required fields\n    if (!params.parentFirstName) throw new Error('parentFirstName required');\n    if (!params.parentLastName) throw new Error('parentLastName required');\n    if (!params.parentPhone) throw new Error('parentPhone required');\n    if (!params.children || !Array.isArray(params.children) || params.children.length === 0) {\n        throw new Error('children array required with at least one child');\n    }\n\n    node.warn('[bookConsultation v6] Starting atomic booking: parent=' + params.parentFirstName + ' ' + params.parentLastName + ', children=' + params.children.length);\n\n    const sessionId = params.sessionId || params.uui || msg._msgid || 'unknown';\n    const familyId = generateUUID();\n    const result = {\n        success: false,\n        parent: null,\n        children: [],\n        familyId: familyId,\n        partialSuccess: false\n    };\n\n    // v2: Session dedup for parent - check if already created in this session\n    const bookingSessions = flow.get('bookingSessions') || {};\n    const cachedParent = bookingSessions[params.parentPhone] || bookingSessions[sessionId];\n    let parentGUID = null;\n\n    if (cachedParent && cachedParent.patientGUID) {\n        node.warn('[bookConsultation v6] Session cache HIT for parent: ' + cachedParent.patientGUID.substring(0, 8) + '...');\n        parentGUID = cachedParent.patientGUID;\n        result.parent = {\n            patientGUID: parentGUID,\n            familyId: cachedParent.familyId || familyId,\n            created: true,\n            cached: true,\n            firstName: params.parentFirstName,\n            lastName: params.parentLastName\n        };\n    } else {\n        // STEP 1: Create parent patient\n        node.warn('[bookConsultation v6] STEP 1: Creating parent patient');\n        const parentApiParams = {\n            patientFirstName: params.parentFirstName,\n            patientLastName: params.parentLastName,\n            providerGUID: CLOUD9.defaultProviderGUID,\n            locationGUID: CLOUD9.defaultLocationGUID,\n            VendorUserName: CLOUD9.vendorUserName,\n            phoneNumber: params.parentPhone\n        };\n        // v2: Pass DOB raw (MM/DD/YYYY) - do NOT convert to ISO (matches createPatient behavior)\n        if (params.parentDOB) parentApiParams.birthdayDateTime = params.parentDOB;\n        if (params.parentEmail) parentApiParams.email = params.parentEmail;\n\n        const parentResult = await callSetPatient(parentApiParams, sessionId);\n        if (!parentResult.success) {\n            // v2: If queued, return queued response instead of hard fail\n            if (parentResult.queued) {\n                msg.payload = {\n                    success: false,\n                    queued: true,\n                    operationId: parentResult.operationId,\n                    familyId: familyId,\n                    error: 'Parent patient creation queued for background processing',\n                    llm_guidance: {\n                        error_type: 'parent_creation_queued',\n                        voice_response: 'Your appointment request is being processed. You will receive a confirmation shortly.',\n                        action_required: 'inform_caller_queued',\n                        CRITICAL: 'Do NOT say there was an error. The booking is being processed in the background.'\n                    }\n                };\n                msg.statusCode = 202;\n                return msg;\n            }\n            msg.payload = {\n                success: false,\n                error: 'Failed to create parent patient: ' + parentResult.error,\n                llm_guidance: {\n                    error_type: 'parent_creation_failed',\n                    voice_response: 'I want to connect you with a specialist who can assist you.',\n                    action_required: 'transfer_to_agent'\n                }\n            };\n            msg.statusCode = 500;\n            return msg;\n        }\n\n        parentGUID = parentResult.patientGUID;\n        result.parent = {\n            patientGUID: parentGUID,\n            familyId: familyId,\n            created: true,\n            firstName: params.parentFirstName,\n            lastName: params.parentLastName\n        };\n\n        // Store parent in session cache (by phone AND sessionId)\n        const sessions = flow.get('bookingSessions') || {};\n        const cacheData = {\n            patientGUID: parentGUID,\n            familyId: familyId,\n            phoneNumber: params.parentPhone,\n            createdAt: Date.now()\n        };\n        sessions[params.parentPhone] = cacheData;\n        sessions[sessionId] = cacheData;\n        sessions[parentGUID] = cacheData;\n        flow.set('bookingSessions', sessions);\n    }\n\n    // Set parent comment with insurance info\n    if (params.insuranceProvider) {\n        let comment = 'Insurance: ' + params.insuranceProvider;\n        if (params.insuranceGroupId) comment += ' | GroupID: ' + params.insuranceGroupId;\n        if (params.insuranceMemberId) comment += ' | MemberID: ' + params.insuranceMemberId;\n        comment += ' | Family: ' + params.parentFirstName + ' ' + params.parentLastName;\n        await setPatientComment(parentGUID, comment);\n    }\n\n    node.warn('[bookConsultation v6] Parent ready: ' + parentGUID.substring(0, 8) + '..., familyId=' + familyId.substring(0, 8) + '...');\n\n    // v5: Initialize child dedup cache for this session\n    const childDedupCache = flow.get('childDedupCache') || {};\n    const sessionChildCache = childDedupCache[sessionId] || {};\n\n    // STEP 2: For each child, check dedup  create patient  book appointment\n    let allChildrenSucceeded = true;\n    let anyQueued = false;\n    const sessionSlotBookings = flow.get('sessionSlotBookings') || {};\n    const sessionSlots = sessionSlotBookings[sessionId] || [];\n\n    for (let i = 0; i < params.children.length; i++) {\n        const child = params.children[i];\n        const childLastName = child.lastName || params.parentLastName;\n        const childFullName = child.firstName + ' ' + childLastName;\n        node.warn('[bookConsultation v6] STEP 2.' + (i+1) + ': Processing ' + childFullName);\n\n        // v5: CHILD DEDUPLICATION CHECK - before creating, check if this child already exists\n        const childDedupKey = normalizeChildDedupKey(child.firstName, childLastName, child.dob);\n        let childPatientGUID = null;\n        let childWasCached = false;\n\n        if (sessionChildCache[childDedupKey]) {\n            // Child already exists in session - reuse GUID\n            childPatientGUID = sessionChildCache[childDedupKey].patientGUID;\n            childWasCached = true;\n            node.warn('[bookConsultation v6] CHILD DEDUP HIT: ' + childFullName + ' already exists as ' + childPatientGUID.substring(0, 8) + '... (key=' + childDedupKey + ')');\n        } else {\n            // v4: Create child patient\n            const childApiParams = {\n                patientFirstName: child.firstName,\n                patientLastName: childLastName,\n                providerGUID: CLOUD9.defaultProviderGUID,\n                locationGUID: CLOUD9.defaultLocationGUID,\n                VendorUserName: CLOUD9.vendorUserName\n            };\n            if (child.dob) childApiParams.birthdayDateTime = child.dob;\n\n            const childResult = await callSetPatient(childApiParams, sessionId);\n            if (childResult.success) {\n                childPatientGUID = childResult.patientGUID;\n                node.warn('[bookConsultation v6] Child ' + child.firstName + ' created: ' + childPatientGUID.substring(0, 8) + '...');\n\n                // v5: Store in child dedup cache\n                sessionChildCache[childDedupKey] = {\n                    patientGUID: childPatientGUID,\n                    firstName: child.firstName,\n                    lastName: childLastName,\n                    dob: child.dob,\n                    createdAt: Date.now()\n                };\n\n                // Set child comment linking to parent/family\n                let childComment = 'Child: ' + childFullName;\n                if (child.dob) childComment += ' | DOB: ' + child.dob;\n                childComment += ' | Parent: ' + params.parentFirstName + ' ' + params.parentLastName;\n                childComment += ' | FamilyID: ' + familyId;\n                if (params.insuranceProvider) childComment += ' | Insurance: ' + params.insuranceProvider;\n                await setPatientComment(childPatientGUID, childComment);\n            } else {\n                node.warn('[bookConsultation v6] Child ' + child.firstName + ' creation failed');\n                if (childResult.queued) {\n                    anyQueued = true;\n                    result.children.push({ firstName: child.firstName, success: false, queued: true, operationId: childResult.operationId, error: 'Patient creation queued' });\n                } else {\n                    result.children.push({ firstName: child.firstName, success: false, error: 'Patient creation failed: ' + childResult.error });\n                }\n                allChildrenSucceeded = false;\n                continue;\n            }\n        }\n\n        // Validate child slot data\n        if (!child.startTime) {\n            result.children.push({ firstName: child.firstName, patientGUID: childPatientGUID, created: true, cached: childWasCached, success: false, error: 'Missing startTime - patient created but no slot to book' });\n            allChildrenSucceeded = false;\n            continue;\n        }\n        if (!child.scheduleViewGUID) {\n            result.children.push({ firstName: child.firstName, patientGUID: childPatientGUID, created: true, cached: childWasCached, success: false, error: 'Missing scheduleViewGUID - patient created but no slot to book' });\n            allChildrenSucceeded = false;\n            continue;\n        }\n\n        const columnGUID = child.scheduleColumnGUID || DEFAULT_CHAIR_GUID;\n\n        // v4: Slot dedup check - ALWAYS return patientGUID even on conflict\n        const slotKey = child.startTime + '|' + columnGUID;\n        if (sessionSlots.includes(slotKey)) {\n            node.warn('[bookConsultation v6] BLOCKED duplicate slot for ' + child.firstName + ': ' + slotKey + ' (patient ' + (childWasCached ? 'cached' : 'created') + ': ' + childPatientGUID + ')');\n            result.children.push({\n                firstName: child.firstName,\n                patientGUID: childPatientGUID,\n                created: true,\n                cached: childWasCached,\n                success: false,\n                error: 'Slot already booked in this session',\n                llm_guidance: {\n                    error_type: 'slot_conflict',\n                    CRITICAL: 'v5: Patient ' + child.firstName + ' ' + (childWasCached ? 'was found in cache' : 'was created') + ' (GUID: ' + childPatientGUID + ') but the slot ' + child.startTime + ' is already taken by another child. You MUST call grouped_slots or slots again to find a DIFFERENT time, then call book_child for ONLY this child using the existing patientGUID.',\n                    action_required: 'find_different_slot_for_child',\n                    patientGUID: childPatientGUID,\n                    voice_response: 'Let me find a different appointment time for ' + child.firstName + '.'\n                }\n            });\n            allChildrenSucceeded = false;\n            continue;\n        }\n\n        // v3: Optimistic cache invalidation\n        node.warn('[bookConsultation v6] Optimistic cache invalidation for ' + child.firstName + ' slot: ' + child.startTime);\n        await invalidateBookedSlot(child.startTime, columnGUID);\n\n        // Book appointment for this child\n        node.warn('[bookConsultation v6] Booking appointment for ' + child.firstName);\n        const apptApiParams = {\n            PatientGUID: childPatientGUID,\n            StartTime: child.startTime,\n            ScheduleViewGUID: child.scheduleViewGUID,\n            ScheduleColumnGUID: columnGUID,\n            AppointmentTypeGUID: child.appointmentTypeGUID || CLOUD9.defaultApptTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n            Minutes: String(child.minutes || 40),\n            VendorUserName: CLOUD9.vendorUserName\n        };\n\n        const apptResult = await callSetAppointment(apptApiParams, sessionId, child.firstName);\n        if (!apptResult.success) {\n            node.warn('[bookConsultation v6] Booking failed for ' + child.firstName + ' (patient ' + (childWasCached ? 'cached' : 'created') + ': ' + childPatientGUID + ')');\n            if (apptResult.queued) {\n                anyQueued = true;\n                result.children.push({\n                    firstName: child.firstName,\n                    patientGUID: childPatientGUID,\n                    created: true, cached: childWasCached, success: false, queued: true,\n                    operationId: apptResult.operationId,\n                    error: 'Appointment queued for processing'\n                });\n            } else {\n                result.children.push({\n                    firstName: child.firstName,\n                    patientGUID: childPatientGUID,\n                    created: true, cached: childWasCached, success: false,\n                    error: 'Appointment booking failed: ' + apptResult.error,\n                    appointment: { booked: false }\n                });\n            }\n            allChildrenSucceeded = false;\n            continue;\n        }\n\n        // Success - track slot for session dedup\n        sessionSlots.push(slotKey);\n\n        node.warn('[bookConsultation v6] SUCCESS: ' + child.firstName + ' booked: ' + apptResult.appointmentGUID.substring(0, 8) + '...');\n        result.children.push({\n            firstName: child.firstName,\n            patientGUID: childPatientGUID,\n            created: true,\n            cached: childWasCached,\n            success: true,\n            appointment: {\n                appointmentGUID: apptResult.appointmentGUID,\n                startTime: child.startTime,\n                booked: true\n            }\n        });\n    }\n\n    // Save slot dedup tracking\n    sessionSlotBookings[sessionId] = sessionSlots;\n    flow.set('sessionSlotBookings', sessionSlotBookings);\n\n    // v5: Save child dedup cache\n    childDedupCache[sessionId] = sessionChildCache;\n    flow.set('childDedupCache', childDedupCache);\n\n    result.success = allChildrenSucceeded;\n    result.partialSuccess = !allChildrenSucceeded && result.children.some(c => c.success);\n    result.anyQueued = anyQueued;\n    result.elapsedMs = Date.now() - startTime;\n\n    // Add LLM guidance\n    if (result.success) {\n        result.llm_guidance = {\n            action_required: 'confirm_all_appointments_to_caller',\n            voice_response_template: result.children.length === 1\n                ? 'Your appointment is confirmed! ' + result.children[0].firstName + ' at [time].'\n                : 'Both appointments are confirmed! ' + result.children.map(c => c.firstName + ' at [time]').join(' and ') + '.',\n            next_state: 'CONFIRMATION'\n        };\n    } else if (anyQueued) {\n        result.llm_guidance = {\n            action_required: 'inform_caller_queued',\n            voice_response: 'Your appointment request is being processed. You will receive a confirmation shortly.',\n            next_state: 'CONFIRMATION_PENDING',\n            CRITICAL: 'Do NOT say there was an error. Appointments are being processed in the background.'\n        };\n    } else if (result.partialSuccess) {\n        const booked = result.children.filter(c => c.success);\n        const failed = result.children.filter(c => !c.success);\n        result.llm_guidance = {\n            action_required: 'confirm_partial_and_explain',\n            voice_response: booked.map(c => c.firstName + ' is confirmed').join('. ') + '. ' + failed.map(c => c.firstName + ' could not be scheduled').join('. ') + '. Let me connect you with someone who can help with the remaining appointment.',\n            next_state: 'TRANSFER'\n        };\n    } else {\n        result.llm_guidance = {\n            action_required: 'transfer_to_agent',\n            voice_response: 'I want to connect you with a specialist who can assist you.',\n            next_state: 'TRANSFER'\n        };\n    }\n\n    msg.payload = result;\n    msg.statusCode = result.success ? 200 : (anyQueued ? 202 : (result.partialSuccess ? 207 : 500));\n    return msg;\n}\n\ntry {\n    return await bookConsultation();\n} catch (error) {\n    node.error('[bookConsultation v6] Fatal error: ' + error.message);\n    msg.payload = {\n        success: false,\n        error: error.message,\n        llm_guidance: {\n            error_type: 'fatal_error',\n            voice_response: 'I want to connect you with a specialist who can assist you.',\n            action_required: 'transfer_to_agent'\n        }\n    };\n    msg.statusCode = 500;\n    return msg;\n}\n",
    "outputs": 1,
    "timeout": 120,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "fetch",
        "module": "node-fetch"
      },
      {
        "var": "crypto",
        "module": "crypto"
      }
    ],
    "x": 800,
    "y": 2560,
    "wires": [
      [
        "http-out-book-consultation",
        "debug-book-consultation-out"
      ]
    ]
  },
  {
    "id": "http-out-book-consultation",
    "type": "http response",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-book-consultation",
    "name": "",
    "statusCode": "",
    "headers": {},
    "x": 1110,
    "y": 2560,
    "wires": []
  },
  {
    "id": "debug-book-consultation-out",
    "type": "debug",
    "z": "cloud9-ortho-tab",
    "g": "grp-ortho-book-consultation",
    "name": "bookConsultation OUT",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1110,
    "y": 2620,
    "wires": []
  }
]