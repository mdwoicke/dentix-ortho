{
  "name": "schedule_appointment_ortho",
  "description": "Appointment scheduling operations. Use action 'slots' to get available times, 'grouped_slots' for siblings, 'book_child' to book, 'cancel' to cancel. Dates in MM/DD/YYYY format. Past dates are auto-corrected to tomorrow.\n\nACTION 'slots': Get available appointment times for ONE patient. Returns startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes.\n\nACTION 'grouped_slots': **REQUIRED** when booking for 2+ children (siblings). Provide startDate, endDate, and numberOfPatients (must be 2 or more). Returns grouped consecutive slots that fit all children. ALWAYS use this instead of 'slots' when scheduling multiple patients.\n\nACTION 'book_child': MUST call AFTER caller confirms appointment time. REQUIRES: patientGUID, startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes. All values come from the slots/grouped_slots response. Call ONCE PER CHILD using their specific slot.\n\nACTION 'cancel': Call to cancel an existing appointment. Requires appointmentGUID.\n\nCRITICAL: (1) Never transfer without first calling this tool with action 'slots' or 'grouped_slots'. (2) For 2+ children, you MUST use 'grouped_slots' with numberOfPatients parameter. (3) After successful slot retrieval, offer times to caller - do NOT transfer.\n",
  "color": "linear-gradient(rgb(227,145,17), rgb(216,138,207))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"The scheduling operation: slots, grouped_slots, book_child, cancel\",\"required\":true},{\"id\":1,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"Start date MM/DD/YYYY\",\"required\":false},{\"id\":2,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"End date MM/DD/YYYY\",\"required\":false},{\"id\":3,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"Schedule view GUIDs\",\"required\":false},{\"id\":4,\"property\":\"numberOfPatients\",\"type\":\"integer\",\"description\":\"Number of patients for grouped_slots\",\"required\":false},{\"id\":5,\"property\":\"timeWindowMinutes\",\"type\":\"integer\",\"description\":\"Time window in minutes\",\"required\":false},{\"id\":6,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"Patient GUID for booking\",\"required\":false},{\"id\":7,\"property\":\"startTime\",\"type\":\"string\",\"description\":\"Appointment time MM/DD/YYYY HH:MM AM\",\"required\":false},{\"id\":8,\"property\":\"scheduleViewGUID\",\"type\":\"string\",\"description\":\"Schedule view GUID\",\"required\":false},{\"id\":9,\"property\":\"scheduleColumnGUID\",\"type\":\"string\",\"description\":\"Schedule column GUID\",\"required\":false},{\"id\":10,\"property\":\"appointmentTypeGUID\",\"type\":\"string\",\"description\":\"Appointment type GUID\",\"required\":false},{\"id\":11,\"property\":\"minutes\",\"type\":\"integer\",\"description\":\"Duration in minutes\",\"required\":false},{\"id\":12,\"property\":\"providerGUID\",\"type\":\"string\",\"description\":\"Provider GUID\",\"required\":false},{\"id\":13,\"property\":\"locationGUID\",\"type\":\"string\",\"description\":\"Location GUID\",\"required\":false},{\"id\":14,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"Appointment GUID for cancel\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING DSO - Appointment Scheduling Tool (Sandbox A - TEST)\n * Version: v54-SANDBOX | Updated: 2026-01-13\n * ============================================================================\n * Actions: slots, grouped_slots, book_child, cancel\n *\n * This version calls Node Red /ortho/ endpoints (TEST Cloud9).\n * Use /ortho-prd/ for Production.\n *\n * v54-SANDBOX: ANTI-LOOP + ANTI-FABRICATION guidance\n *   - Enhanced slot conflict error guidance with CRITICAL_ANTI_LOOP\n *   - Added GUID_EXTRACTION_CRITICAL with explicit GUIDs in slots response\n *   - Added ANTI_FABRICATION_WARNING to prevent hallucinated GUIDs\n *   - Added USE_THESE_GUIDS_NOT_DEFAULTS with actual slot GUIDs\n * v53-SANDBOX: Uses /ortho/ routes for TEST Cloud9 environment\n * v53 FIX: BOOKING SEQUENCE GUIDANCE - Add explicit llm_guidance to slots response\n * v52 FIX: INDIVIDUAL GUIDs FOR BOOKING - Accept individual params for book_child\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\nconst TOOL_VERSION = 'v54-SANDBOX';\nconst MAX_SLOTS_RETURNED = 1;\nconst BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord';\n\n// TEST Cloud9 GUIDs (Location14 - verified working in Postman)\nconst DEFAULT_SCHEDULE_VIEW_GUID = '2544683a-8e79-4b32-a4d4-bf851996bac3';  // Location14 TEST\nconst DEFAULT_SCHEDULE_COLUMN_GUID = 'e062b81f-1fff-40fc-b4a4-1cf9ecc2f32b';  // Location14 Chair8 TEST\nconst DEFAULT_APPOINTMENT_TYPE_GUID = '8fc9d063-ae46-4975-a5ae-734c6efe341a';  // 100 Exam - NP Child TEST\nconst DEFAULT_LOCATION_GUID = '1070d281-0952-4f01-9a6e-1a2e6926a7db';  // Location14 TEST\nconst SANDBOX_MIN_DATE = new Date(2026, 0, 13);\n\n// v50: Progressive date expansion tiers (in days)\nconst DATE_EXPANSION_TIERS = [14, 28, 56]; // 2 weeks, 4 weeks, 8 weeks\nconst MIN_DATE_RANGE_DAYS = 14; // Minimum range to prevent single-day searches\n// v51: Maximum days in the future to accept (prevents LLM hallucinated dates)\nconst MAX_FUTURE_DAYS = 90; // ~3 months - anything beyond this is likely an error\n\nfunction encodeBookingToken(slot) {\n    const data = {\n        st: slot.startTime,\n        sv: slot.scheduleViewGUID,\n        sc: slot.scheduleColumnGUID,\n        at: slot.appointmentTypeGUID,\n        mn: slot.minutes\n    };\n    return Buffer.from(JSON.stringify(data)).toString('base64');\n}\n\nfunction decodeBookingToken(token) {\n    try {\n        const data = JSON.parse(Buffer.from(token, 'base64').toString('utf8'));\n        return {\n            startTime: data.st,\n            scheduleViewGUID: data.sv,\n            scheduleColumnGUID: data.sc,\n            appointmentTypeGUID: data.at,\n            minutes: data.mn\n        };\n    } catch (e) {\n        console.error('[decodeBookingToken] Failed to decode:', e.message);\n        return null;\n    }\n}\n\n// v52: Return individual GUIDs in slots response for direct booking\nfunction formatSlotsResponse(data) {\n    if (data && data.slots && Array.isArray(data.slots)) {\n        data.slots = data.slots.map(slot => ({\n            displayTime: slot.startTime || slot.StartTime,\n            startTime: slot.startTime || slot.StartTime,\n            scheduleViewGUID: slot.scheduleViewGUID || DEFAULT_SCHEDULE_VIEW_GUID,\n            scheduleColumnGUID: slot.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID,\n            appointmentTypeGUID: slot.appointmentTypeGUID || DEFAULT_APPOINTMENT_TYPE_GUID,\n            minutes: slot.minutes || 45\n        }));\n    }\n    if (data && data.groups && Array.isArray(data.groups)) {\n        data.groups = data.groups.map(group => ({\n            groupTime: group.slots && group.slots[0] ? (group.slots[0].startTime || group.slots[0].StartTime) : null,\n            slots: group.slots ? group.slots.map(slot => ({\n                displayTime: slot.startTime || slot.StartTime,\n                startTime: slot.startTime || slot.StartTime,\n                scheduleViewGUID: slot.scheduleViewGUID || DEFAULT_SCHEDULE_VIEW_GUID,\n                scheduleColumnGUID: slot.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID,\n                appointmentTypeGUID: slot.appointmentTypeGUID || DEFAULT_APPOINTMENT_TYPE_GUID,\n                minutes: slot.minutes || 45\n            })) : []\n        }));\n    }\n    delete data.voiceSlots;\n    return data;\n}\n\n// ============================================================================\n// ACTION CONFIGURATIONS - Node Red /ortho/ Endpoints (TEST)\n// ============================================================================\n\nconst ACTIONS = {\n    slots: {\n        endpoint: `${BASE_URL}/ortho/getApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            const body = { \n                uui: uui, \n                startDate: params.startDate, \n                endDate: params.endDate,\n                locationGUID: params.locationGUID || DEFAULT_LOCATION_GUID\n            };\n            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.count || (data.slots ? data.slots.length : 0) || 0} available slots`\n    },\n    grouped_slots: {\n        endpoint: `${BASE_URL}/ortho/getGroupedApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            const body = {\n                uui: uui,\n                startDate: params.startDate,\n                endDate: params.endDate,\n                numberOfPatients: params.numberOfPatients || 2,\n                timeWindowMinutes: params.timeWindowMinutes || 30,\n                locationGUID: params.locationGUID || DEFAULT_LOCATION_GUID\n            };\n            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.totalGroups || (data.groups ? data.groups.length : 0) || 0} grouped slot options`\n    },\n    book_child: {\n        endpoint: `${BASE_URL}/ortho/createAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            console.log('[book_child v53-SANDBOX] Using individual params:', JSON.stringify(params));\n            return {\n                uui: uui,\n                patientGUID: params.patientGUID,\n                startTime: params.startTime,\n                scheduleViewGUID: params.scheduleViewGUID || DEFAULT_SCHEDULE_VIEW_GUID,\n                scheduleColumnGUID: params.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID,\n                appointmentTypeGUID: params.appointmentTypeGUID || DEFAULT_APPOINTMENT_TYPE_GUID,\n                minutes: params.minutes || 45,\n                childName: params.childName,\n                locationGUID: params.locationGUID || DEFAULT_LOCATION_GUID\n            };\n        },\n        validate: (params) => {\n            if (!params.patientGUID) throw new Error('BOOKING FAILED - Missing patientGUID. You MUST call chord_ortho_patient action=create FIRST to get a patientGUID.');\n            if (!params.startTime) throw new Error('BOOKING FAILED - Missing startTime');\n        },\n        successLog: () => 'Appointment booked successfully'\n    },\n    cancel: {\n        endpoint: `${BASE_URL}/ortho/cancelAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({ uui: uui, appointmentGUID: params.appointmentGUID }),\n        validate: (params) => { if (!params.appointmentGUID) throw new Error(\"appointmentGUID required\"); },\n        successLog: () => 'Appointment cancelled successfully'\n    }\n};\n\nfunction getAuthHeader() {\n    try {\n        const credentials = Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n        return `Basic ${credentials}`;\n    } catch (e) { return null; }\n}\n\nfunction checkForError(data) {\n    if (!data || typeof data !== 'object') return null;\n    if (data.success === false && !data.llm_guidance) return data.error || data.message || 'Operation failed';\n    if (data.code === false) return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    if (data.error && !data.slots && !data.groups && !data.appointmentGUID && !data.llm_guidance) {\n        return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    }\n    if (data.message && data.message.toLowerCase().includes('error') && !data.appointmentGUID) return data.message;\n    return null;\n}\n\nfunction formatDate(date) {\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    return `${mm}/${dd}/${date.getFullYear()}`;\n}\n\nfunction parseDate(dateStr) {\n    if (!dateStr) return null;\n    const parts = dateStr.split('/');\n    if (parts.length !== 3) return null;\n    return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n}\n\n// v51: Enhanced date range correction with future date validation\nfunction correctDateRange(startDate, endDate, expansionDays = DATE_EXPANSION_TIERS[0]) {\n    let correctedStart = startDate ? parseDate(startDate) : null;\n    let correctedEnd = endDate ? parseDate(endDate) : null;\n    const today = new Date(); today.setHours(0, 0, 0, 0);\n    let datesCorrected = false;\n    let originalStart = startDate;\n    let originalEnd = endDate;\n    \n    // v51: Check if dates are too far in the future (LLM hallucination detection)\n    const maxFutureDate = new Date(today);\n    maxFutureDate.setDate(maxFutureDate.getDate() + MAX_FUTURE_DAYS);\n    \n    if (correctedStart && correctedStart > maxFutureDate) {\n        console.log('[v51] WARNING: startDate ' + startDate + ' is ' + Math.ceil((correctedStart - today) / (1000 * 60 * 60 * 24)) + ' days in future - AUTO-CORRECTING to today');\n        correctedStart = null; // Will be set to today below\n        datesCorrected = true;\n    }\n    if (correctedEnd && correctedEnd > maxFutureDate) {\n        console.log('[v51] WARNING: endDate ' + endDate + ' is too far in future - will be recalculated');\n        correctedEnd = null; // Will be recalculated below\n        datesCorrected = true;\n    }\n    \n    // Fix dates in the past or missing\n    if (!correctedStart || correctedStart < today) {\n        correctedStart = new Date(Math.max(today.getTime(), SANDBOX_MIN_DATE.getTime()));\n    }\n    if (correctedStart < SANDBOX_MIN_DATE) correctedStart = new Date(SANDBOX_MIN_DATE);\n    \n    // v50: Calculate days between dates\n    let daysDiff = 0;\n    if (correctedEnd && correctedEnd > correctedStart) {\n        daysDiff = Math.ceil((correctedEnd - correctedStart) / (1000 * 60 * 60 * 24));\n    }\n    \n    // v50: Enforce minimum range AND use expansion tier\n    if (!correctedEnd || correctedEnd <= correctedStart || daysDiff < MIN_DATE_RANGE_DAYS) {\n        correctedEnd = new Date(correctedStart);\n        correctedEnd.setDate(correctedEnd.getDate() + expansionDays);\n    }\n    \n    // v51: Log when dates were auto-corrected\n    if (datesCorrected) {\n        console.log('[v51] Date auto-correction: original=' + originalStart + ' to ' + originalEnd + ' -> corrected=' + formatDate(correctedStart) + ' to ' + formatDate(correctedEnd));\n    }\n    \n    return { startDate: formatDate(correctedStart), endDate: formatDate(correctedEnd), expansionDays: expansionDays, datesCorrected: datesCorrected };\n}\n\nfunction cleanParams(params) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(params)) {\n        if (value !== null && value !== undefined && value !== '' && value !== 'NULL' && value !== 'null' && value !== 'None') {\n            cleaned[key] = value;\n        }\n    }\n    return cleaned;\n}\n\n// v50: Dynamic slot search with progressive expansion\nasync function searchSlotsWithExpansion(action, params, uui, headers) {\n    const config = ACTIONS[action];\n    let lastError = null;\n    let searchExpanded = false;\n    let finalExpansionDays = DATE_EXPANSION_TIERS[0];\n    \n    for (let tierIndex = 0; tierIndex < DATE_EXPANSION_TIERS.length; tierIndex++) {\n        const expansionDays = DATE_EXPANSION_TIERS[tierIndex];\n        const corrected = correctDateRange(params.startDate, params.endDate, expansionDays);\n        \n        const searchParams = { ...params, startDate: corrected.startDate, endDate: corrected.endDate };\n        const body = config.buildBody(searchParams, uui);\n        \n        console.log('[v50] Tier ' + tierIndex + ' search: ' + corrected.startDate + ' to ' + corrected.endDate + ' (' + expansionDays + ' days)');\n        \n        try {\n            const response = await fetch(config.endpoint, { method: config.method, headers: headers, body: JSON.stringify(body) });\n            const responseText = await response.text();\n            let data;\n            try { data = JSON.parse(responseText); } catch (e) { data = responseText; }\n            \n            if (!response.ok) {\n                lastError = 'HTTP ' + response.status + ': ' + response.statusText;\n                continue;\n            }\n            \n            const errorMessage = checkForError(data);\n            if (errorMessage) {\n                lastError = errorMessage;\n                continue;\n            }\n            \n            // Check if we got slots/groups\n            const hasResults = (action === 'slots' && data.slots && data.slots.length > 0) ||\n                               (action === 'grouped_slots' && data.groups && data.groups.length > 0);\n            \n            if (hasResults) {\n                // v50: Add metadata about the search\n                data._searchExpanded = tierIndex > 0;\n                data._expansionTier = tierIndex;\n                data._dateRange = { start: corrected.startDate, end: corrected.endDate, days: expansionDays };\n                if (tierIndex > 0) {\n                    console.log('[v50] Found slots after expanding to tier ' + tierIndex + ' (' + expansionDays + ' days)');\n                }\n                return { success: true, data: data };\n            }\n            \n            // No results, try next tier\n            searchExpanded = true;\n            finalExpansionDays = expansionDays;\n            console.log('[v50] No slots found at tier ' + tierIndex + ', expanding...');\n            \n        } catch (e) {\n            lastError = e.message;\n            console.log('[v50] Search error at tier ' + tierIndex + ': ' + e.message);\n        }\n    }\n    \n    // v50: All tiers exhausted, no slots found\n    console.log('[v50] All expansion tiers exhausted, no slots found');\n    return {\n        success: false,\n        data: {\n            slots: [],\n            groups: [],\n            count: 0,\n            totalGroups: 0,\n            _toolVersion: TOOL_VERSION,\n            _searchExpanded: searchExpanded,\n            _expansionTier: DATE_EXPANSION_TIERS.length - 1,\n            _dateRange: { days: finalExpansionDays },\n            _debug_error: lastError || 'No slots available after searching ' + finalExpansionDays + ' days',\n            llm_guidance: {\n                error_type: 'no_slots_after_expansion',\n                voice_response: 'I apologize, but I was not able to find any available appointments within the next ' + Math.round(finalExpansionDays / 7) + ' weeks. Let me connect you with someone who can help schedule your appointment.',\n                action_required: 'transfer_to_agent',\n                transfer_reason: 'no_availability_after_8_week_search',\n                CRITICAL: 'All date expansion tiers exhausted. Transfer to agent for manual scheduling assistance.'\n            }\n        }\n    };\n}\n\nasync function executeRequest() {\n    const toolName = 'schedule_appointment_ortho';\n    const action = $action;\n    console.log('[' + toolName + '] ' + TOOL_VERSION + ' - Node Red /ortho/ (TEST)');\n    console.log('[' + toolName + '] Action: ' + action);\n\n    if (!action || !ACTIONS[action]) throw new Error('Invalid action. Valid: ' + Object.keys(ACTIONS).join(', '));\n    const config = ACTIONS[action];\n\n    let uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';\n    if ($vars && $vars.c1mg_uui && $vars.c1mg_uui !== 'c1mg_uui' && $vars.c1mg_uui.trim() !== '') uui = $vars.c1mg_uui;\n\n    const rawParams = {\n        startDate: typeof $startDate !== 'undefined' ? $startDate : null,\n        endDate: typeof $endDate !== 'undefined' ? $endDate : null,\n        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,\n        startTime: typeof $startTime !== 'undefined' ? $startTime : null,\n        scheduleViewGUID: typeof $scheduleViewGUID !== 'undefined' ? $scheduleViewGUID : null,\n        scheduleColumnGUID: typeof $scheduleColumnGUID !== 'undefined' ? $scheduleColumnGUID : null,\n        appointmentTypeGUID: typeof $appointmentTypeGUID !== 'undefined' ? $appointmentTypeGUID : null,\n        minutes: typeof $minutes !== 'undefined' ? $minutes : null,\n        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null,\n        childName: typeof $childName !== 'undefined' ? $childName : null,\n        locationGUID: typeof $locationGUID !== 'undefined' ? $locationGUID : null\n    };\n    const params = cleanParams(rawParams);\n\n    try {\n        // v50: Use dynamic search for slots/grouped_slots\n        if (action === 'slots' || action === 'grouped_slots') {\n            const headers = { 'Content-Type': 'application/json' };\n            const authHeader = getAuthHeader();\n            if (authHeader) headers['Authorization'] = authHeader;\n            \n            const searchResult = await searchSlotsWithExpansion(action, params, uui, headers);\n            \n            if (!searchResult.success) {\n                // Return the no-slots response with guidance\n                return JSON.stringify(searchResult.data);\n            }\n            \n            let data = searchResult.data;\n            console.log('[' + toolName + '] ' + config.successLog(data));\n            \n            // v52: Format slots with individual GUIDs for direct booking\n            data = formatSlotsResponse(data);\n            \n            // Truncate to MAX_SLOTS_RETURNED\n            if (data && data.slots && data.slots.length > MAX_SLOTS_RETURNED) {\n                data.slots = data.slots.slice(0, MAX_SLOTS_RETURNED);\n                data.count = MAX_SLOTS_RETURNED;\n                data._truncated = true;\n            }\n            if (data && data.groups && data.groups.length > MAX_SLOTS_RETURNED) {\n                data.groups = data.groups.slice(0, MAX_SLOTS_RETURNED);\n                data.totalGroups = MAX_SLOTS_RETURNED;\n                data._truncated = true;\n            }\n            \n            if (typeof data === 'object') {\n                data._toolVersion = TOOL_VERSION;\n                data._environment = 'TEST';\n                data._noderedRoute = '/ortho/';\n                // v53: Add explicit booking sequence guidance\n                // v54: Add GUID extraction emphasis and anti-fabrication guidance\n                const firstSlot = data.slots && data.slots[0] ? data.slots[0] : null;\n                data.llm_guidance = {\n                    timestamp: new Date().toISOString(),\n                    confirmation_triggers: ['yes', 'yeah', 'yep', 'yup', 'sure', 'okay', 'ok', 'alright', 'that works', 'works for me', 'perfect', 'sounds good'],\n                    goodbye_triggers: [\"that's all\", 'thats all', \"that's it\", 'thats it', 'no thank you', 'no thanks'],\n                    BOOKING_SEQUENCE_MANDATORY: [\n                        'STEP 1: Offer the slot time to the caller and wait for confirmation',\n                        'STEP 2: When caller confirms, FIRST call chord_ortho_patient action=create to create the patient',\n                        'STEP 3: Get the patientGUID from the chord_ortho_patient response',\n                        'STEP 4: THEN call schedule_appointment_ortho action=book_child with patientGUID from step 3 AND slot GUIDs from THIS response',\n                        'CRITICAL: NEVER call book_child before chord_ortho_patient create. The patientGUID is REQUIRED.'\n                    ],\n                    GUID_EXTRACTION_CRITICAL: [\n                        'COPY THESE EXACT GUIDs for book_child - do NOT modify or invent:',\n                        firstSlot ? 'scheduleViewGUID: ' + firstSlot.scheduleViewGUID : 'scheduleViewGUID: (from slot)',\n                        firstSlot ? 'scheduleColumnGUID: ' + firstSlot.scheduleColumnGUID : 'scheduleColumnGUID: (from slot)',\n                        firstSlot ? 'appointmentTypeGUID: ' + firstSlot.appointmentTypeGUID : 'appointmentTypeGUID: (from slot)',\n                        firstSlot ? 'startTime: ' + firstSlot.startTime : 'startTime: (from slot)',\n                        'NEVER use GUIDs like a1b2c3d4 or 1234abcd - those are FABRICATED and will FAIL'\n                    ],\n                    ANTI_FABRICATION_WARNING: 'If your GUID looks like a pattern (a1b2c3d4, 1234abcd, 00000000), STOP - you are hallucinating. Use the GUIDs above.',\n                    next_action: 'offer_time_to_caller_and_wait_for_confirmation',\n                    on_caller_confirms: 'call_chord_ortho_patient_action_create_FIRST_then_book_child',\n                    slot_fields_for_booking: 'startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes',\n                    USE_THESE_GUIDS_NOT_DEFAULTS: firstSlot ? {\n                        scheduleViewGUID: firstSlot.scheduleViewGUID,\n                        scheduleColumnGUID: firstSlot.scheduleColumnGUID,\n                        appointmentTypeGUID: firstSlot.appointmentTypeGUID,\n                        startTime: firstSlot.startTime,\n                        minutes: firstSlot.minutes || 45\n                    } : null\n                };\n            }\n            return JSON.stringify(data);\n        }\n        \n        // Non-slot actions (book_child, cancel) - use original flow\n        config.validate(params);\n        const body = config.buildBody(params, uui);\n        console.log('[' + toolName + '] Request:', JSON.stringify(body));\n\n        const headers = { 'Content-Type': 'application/json' };\n        const authHeader = getAuthHeader();\n        if (authHeader) headers['Authorization'] = authHeader;\n\n        const response = await fetch(config.endpoint, { method: config.method, headers: headers, body: JSON.stringify(body) });\n        const responseText = await response.text();\n        let data;\n        try { data = JSON.parse(responseText); } catch (e) { data = responseText; }\n\n        if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);\n        const errorMessage = checkForError(data);\n        if (errorMessage) throw new Error(errorMessage);\n\n        console.log('[' + toolName + '] ' + config.successLog(data));\n        if (typeof data === 'object') {\n            data._toolVersion = TOOL_VERSION;\n            data._environment = 'TEST';\n            data._noderedRoute = '/ortho/';\n        }\n        return JSON.stringify(data);\n\n    } catch (error) {\n        console.error('[' + toolName + '] Error:', error.message);\n\n        if (error.message.includes('BOOKING FAILED') || error.message.includes('Missing')) {\n            return JSON.stringify({\n                success: false, _toolVersion: TOOL_VERSION, _environment: 'TEST', _debug_error: error.message,\n                llm_guidance: { \n                    error_type: 'missing_params', \n                    voice_response: 'Let me check those details again.', \n                    action_required: 'provide_required_params',\n                    CRITICAL: 'book_child requires: patientGUID (from chord_ortho_patient create), startTime, scheduleViewGUID. You MUST call chord_ortho_patient action=create FIRST to get the patientGUID before calling book_child.'\n                }\n            });\n        }\n\n        if (error.message.includes('cannot be scheduled') || error.message.includes('time slot') || error.message.includes('not available')) {\n            return JSON.stringify({\n                success: false, _toolVersion: TOOL_VERSION, _environment: 'TEST', _debug_error: error.message,\n                llm_guidance: {\n                    error_type: 'slot_no_longer_available',\n                    voice_response: 'That time was just taken. Let me find the next available.',\n                    action_required: 'IMMEDIATELY_CALL_SLOTS_FOR_NEW_DATA',\n                    CRITICAL_ANTI_LOOP: [\n                        'The slot you tried is TAKEN - do NOT retry with same GUIDs',\n                        'You MUST call schedule_appointment_ortho action=slots NOW',\n                        'DISCARD all previous slot GUIDs - they are INVALID',\n                        'Use ONLY the NEW GUIDs from the fresh slots response',\n                        'If this is your 2nd failed booking attempt, TRANSFER instead of looping'\n                    ],\n                    WRONG_BEHAVIOR: 'Retrying book_child with same slot data = INFINITE LOOP',\n                    CORRECT_BEHAVIOR: 'Call slots → get NEW data → offer NEW time → book with NEW GUIDs',\n                    FORGET_PREVIOUS_GUIDS: true,\n                    next_tool_call: 'schedule_appointment_ortho action=slots'\n                }\n            });\n        }\n\n        return JSON.stringify({\n            success: false, _toolVersion: TOOL_VERSION, _environment: 'TEST', _debug_error: error.message,\n            llm_guidance: { error_type: 'api_error', voice_response: 'Let me connect you with a specialist.', action_required: 'transfer_to_agent' }\n        });\n    }\n}\n\nreturn executeRequest();\n"
}