{
  "name": "chord_dso_scheduling",
  "description": "Appointment scheduling operations. Use action 'slots' to get available times, 'grouped_slots' for siblings, 'book_child' to book, 'cancel' to cancel. Dates in MM/DD/YYYY format. Past dates are auto-corrected to tomorrow.\n\nACTION 'slots': Get available appointment times. Returns startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes.\n\nACTION 'grouped_slots': MUST call for siblings or multiple patients. Provide startDate, endDate, and numberOfPatients. Returns grouped consecutive slots.\n\nACTION 'book_child': MUST call AFTER caller confirms appointment time. REQUIRES: patientGUID, startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes. All values come from the slots response.\n\nACTION 'cancel': Call to cancel an existing appointment. Requires appointmentGUID.\n\nCRITICAL: Never transfer to live agent with reason \"Unable to retrieve appointment availability\" without first calling this tool with action 'slots'.\n\n",
  "color": "linear-gradient(rgb(208,200,172), rgb(71,24,138))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"The scheduling action to perform: 'slots' (get available times), 'grouped_slots' (get consecutive slots for siblings), 'book_child' (create appointment), 'cancel' (cancel appointment)\",\"required\":true},{\"id\":1,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"Patient GUID from the create patient response. Required for book_child action.\",\"required\":false},{\"id\":2,\"property\":\"startTime\",\"type\":\"string\",\"description\":\"Appointment start time in format 'MM/DD/YYYY HH:MM AM/PM'. Required for book_child action.\",\"required\":false},{\"id\":3,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"Start date for slot search in format 'MM/DD/YYYY'. Required for slots and grouped_slots actions.\",\"required\":false},{\"id\":4,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"End date for slot search in format 'MM/DD/YYYY'. Required for slots and grouped_slots actions.\",\"required\":false},{\"id\":5,\"property\":\"scheduleViewGUID\",\"type\":\"string\",\"description\":\"Schedule view GUID from the slots response. Required for book_child action.\",\"required\":false},{\"id\":6,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"Comma-separated list of schedule view GUIDs to search. Used for slots action.\",\"required\":false},{\"id\":7,\"property\":\"scheduleColumnGUID\",\"type\":\"string\",\"description\":\"Schedule column GUID from the slots response. Required for book_child action.\",\"required\":false},{\"id\":8,\"property\":\"appointmentTypeGUID\",\"type\":\"string\",\"description\":\"CRITICAL - REQUIRED: Appointment type GUID from the slots response. Must be included for book_child action or booking WILL FAIL.\",\"required\":true},{\"id\":9,\"property\":\"minutes\",\"type\":\"number\",\"description\":\"Appointment duration in minutes from the slots response. Required for book_child action.\",\"required\":false},{\"id\":10,\"property\":\"numberOfPatients\",\"type\":\"number\",\"description\":\"Number of patients to find consecutive slots for. Required for grouped_slots action.\",\"required\":false},{\"id\":11,\"property\":\"timeWindowMinutes\",\"type\":\"number\",\"description\":\"Time window in minutes for grouped slots. Use 30 for 1-2 children, 45 for 3+ children. Used for grouped_slots action.\",\"required\":false},{\"id\":12,\"property\":\"providerGUID\",\"type\":\"string\",\"description\":\"Provider GUID from the slots response. Optional for book_child action.\",\"required\":false},{\"id\":13,\"property\":\"locationGUID\",\"type\":\"string\",\"description\":\"Location GUID. Optional for book_child action.\",\"required\":false},{\"id\":14,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"Appointment GUID to cancel. Required for cancel action.\",\"required\":true}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING - Cloud9 Direct API Integration\n * ============================================================================\n * Calls Cloud9 XML APIs directly (no Node-RED intermediary)\n *\n * Actions:\n *   - slots: Get available appointment slots (GetOnlineReservations)\n *   - grouped_slots: Get slots for siblings (GetOnlineReservations + grouping)\n *   - book_child: Create appointment (SetAppointment)\n *   - cancel: Cancel appointment (SetAppointmentStatusCanceled)\n *\n * UPDATED: Stepwise date expansion - if no slots found, automatically\n *          expands search range by 10 days and retries (max 3 attempts)\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\n// ============================================================================\n// CLOUD9 API CONFIGURATION (Sandbox)\n// ============================================================================\n\nconst CLOUD9 = {\n    endpoint: 'https://us-ea1-partnertest.cloud9ortho.com/GetData.ashx',\n    clientId: 'c15aa02a-adc1-40ae-a2b5-d2e39173ae56',\n    userName: 'IntelepeerTest',\n    password: '#!InteleP33rTest!#',\n    namespace: 'http://schemas.practica.ws/cloud9/partners/',\n    vendorUserName: 'IntelepeerTest',\n    defaultApptTypeGUID: '8fc9d063-ae46-4975-a5ae-734c6efe341a'\n};\n\n// ============================================================================\n// STEPWISE SEARCH CONFIGURATION\n// ============================================================================\n\nconst STEPWISE_CONFIG = {\n    maxAttempts: 3,           // Maximum number of search attempts\n    expansionDays: 10,        // Days to add to endDate on each retry\n    maxRangeDays: 196         // Cloud9 API limit: ~28 weeks from start\n};\n\n// ============================================================================\n// XML UTILITIES\n// ============================================================================\n\nfunction escapeXml(str) {\n    if (str === null || str === undefined) return '';\n    return String(str).replace(/[<>&'\"]/g, c => ({\n        '<': '&lt;', '>': '&gt;', '&': '&amp;', \"'\": '&apos;', '\"': '&quot;'\n    }[c]));\n}\n\nfunction buildXmlRequest(procedure, params = {}) {\n    const paramElements = Object.entries(params)\n        .filter(([_, v]) => v !== null && v !== undefined && v !== '')\n        .map(([k, v]) => `<${k}>${escapeXml(v)}</${k}>`)\n        .join('');\n\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?><GetDataRequest xmlns=\"${CLOUD9.namespace}\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><ClientID>${CLOUD9.clientId}</ClientID><UserName>${CLOUD9.userName}</UserName><Password>${escapeXml(CLOUD9.password)}</Password><Procedure>${procedure}</Procedure><Parameters>${paramElements}</Parameters></GetDataRequest>`;\n}\n\nfunction parseXmlResponse(xmlText) {\n    const statusMatch = xmlText.match(/<ResponseStatus>([^<]+)<\\/ResponseStatus>/);\n    const status = statusMatch ? statusMatch[1] : 'Unknown';\n\n    if (status === 'Error' || status !== 'Success') {\n        const errorMatch = xmlText.match(/<Result>([^<]+)<\\/Result>/);\n        if (errorMatch && (errorMatch[1].includes('Error') || errorMatch[1].includes('error'))) {\n            throw new Error(errorMatch[1]);\n        }\n    }\n\n    const records = [];\n    const recordRegex = /<Record>([\\s\\S]*?)<\\/Record>/g;\n    let match;\n    while ((match = recordRegex.exec(xmlText)) !== null) {\n        const record = {};\n        const fieldRegex = /<([A-Za-z0-9_]+)>([^<]*)<\\/\\1>/g;\n        let fieldMatch;\n        while ((fieldMatch = fieldRegex.exec(match[1])) !== null) {\n            record[fieldMatch[1]] = fieldMatch[2];\n        }\n        records.push(record);\n    }\n    return { status, records };\n}\n\n// ============================================================================\n// DATE UTILITIES\n// ============================================================================\n\nfunction formatDate(d) {\n    const month = (d.getMonth() + 1).toString().padStart(2, '0');\n    const day = d.getDate().toString().padStart(2, '0');\n    const year = d.getFullYear();\n    return `${month}/${day}/${year}`;\n}\n\nfunction parseDate(dateStr) {\n    // Parse MM/DD/YYYY format\n    const parts = dateStr.split('/');\n    if (parts.length === 3) {\n        return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n    }\n    return new Date(dateStr);\n}\n\nfunction addDays(dateStr, days) {\n    const date = parseDate(dateStr);\n    date.setDate(date.getDate() + days);\n    return formatDate(date);\n}\n\nfunction getDynamicDateRange() {\n    const today = new Date();\n    const startDate = new Date(today);\n    startDate.setDate(today.getDate() + 1);\n    const endDate = new Date(startDate);\n    endDate.setDate(startDate.getDate() + 14);\n\n    return {\n        startDate: formatDate(startDate),\n        endDate: formatDate(endDate)\n    };\n}\n\nfunction parseDateOrDefault(dateStr, isStart) {\n    if (dateStr && dateStr.trim() !== '') {\n        if (dateStr.includes(':')) return dateStr;\n        return isStart ? `${dateStr} 7:00:00 AM` : `${dateStr} 5:00:00 PM`;\n    }\n    const dynamic = getDynamicDateRange();\n    const date = isStart ? dynamic.startDate : dynamic.endDate;\n    return isStart ? `${date} 7:00:00 AM` : `${date} 5:00:00 PM`;\n}\n\nfunction getDaysBetween(startDateStr, endDateStr) {\n    const start = parseDate(startDateStr);\n    const end = parseDate(endDateStr);\n    return Math.ceil((end - start) / (1000 * 60 * 60 * 24));\n}\n\nfunction validateAndCorrectDates(startDateStr, endDateStr) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    const tomorrow = new Date(today);\n    tomorrow.setDate(tomorrow.getDate() + 1);\n\n    let correctedStart = startDateStr;\n    let correctedEnd = endDateStr;\n    let wasDateCorrected = false;\n    let correctionMessage = null;\n\n    // Check if startDate is in the past\n    if (startDateStr) {\n        const startDate = parseDate(startDateStr);\n        startDate.setHours(0, 0, 0, 0);\n\n        if (startDate < today) {\n            correctedStart = formatDate(tomorrow);\n            wasDateCorrected = true;\n            correctionMessage = `Requested date ${startDateStr} is in the past. Searching from ${correctedStart} instead.`;\n            console.log(`[DATE VALIDATION] ${correctionMessage}`);\n        }\n    }\n\n    // Check if endDate is before corrected startDate\n    if (endDateStr && correctedStart) {\n        const endDate = parseDate(endDateStr);\n        const startDate = parseDate(correctedStart);\n\n        if (endDate <= startDate) {\n            // Set endDate to startDate + 14 days\n            const newEnd = new Date(startDate);\n            newEnd.setDate(newEnd.getDate() + 14);\n            correctedEnd = formatDate(newEnd);\n            wasDateCorrected = true;\n        }\n    }\n\n    return {\n        startDate: correctedStart,\n        endDate: correctedEnd,\n        wasDateCorrected,\n        correctionMessage,\n        currentDate: formatDate(today)\n    };\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction cleanParams(params) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(params)) {\n        if (value !== null && value !== undefined && value !== '' &&\n            value !== 'NULL' && value !== 'null' && value !== 'None' &&\n            value !== 'none' && value !== 'N/A' && value !== 'n/a') {\n            cleaned[key] = value;\n        }\n    }\n    return cleaned;\n}\n\nfunction extractGuidFromResult(result, pattern) {\n    if (!result) return null;\n    const match = result.match(pattern);\n    return match ? match[1] : null;\n}\n\n// ============================================================================\n// GROUP SLOTS POST-PROCESSING\n// ============================================================================\n\nfunction groupConsecutiveSlots(slots, numberOfPatients, timeWindowMinutes) {\n    if (!slots || slots.length === 0) return [];\n\n    const duration = timeWindowMinutes || (numberOfPatients >= 3 ? 45 : 30);\n    const sorted = [...slots].sort((a, b) => new Date(a.StartTime) - new Date(b.StartTime));\n    const groups = [];\n\n    for (let i = 0; i <= sorted.length - numberOfPatients; i++) {\n        const group = [sorted[i]];\n        let lastEnd = new Date(sorted[i].StartTime);\n        lastEnd.setMinutes(lastEnd.getMinutes() + parseInt(sorted[i].Minutes || 30));\n\n        for (let j = i + 1; j < sorted.length && group.length < numberOfPatients; j++) {\n            const nextStart = new Date(sorted[j].StartTime);\n            const gapMinutes = (nextStart - lastEnd) / 60000;\n\n            if (gapMinutes >= 0 && gapMinutes <= 15 &&\n                sorted[j].ScheduleViewGUID === sorted[i].ScheduleViewGUID) {\n                group.push(sorted[j]);\n                lastEnd = new Date(sorted[j].StartTime);\n                lastEnd.setMinutes(lastEnd.getMinutes() + parseInt(sorted[j].Minutes || 30));\n            }\n        }\n\n        if (group.length >= numberOfPatients) {\n            groups.push({\n                slots: group.slice(0, numberOfPatients),\n                startTime: group[0].StartTime,\n                scheduleViewGUID: group[0].ScheduleViewGUID,\n                locationGUID: group[0].LocationGUID\n            });\n        }\n    }\n    return groups;\n}\n\n// ============================================================================\n// STEPWISE SLOT SEARCH - Core new functionality\n// ============================================================================\n\nasync function searchSlotsWithExpansion(startDate, endDate, scheduleViewGUIDs, toolName) {\n    let currentEndDate = endDate;\n    let attempt = 0;\n    let lastError = null;\n    const searchHistory = [];\n\n    while (attempt < STEPWISE_CONFIG.maxAttempts) {\n        attempt++;\n\n        // Check if we've exceeded the max range\n        const rangeDays = getDaysBetween(startDate, currentEndDate);\n        if (rangeDays > STEPWISE_CONFIG.maxRangeDays) {\n            console.log(`[${toolName}] Max range exceeded (${rangeDays} days > ${STEPWISE_CONFIG.maxRangeDays}). Stopping.`);\n            break;\n        }\n\n        console.log(`[${toolName}] Attempt ${attempt}/${STEPWISE_CONFIG.maxAttempts}: Searching ${startDate} to ${currentEndDate}`);\n\n        const apiParams = {\n            startDate: parseDateOrDefault(startDate, true),\n            endDate: parseDateOrDefault(currentEndDate, false),\n            morning: 'True',\n            afternoon: 'True',\n            appttypGUIDs: CLOUD9.defaultApptTypeGUID\n        };\n        if (scheduleViewGUIDs) apiParams.schdvwGUIDs = scheduleViewGUIDs;\n\n        try {\n            const xmlRequest = buildXmlRequest('GetOnlineReservations', apiParams);\n\n            const response = await fetch(CLOUD9.endpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/xml' },\n                body: xmlRequest,\n                timeout: 30000\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n            const xmlText = await response.text();\n            const parsed = parseXmlResponse(xmlText);\n\n            searchHistory.push({\n                attempt,\n                startDate,\n                endDate: currentEndDate,\n                slotsFound: parsed.records.length\n            });\n\n            console.log(`[${toolName}] Attempt ${attempt}: Found ${parsed.records.length} slots`);\n\n            // SUCCESS: Found slots, return them\n            if (parsed.records.length > 0) {\n                return {\n                    success: true,\n                    records: parsed.records,\n                    searchRange: { startDate, endDate: currentEndDate },\n                    attempts: attempt,\n                    expanded: attempt > 1,\n                    searchHistory\n                };\n            }\n\n            // NO SLOTS: Expand the date range and retry\n            console.log(`[${toolName}] No slots found. Expanding endDate by ${STEPWISE_CONFIG.expansionDays} days...`);\n            currentEndDate = addDays(currentEndDate, STEPWISE_CONFIG.expansionDays);\n\n        } catch (error) {\n            console.error(`[${toolName}] Attempt ${attempt} error:`, error.message);\n            lastError = error;\n\n            searchHistory.push({\n                attempt,\n                startDate,\n                endDate: currentEndDate,\n                error: error.message\n            });\n\n            // On error, don't expand - this is likely an API issue, not a date issue\n            break;\n        }\n    }\n\n    // All attempts exhausted or error occurred\n    return {\n        success: false,\n        records: [],\n        searchRange: { startDate, endDate: currentEndDate },\n        attempts: attempt,\n        expanded: attempt > 1,\n        searchHistory,\n        error: lastError ? lastError.message : 'No slots found after all attempts'\n    };\n}\n\n// ============================================================================\n// MAIN EXECUTION\n// ============================================================================\n\nasync function executeRequest() {\n    const toolName = 'chord_dso_scheduling';\n    const action = $action;\n\n    console.log(`[${toolName}] Action: ${action}`);\n\n    const validActions = ['slots', 'grouped_slots', 'book_child', 'cancel'];\n    if (!action || !validActions.includes(action)) {\n        throw new Error(`Invalid action '${action}'. Valid: ${validActions.join(', ')}`);\n    }\n\n    const rawParams = {\n        startDate: typeof $startDate !== 'undefined' ? $startDate : null,\n        endDate: typeof $endDate !== 'undefined' ? $endDate : null,\n        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,\n        startTime: typeof $startTime !== 'undefined' ? $startTime : null,\n        scheduleViewGUID: typeof $scheduleViewGUID !== 'undefined' ? $scheduleViewGUID : null,\n        scheduleColumnGUID: typeof $scheduleColumnGUID !== 'undefined' ? $scheduleColumnGUID : null,\n        appointmentTypeGUID: typeof $appointmentTypeGUID !== 'undefined' ? $appointmentTypeGUID : null,\n        minutes: typeof $minutes !== 'undefined' ? $minutes : null,\n        providerGUID: typeof $providerGUID !== 'undefined' ? $providerGUID : null,\n        locationGUID: typeof $locationGUID !== 'undefined' ? $locationGUID : null,\n        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null\n    };\n    const params = cleanParams(rawParams);\n\n    try {\n        switch (action) {\n            case 'slots':\n            case 'grouped_slots': {\n                const dynamicDates = getDynamicDateRange();\n                const requestedStart = params.startDate || dynamicDates.startDate;\n                const requestedEnd = params.endDate || dynamicDates.endDate;\n\n                // VALIDATE AND AUTO-CORRECT PAST DATES\n                const dateValidation = validateAndCorrectDates(requestedStart, requestedEnd);\n                const searchStartDate = dateValidation.startDate || dynamicDates.startDate;\n                const searchEndDate = dateValidation.endDate || dynamicDates.endDate;\n\n                console.log(`[${toolName}] Current date: ${dateValidation.currentDate}`);\n                console.log(`[${toolName}] Requested: ${requestedStart} to ${requestedEnd}`);\n                console.log(`[${toolName}] Searching: ${searchStartDate} to ${searchEndDate}`);\n                if (dateValidation.wasDateCorrected) {\n                    console.log(`[${toolName}] Date was corrected: ${dateValidation.correctionMessage}`);\n                }\n\n                if (action === 'grouped_slots' && !params.numberOfPatients) {\n                    throw new Error('numberOfPatients required for grouped_slots');\n                }\n\n                // Use stepwise expansion search\n                const searchResult = await searchSlotsWithExpansion(\n                    searchStartDate,\n                    searchEndDate,\n                    params.scheduleViewGUIDs,\n                    toolName\n                );\n\n                if (action === 'slots') {\n                    let message = searchResult.expanded\n                        ? `Found ${searchResult.records.length} slots after expanding search to ${searchResult.searchRange.endDate}`\n                        : `Found ${searchResult.records.length} slots`;\n                    if (dateValidation.wasDateCorrected) {\n                        message = `${dateValidation.correctionMessage} ${message}`;\n                    }\n                    return JSON.stringify({\n                        slots: searchResult.records,\n                        count: searchResult.records.length,\n                        searchRange: searchResult.searchRange,\n                        attempts: searchResult.attempts,\n                        expanded: searchResult.expanded,\n                        currentDate: dateValidation.currentDate,\n                        dateWasCorrected: dateValidation.wasDateCorrected,\n                        message: message\n                    });\n                } else {\n                    // grouped_slots\n                    const groups = groupConsecutiveSlots(\n                        searchResult.records,\n                        parseInt(params.numberOfPatients),\n                        params.timeWindowMinutes ? parseInt(params.timeWindowMinutes) : null\n                    );\n                    let message = searchResult.expanded\n                        ? `Found ${groups.length} grouped options after expanding search to ${searchResult.searchRange.endDate}`\n                        : `Found ${groups.length} grouped options`;\n                    if (dateValidation.wasDateCorrected) {\n                        message = `${dateValidation.correctionMessage} ${message}`;\n                    }\n                    return JSON.stringify({\n                        groups: groups,\n                        count: groups.length,\n                        numberOfPatients: params.numberOfPatients,\n                        searchRange: searchResult.searchRange,\n                        attempts: searchResult.attempts,\n                        expanded: searchResult.expanded,\n                        currentDate: dateValidation.currentDate,\n                        dateWasCorrected: dateValidation.wasDateCorrected,\n                        message: message\n                    });\n                }\n            }\n\n            case 'book_child': {\n                if (!params.patientGUID) throw new Error('patientGUID required');\n                if (!params.startTime) throw new Error('startTime required (MM/DD/YYYY HH:MM AM)');\n                if (!params.scheduleViewGUID) throw new Error('scheduleViewGUID required');\n                if (!params.scheduleColumnGUID) throw new Error('scheduleColumnGUID required');\n                if (!params.appointmentTypeGUID) throw new Error('appointmentTypeGUID required');\n\n                const apiParams = {\n                    PatientGUID: params.patientGUID,\n                    StartTime: params.startTime,\n                    ScheduleViewGUID: params.scheduleViewGUID,\n                    ScheduleColumnGUID: params.scheduleColumnGUID,\n                    AppointmentTypeGUID: params.appointmentTypeGUID,\n                    Minutes: String(params.minutes || 30),\n                    VendorUserName: CLOUD9.vendorUserName\n                };\n\n                const xmlRequest = buildXmlRequest('SetAppointment', apiParams);\n                const response = await fetch(CLOUD9.endpoint, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/xml' },\n                    body: xmlRequest,\n                    timeout: 30000\n                });\n\n                const xmlText = await response.text();\n                if (!response.ok) {\n                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n                }\n\n                const parsed = parseXmlResponse(xmlText);\n                const apptResult = parsed.records[0]?.Result || '';\n                const apptGUID = extractGuidFromResult(apptResult, /Appointment GUID Added:\\s*([A-Fa-f0-9-]+)/i);\n\n                return JSON.stringify({\n                    success: apptResult.includes('Added'),\n                    appointmentGUID: apptGUID,\n                    message: apptResult\n                });\n            }\n\n            case 'cancel': {\n                if (!params.appointmentGUID) throw new Error('appointmentGUID required');\n\n                const xmlRequest = buildXmlRequest('SetAppointmentStatusCanceled', {\n                    apptGUID: params.appointmentGUID\n                });\n\n                const response = await fetch(CLOUD9.endpoint, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/xml' },\n                    body: xmlRequest,\n                    timeout: 30000\n                });\n\n                const xmlText = await response.text();\n                if (!response.ok) {\n                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n                }\n\n                const parsed = parseXmlResponse(xmlText);\n                const cancelResult = parsed.records[0]?.Result || 'Cancellation processed';\n\n                return JSON.stringify({\n                    success: !cancelResult.toLowerCase().includes('error'),\n                    message: cancelResult\n                });\n            }\n        }\n\n    } catch (error) {\n        console.error(`[${toolName}] Error:`, error.message);\n        return JSON.stringify({\n            error: `Failed to execute ${action}`,\n            message: error.message,\n            action: action,\n            timestamp: new Date().toISOString()\n        });\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}