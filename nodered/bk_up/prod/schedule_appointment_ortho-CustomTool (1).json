{
  "name": "schedule_appointment_ortho",
  "description": "Appointment scheduling operations. Use action 'slots' to get available times, 'grouped_slots' for siblings, 'book_child' to book, 'cancel' to cancel. Dates in MM/DD/YYYY format. Past dates are auto-corrected to tomorrow.\n\nACTION 'slots': Get available appointment times. Returns startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes.\n\nACTION 'grouped_slots': MUST call for siblings or multiple patients. Provide startDate, endDate, and numberOfPatients. Returns grouped consecutive slots.\n\nACTION 'book_child': MUST call AFTER caller confirms appointment time. REQUIRES: patientGUID, startTime, scheduleViewGUID, scheduleColumnGUID, appointmentTypeGUID, minutes. All values come from the slots response.\n\nACTION 'cancel': Call to cancel an existing appointment. Requires appointmentGUID.\n\nCRITICAL: Never transfer to live agent with reason \"Unable to retrieve appointment availability\" without first calling this tool with action 'slots'.\n",
  "color": "linear-gradient(rgb(119,207,178), rgb(110,210,194))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"action\",\"type\":\"string\",\"description\":\"\",\"required\":true},{\"id\":1,\"property\":\"startDate\",\"type\":\"string\",\"description\":\"\",\"required\":false},{\"id\":2,\"property\":\"endDate\",\"type\":\"string\",\"description\":\"\",\"required\":false},{\"id\":3,\"property\":\"scheduleViewGUIDs\",\"type\":\"string\",\"description\":\"\",\"required\":false},{\"id\":4,\"property\":\"numberOfPatients\",\"type\":\"string\",\"description\":\"\",\"required\":false},{\"id\":5,\"property\":\"timeWindowMinutes\",\"type\":\"string\",\"description\":\"\",\"required\":false},{\"id\":6,\"property\":\"patientGUID\",\"type\":\"string\",\"description\":\"\",\"required\":false},{\"id\":7,\"property\":\"bookingToken\",\"type\":\"string\",\"description\":\"\",\"required\":false},{\"id\":8,\"property\":\"appointmentGUID\",\"type\":\"string\",\"description\":\"\",\"required\":false}]",
  "func": "/**\n * ============================================================================\n * CHORD SCHEDULING DSO - Appointment Scheduling Tool (Node Red Version)\n * Version: v49 | Updated: 2026-01-12\n * ============================================================================\n * Actions: slots, grouped_slots, book_child, cancel\n *\n * v49 FIX: STRIP GUIDs FROM SLOTS RESPONSE - LLM was pattern-matching GUIDs from slot data\n *          - Slots response now only returns displayTime + bookingToken (no individual GUIDs)\n *          - LLM cannot extract startTime/scheduleViewGUID/scheduleColumnGUID from response\n * v48 FIX: ENFORCE BOOKINGTOKEN - Removed deprecated params from schema\n *          - book_child FAILS if bookingToken not provided\n * v47 FIX: bookingToken system (but LLM ignored it)\n * v46 FIX: Reduced MAX_SLOTS_RETURNED to 1\n * v45 FIX: Added DEFAULT_SCHEDULE_COLUMN_GUID + slot mismatch error detection\n * ============================================================================\n */\n\nconst fetch = require('node-fetch');\n\nconst TOOL_VERSION = 'v49';\nconst MAX_SLOTS_RETURNED = 1;\nconst BASE_URL = 'https://c1-aicoe-nodered-lb.prod.c1conversations.io/FabricWorkflow/api/chord';\nconst DEFAULT_SCHEDULE_COLUMN_GUID = 'dda0b40c-ace5-4427-8b76-493bf9aa26f1';\nconst SANDBOX_MIN_DATE = new Date(2026, 0, 13);\n\n// Encode slot data into a bookingToken\nfunction encodeBookingToken(slot) {\n    const data = {\n        st: slot.startTime,\n        sv: slot.scheduleViewGUID,\n        sc: slot.scheduleColumnGUID,\n        at: slot.appointmentTypeGUID,\n        mn: slot.minutes\n    };\n    return Buffer.from(JSON.stringify(data)).toString('base64');\n}\n\n// Decode bookingToken back to slot data\nfunction decodeBookingToken(token) {\n    try {\n        const data = JSON.parse(Buffer.from(token, 'base64').toString('utf8'));\n        return {\n            startTime: data.st,\n            scheduleViewGUID: data.sv,\n            scheduleColumnGUID: data.sc,\n            appointmentTypeGUID: data.at,\n            minutes: data.mn\n        };\n    } catch (e) {\n        console.error('[decodeBookingToken] Failed to decode:', e.message);\n        return null;\n    }\n}\n\n// v49: Strip individual GUIDs, only return displayTime + bookingToken\nfunction addBookingTokensToSlots(data) {\n    if (data && data.slots && Array.isArray(data.slots)) {\n        data.slots = data.slots.map(slot => ({\n            displayTime: slot.startTime || slot.StartTime,\n            bookingToken: encodeBookingToken(slot)\n        }));\n    }\n    if (data && data.groups && Array.isArray(data.groups)) {\n        data.groups = data.groups.map(group => ({\n            groupTime: group.slots && group.slots[0] ? (group.slots[0].startTime || group.slots[0].StartTime) : null,\n            slots: group.slots ? group.slots.map(slot => ({\n                displayTime: slot.startTime || slot.StartTime,\n                bookingToken: encodeBookingToken(slot)\n            })) : []\n        }));\n    }\n    // Remove voiceSlots as it also contains GUIDs\n    delete data.voiceSlots;\n    return data;\n}\n\nconst ACTIONS = {\n    slots: {\n        endpoint: `${BASE_URL}/ortho-prd/getApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            const body = { uui: uui, startDate: params.startDate, endDate: params.endDate };\n            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.count || (data.slots ? data.slots.length : 0) || 0} available slots`\n    },\n    grouped_slots: {\n        endpoint: `${BASE_URL}/ortho-prd/getGroupedApptSlots`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            const body = {\n                uui: uui,\n                startDate: params.startDate,\n                endDate: params.endDate,\n                numberOfPatients: params.numberOfPatients || 2,\n                timeWindowMinutes: params.timeWindowMinutes || 30\n            };\n            if (params.scheduleViewGUIDs) body.scheduleViewGUIDs = params.scheduleViewGUIDs;\n            return body;\n        },\n        validate: () => {},\n        successLog: (data) => `Found ${data.totalGroups || (data.groups ? data.groups.length : 0) || 0} grouped slot options`\n    },\n    book_child: {\n        endpoint: `${BASE_URL}/ortho-prd/createAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => {\n            // v48: REQUIRE bookingToken - no fallback to individual params\n            if (!params.bookingToken) {\n                throw new Error('BOOKING FAILED - bookingToken is required. Call slots first to get a bookingToken.');\n            }\n            const slotData = decodeBookingToken(params.bookingToken);\n            if (!slotData) {\n                throw new Error('BOOKING FAILED - Invalid bookingToken. Call slots again to get a fresh token.');\n            }\n            console.log('[book_child] Decoded bookingToken:', JSON.stringify(slotData));\n            return {\n                uui: uui,\n                patientGUID: params.patientGUID,\n                startTime: slotData.startTime,\n                scheduleViewGUID: slotData.scheduleViewGUID,\n                scheduleColumnGUID: slotData.scheduleColumnGUID || DEFAULT_SCHEDULE_COLUMN_GUID,\n                appointmentTypeGUID: slotData.appointmentTypeGUID || 'f6c20c35-9abb-47c2-981a-342996016705',\n                minutes: slotData.minutes || 45,\n                childName: params.childName\n            };\n        },\n        validate: (params) => {\n            if (!params.patientGUID) throw new Error('BOOKING FAILED - Missing patientGUID');\n            if (!params.bookingToken) throw new Error('BOOKING FAILED - Missing bookingToken. You must call slots first and use the bookingToken from the response.');\n        },\n        successLog: () => 'Appointment booked successfully'\n    },\n    cancel: {\n        endpoint: `${BASE_URL}/ortho-prd/cancelAppt`,\n        method: 'POST',\n        buildBody: (params, uui) => ({ uui: uui, appointmentGUID: params.appointmentGUID }),\n        validate: (params) => { if (!params.appointmentGUID) throw new Error(\"appointmentGUID required\"); },\n        successLog: () => 'Appointment cancelled successfully'\n    }\n};\n\nfunction getAuthHeader() {\n    try {\n        const credentials = Buffer.from('workflowapi:e^@V95&6sAJReTsb5!iq39mIC4HYIV').toString('base64');\n        return `Basic ${credentials}`;\n    } catch (e) { return null; }\n}\n\nfunction checkForError(data) {\n    if (!data || typeof data !== 'object') return null;\n    if (data.success === false && !data.llm_guidance) return data.error || data.message || 'Operation failed';\n    if (data.code === false) return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    if (data.error && !data.slots && !data.groups && !data.appointmentGUID && !data.llm_guidance) {\n        return Array.isArray(data.error) ? data.error.join(', ') : data.error;\n    }\n    if (data.message && data.message.toLowerCase().includes('error') && !data.appointmentGUID) return data.message;\n    return null;\n}\n\nfunction formatDate(date) {\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    return `${mm}/${dd}/${date.getFullYear()}`;\n}\n\nfunction parseDate(dateStr) {\n    if (!dateStr) return null;\n    const parts = dateStr.split('/');\n    if (parts.length !== 3) return null;\n    return new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));\n}\n\nfunction correctDateRange(startDate, endDate) {\n    let correctedStart = startDate ? parseDate(startDate) : null;\n    let correctedEnd = endDate ? parseDate(endDate) : null;\n    const today = new Date(); today.setHours(0, 0, 0, 0);\n    \n    if (!correctedStart || correctedStart < today) correctedStart = new Date(Math.max(today.getTime(), SANDBOX_MIN_DATE.getTime()));\n    if (correctedStart < SANDBOX_MIN_DATE) correctedStart = new Date(SANDBOX_MIN_DATE);\n    \n    if (!correctedEnd || correctedEnd <= correctedStart) {\n        correctedEnd = new Date(correctedStart);\n        correctedEnd.setDate(correctedEnd.getDate() + 14);\n    }\n    return { startDate: formatDate(correctedStart), endDate: formatDate(correctedEnd) };\n}\n\nfunction cleanParams(params) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(params)) {\n        if (value !== null && value !== undefined && value !== '' && value !== 'NULL' && value !== 'null' && value !== 'None') {\n            cleaned[key] = value;\n        }\n    }\n    return cleaned;\n}\n\nasync function executeRequest() {\n    const toolName = 'schedule_appointment_ortho';\n    const action = $action;\n    console.log('[' + toolName + '] ' + TOOL_VERSION + ' - bookingToken ENFORCED');\n    console.log('[' + toolName + '] Action: ' + action);\n\n    if (!action || !ACTIONS[action]) throw new Error('Invalid action. Valid: ' + Object.keys(ACTIONS).join(', '));\n    const config = ACTIONS[action];\n\n    let uui = '765381306-000000000001030525-SR-000-000000000000DAL130-026DE427|333725|421458314VO|2d411063-3769-4618-86d1-925d3578c112|FSV';\n    if ($vars && $vars.c1mg_uui && $vars.c1mg_uui !== 'c1mg_uui' && $vars.c1mg_uui.trim() !== '') uui = $vars.c1mg_uui;\n\n    const rawParams = {\n        startDate: typeof $startDate !== 'undefined' ? $startDate : null,\n        endDate: typeof $endDate !== 'undefined' ? $endDate : null,\n        scheduleViewGUIDs: typeof $scheduleViewGUIDs !== 'undefined' ? $scheduleViewGUIDs : null,\n        numberOfPatients: typeof $numberOfPatients !== 'undefined' ? $numberOfPatients : null,\n        timeWindowMinutes: typeof $timeWindowMinutes !== 'undefined' ? $timeWindowMinutes : null,\n        patientGUID: typeof $patientGUID !== 'undefined' ? $patientGUID : null,\n        bookingToken: typeof $bookingToken !== 'undefined' ? $bookingToken : null,\n        appointmentGUID: typeof $appointmentGUID !== 'undefined' ? $appointmentGUID : null,\n        childName: typeof $childName !== 'undefined' ? $childName : null\n    };\n    const params = cleanParams(rawParams);\n\n    if (action === 'slots' || action === 'grouped_slots') {\n        const corrected = correctDateRange(params.startDate, params.endDate);\n        params.startDate = corrected.startDate;\n        params.endDate = corrected.endDate;\n    }\n\n    try {\n        config.validate(params);\n        const body = config.buildBody(params, uui);\n        console.log('[' + toolName + '] Request:', JSON.stringify(body));\n\n        const headers = { 'Content-Type': 'application/json' };\n        const authHeader = getAuthHeader();\n        if (authHeader) headers['Authorization'] = authHeader;\n\n        const response = await fetch(config.endpoint, { method: config.method, headers: headers, body: JSON.stringify(body) });\n        const responseText = await response.text();\n        let data;\n        try { data = JSON.parse(responseText); } catch (e) { data = responseText; }\n\n        if (!response.ok) throw new Error('HTTP ' + response.status + ': ' + response.statusText);\n        const errorMessage = checkForError(data);\n        if (errorMessage) throw new Error(errorMessage);\n\n        console.log('[' + toolName + '] ' + config.successLog(data));\n\n        // v48: Add bookingTokens to slots\n        if (action === 'slots' || action === 'grouped_slots') {\n            data = addBookingTokensToSlots(data);\n        }\n\n        // Truncate to MAX_SLOTS_RETURNED\n        if (data && data.slots && data.slots.length > MAX_SLOTS_RETURNED) {\n            data.slots = data.slots.slice(0, MAX_SLOTS_RETURNED);\n            data.count = MAX_SLOTS_RETURNED;\n            data._truncated = true;\n            data._note = 'Use the bookingToken from this slot when calling book_child';\n        }\n        if (data && data.groups && data.groups.length > MAX_SLOTS_RETURNED) {\n            data.groups = data.groups.slice(0, MAX_SLOTS_RETURNED);\n            data.totalGroups = MAX_SLOTS_RETURNED;\n            data._truncated = true;\n        }\n\n        if (typeof data === 'object') data._toolVersion = TOOL_VERSION;\n        return JSON.stringify(data);\n\n    } catch (error) {\n        console.error('[' + toolName + '] Error:', error.message);\n\n        if (error.message.includes('BOOKING FAILED') || error.message.includes('bookingToken')) {\n            return JSON.stringify({\n                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,\n                llm_guidance: { \n                    error_type: 'missing_booking_token', \n                    voice_response: 'Let me check those times again.', \n                    action_required: 'call_slots_then_use_bookingToken',\n                    CRITICAL: 'You MUST call slots action first, then use the bookingToken from the response when calling book_child. The bookingToken contains all the slot details.'\n                }\n            });\n        }\n\n        if (error.message.includes('cannot be scheduled') || error.message.includes('time slot') || error.message.includes('not available')) {\n            return JSON.stringify({\n                success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,\n                llm_guidance: { \n                    error_type: 'slot_no_longer_available', \n                    voice_response: 'That time is no longer available. Let me find another option.', \n                    action_required: 'call_slots_offer_new_time',\n                    CRITICAL: 'The slot is taken. Call slots again to get a new bookingToken and offer the new time to caller.'\n                }\n            });\n        }\n\n        return JSON.stringify({\n            success: false, _toolVersion: TOOL_VERSION, _debug_error: error.message,\n            llm_guidance: { error_type: 'api_error', voice_response: 'Let me connect you with a specialist.', action_required: 'transfer_to_agent' }\n        });\n    }\n}\n\nreturn executeRequest();\n",
  "workspaceId": "9e7c759d-2623-4529-945d-6c578631aad0"
}