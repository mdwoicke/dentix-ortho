---
phase: 06-automated-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/monitoringService.ts
  - backend/src/services/heartbeatService.ts
  - backend/src/controllers/traceAnalysisController.ts
autonomous: true

must_haves:
  truths:
    - "Every completed call session gets an automatic intent-vs-fulfillment check without manual intervention"
    - "Results are stored incrementally so sessions are only analyzed once"
    - "When a session fails verification, the diagnostic orchestrator runs automatically"
    - "Diagnostics are capped at 3 per cycle to avoid LLM rate limiting storms"
  artifacts:
    - path: "backend/src/services/monitoringService.ts"
      provides: "MonitoringService with runMonitoringCycle, findUnanalyzedSessions, analyzeSession, triggerDiagnostics"
      exports: ["MonitoringService", "getMonitoringService"]
    - path: "backend/src/services/heartbeatService.ts"
      provides: "Extended heartbeat that calls monitoringService.runMonitoringCycle()"
  key_links:
    - from: "backend/src/services/heartbeatService.ts"
      to: "backend/src/services/monitoringService.ts"
      via: "runMonitoringCycle() call after evaluateAlerts()"
      pattern: "monitoringService.*runMonitoringCycle"
    - from: "backend/src/services/monitoringService.ts"
      to: "backend/src/services/langfuseTraceService.ts"
      via: "importRecentTraces to get new sessions"
      pattern: "langfuseTraceService.*getTraces|importTraces"
    - from: "backend/src/services/monitoringService.ts"
      to: "backend/src/controllers/traceAnalysisController.ts"
      via: "reuse analyzeSession logic for intent+verification"
      pattern: "classifyCallerIntent|verifyFulfillment"
---

<objective>
Build the automated post-call monitoring pipeline that runs on each heartbeat cycle, imports recent traces, runs intent classification + fulfillment verification on unanalyzed sessions, stores pass/fail results in a monitoring_results table, and auto-triggers diagnostics on failures.

Purpose: MON-01 (auto-check every completed call) and MON-02 (auto-trigger diagnostics on failures).
Output: MonitoringService + HeartbeatService integration + monitoring_results table.
</objective>

<execution_context>
@C:\Users\mwoic\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mwoic\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-automated-monitoring/06-RESEARCH.md
@backend/src/services/heartbeatService.ts
@backend/src/controllers/traceAnalysisController.ts
@backend/src/services/langfuseTraceService.ts
@backend/src/services/fulfillmentVerifier.ts
@backend/src/services/callerIntentClassifier.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MonitoringService with monitoring_results table and analysis pipeline</name>
  <files>backend/src/services/monitoringService.ts</files>
  <action>
Create `MonitoringService` class that encapsulates the full monitoring cycle:

1. **monitoring_results table** (auto-created in constructor like session_analysis pattern):
   ```sql
   CREATE TABLE IF NOT EXISTS monitoring_results (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     session_id TEXT NOT NULL UNIQUE,
     intent_type TEXT,
     intent_confidence REAL,
     verification_status TEXT, -- 'pass', 'fail', 'partial', 'error', 'skipped'
     verdict_summary TEXT,
     diagnostic_status TEXT, -- null, 'pending', 'complete', 'error'
     diagnostic_report_json TEXT,
     analyzed_at TEXT NOT NULL DEFAULT (datetime('now')),
     diagnosed_at TEXT
   );
   ```

2. **runMonitoringCycle(configId)** method:
   - Use LangfuseTraceService to fetch traces from last 10 minutes (configurable)
   - Group traces into sessions (reuse existing session grouping from langfuseTraceService)
   - Filter to sessions where last trace is >= 5 minutes old (completed calls)
   - Find sessions NOT already in monitoring_results table
   - For each unanalyzed session (cap at 10 per cycle):
     a. Import full session traces/observations
     b. Extract conversation turns using `transformToConversationTurns` (import from testMonitorController)
     c. Call `classifyCallerIntent()` from callerIntentClassifier
     d. Call `verifyFulfillment()` from fulfillmentVerifier (with 200ms serial Cloud9 delay)
     e. Store result in monitoring_results with pass/fail/partial status
   - Return summary: { sessionsChecked, passed, failed, errors }

3. **triggerDiagnostics()** method:
   - Query monitoring_results WHERE verification_status IN ('fail','partial') AND diagnostic_status IS NULL
   - Cap at 3 sessions per invocation
   - For each: dynamically import diagnosticOrchestrator (Phase 4), call analyze()
   - Update diagnostic_status and diagnostic_report_json
   - Use sequential execution (not parallel) to avoid LLM rate limits

4. **Singleton pattern** matching heartbeatService: `getMonitoringService(db?)` and `resetMonitoringService()`.

Key decisions:
- Use the same test-agent DB path as traceAnalysisController (TEST_AGENT_DB_PATH)
- Import `filterInternalTraces`, `transformToConversationTurns` from testMonitorController
- Import `classifyCallerIntent` from callerIntentClassifier
- Import `verifyFulfillment` from fulfillmentVerifier
- Dynamic import() for diagnosticOrchestrator to avoid circular deps
- Sessions with intent type 'unknown' or confidence < 0.5 get verification_status = 'skipped'
- Log each session analysis result to console for observability
  </action>
  <verify>
    TypeScript compiles: `cd backend && npx tsc --noEmit src/services/monitoringService.ts`
  </verify>
  <done>
    MonitoringService exists with runMonitoringCycle() and triggerDiagnostics() methods. monitoring_results table auto-created. Singleton exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire MonitoringService into HeartbeatService cycle</name>
  <files>backend/src/services/heartbeatService.ts, backend/src/controllers/traceAnalysisController.ts</files>
  <action>
1. **In heartbeatService.ts**, after the existing `evaluateAlerts()` call in `runHeartbeat()`:
   - Import `getMonitoringService` from monitoringService
   - Add monitoring cycle call with try/catch (monitoring failure should not break alert evaluation):
     ```typescript
     // Run monitoring cycle (every 5th heartbeat to avoid overloading)
     try {
       const monitoringService = getMonitoringService(this.db);
       const monitoringResult = await monitoringService.runMonitoringCycle(this.configId || 1);
       console.log(`[HeartbeatService] Monitoring: ${monitoringResult.sessionsChecked} sessions checked, ${monitoringResult.failed} failed`);

       // Auto-trigger diagnostics on failures
       if (monitoringResult.failed > 0) {
         const diagResult = await monitoringService.triggerDiagnostics();
         console.log(`[HeartbeatService] Diagnostics: ${diagResult.diagnosed} sessions diagnosed`);
       }
     } catch (err: any) {
       console.error('[HeartbeatService] Monitoring cycle error (non-fatal):', err.message);
     }
     ```
   - Add monitoring stats to HeartbeatResult interface: `monitoringChecked?: number`, `monitoringFailed?: number`
   - Add a `monitoringEnabled` flag to HeartbeatStatus (default true)
   - Track a `lastMonitoringCycleAt` timestamp; only run monitoring if >= 5 minutes since last cycle (the heartbeat runs every 1 min for alerts, but monitoring should run every 5 min)

2. **In traceAnalysisController.ts**, export `getDb` function (or make it accessible) so MonitoringService can reuse the same DB connection pattern. If getDb is already module-scoped, add `export` keyword. Also ensure `transformToConversationTurns` and `filterInternalTraces` are importable (they should already be exported from testMonitorController).
  </action>
  <verify>
    `cd backend && npx tsc --noEmit` compiles without errors. HeartbeatService imports MonitoringService successfully.
  </verify>
  <done>
    HeartbeatService runs monitoring cycle every 5 minutes (gated by timestamp check within 1-min heartbeat). Failed sessions auto-trigger diagnostics. Monitoring errors are caught and logged without breaking alert evaluation.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npx tsc --noEmit` -- full project compiles
2. monitoring_results table creation SQL is valid (tested by service instantiation)
3. HeartbeatService.runHeartbeat() calls monitoringService.runMonitoringCycle() with 5-min gating
4. MonitoringService.triggerDiagnostics() caps at 3 sessions per invocation
</verification>

<success_criteria>
- MonitoringService exists with runMonitoringCycle() that imports traces, classifies intent, verifies fulfillment, stores results
- HeartbeatService calls monitoring cycle every ~5 minutes
- Failed sessions auto-trigger diagnostics (capped at 3)
- monitoring_results table stores per-session verdicts
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-automated-monitoring/06-01-SUMMARY.md`
</output>
