---
phase: 04-expert-agents-diagnostics
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/services/diagnosticOrchestrator.ts
  - backend/src/controllers/testMonitorController.ts
  - backend/src/routes/testMonitor.ts
autonomous: true

must_haves:
  truths:
    - "Diagnostic orchestrator routes failed traces to relevant expert agent(s) based on StepStatus data"
    - "diagnoseProductionTrace now uses orchestrator instead of generic prompt"
    - "Standalone expert endpoints exist at POST /api/test-monitor/expert/:agentType/analyze"
    - "Multiple experts can be invoked for a single trace when failures span domains"
  artifacts:
    - path: "backend/src/services/diagnosticOrchestrator.ts"
      provides: "Rule-based routing from failure location to expert agent(s)"
      exports: ["DiagnosticOrchestrator", "DiagnosticReport"]
      min_lines: 100
  key_links:
    - from: "backend/src/services/diagnosticOrchestrator.ts"
      to: "backend/src/services/expertAgentService.ts"
      via: "ExpertAgentService.analyze()"
      pattern: "expertAgentService.*analyze"
    - from: "backend/src/services/diagnosticOrchestrator.ts"
      to: "backend/src/services/toolSequenceMapper.ts"
      via: "StepStatus for routing decisions"
      pattern: "StepStatus"
    - from: "backend/src/controllers/testMonitorController.ts"
      to: "backend/src/services/diagnosticOrchestrator.ts"
      via: "orchestrator.diagnose() replaces generic prompt"
      pattern: "DiagnosticOrchestrator"
---

<objective>
Create the diagnostic orchestrator that routes failures to expert agents, replace the generic diagnosis, and add standalone expert endpoints.

Purpose: Intelligent routing ensures the right expert analyzes each failure, producing higher-quality diagnoses.
Output: diagnosticOrchestrator.ts, updated diagnoseProductionTrace, standalone expert endpoints.
</objective>

<execution_context>
@C:\Users\mwoic\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mwoic\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-expert-agents-diagnostics/04-RESEARCH.md
@.planning/phases/04-expert-agents-diagnostics/04-01-SUMMARY.md
@backend/src/services/toolSequenceMapper.ts
@backend/src/controllers/testMonitorController.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create diagnosticOrchestrator.ts with rule-based routing</name>
  <files>backend/src/services/diagnosticOrchestrator.ts</files>
  <action>
Create `backend/src/services/diagnosticOrchestrator.ts` with:

1. **Types:**
   - `DiagnosticReport` with fields: sessionId, traceId, agents (array of ExpertAnalysisResult from expertAgentService), combinedMarkdown (string), overallConfidence (number), deployCorrelation? (object with artifact versions active at failure time)
   - `DiagnosticRequest` with fields: traceId, sessionId, transcript (string), apiErrors (string), stepStatuses (StepStatus[]), failureTimestamp? (string for deploy correlation)

2. **Routing rules** (the core logic):
   Map StepStatus failures to expert agents using these rules:
   - If any step with toolName containing 'patient' has status 'failed' or 'missing' -> route to 'patient_tool'
   - If any step with toolName containing 'schedule' and action 'slots' or 'book' has status 'failed' or 'missing' -> route to 'scheduling_tool'
   - If apiErrors contain Cloud9 API errors, HTTP 4xx/5xx, or "_debug_error" -> route to 'nodered_flow'
   - If no tool-level failures found but completion rate < 1.0 -> route to 'system_prompt' (conversation flow issue)
   - If NO specific failures detected -> route to 'system_prompt' as fallback
   - Always deduplicate: each agent type appears at most once

   Implement as `determineExperts(request: DiagnosticRequest): ExpertAgentType[]`

3. **Core class `DiagnosticOrchestrator`:**
   - Constructor takes BetterSqlite3.Database
   - `diagnose(request: DiagnosticRequest): Promise<DiagnosticReport>` - Calls determineExperts(), then invokes ExpertAgentService.analyze() for each selected expert (sequentially to avoid parallel LLM cost spikes). Combines results into DiagnosticReport. Generates combinedMarkdown by concatenating each agent's diagnosticMarkdown with headers.
   - `correlateDeployVersions(artifactKey: string, timestamp: string): { version: number, deployedAt: string } | null` - Queries artifact_deploy_events for the most recent deploy before the given timestamp. Returns null if no deploy events exist.
   - Build overallConfidence as max of individual agent confidences.

4. **Combined markdown format:**
   ```markdown
   # Diagnostic Report: {traceId}

   ## Experts Consulted: {agent1}, {agent2}

   ---
   ## {Agent1 Type} Analysis (Confidence: {N}%)
   {agent1.diagnosticMarkdown}

   ---
   ## {Agent2 Type} Analysis (Confidence: {N}%)
   {agent2.diagnosticMarkdown}

   ---
   ## Deploy Correlation
   {version info or "No deploy events recorded"}
   ```
  </action>
  <verify>
Run `npx tsc --noEmit --project backend/tsconfig.json 2>&1 | head -20` to verify no type errors.
  </verify>
  <done>diagnosticOrchestrator.ts compiles, routes failures to correct experts based on StepStatus, produces combined markdown report.</done>
</task>

<task type="auto">
  <name>Task 2: Wire orchestrator into diagnoseProductionTrace and add standalone endpoints</name>
  <files>backend/src/controllers/testMonitorController.ts, backend/src/routes/testMonitor.ts</files>
  <action>
**In testMonitorController.ts:**

1. Add imports at top: `import { DiagnosticOrchestrator } from '../services/diagnosticOrchestrator'` and `import { ExpertAgentService } from '../services/expertAgentService'`

2. Modify `diagnoseProductionTrace` (around line 8904): Replace the generic LLM prompt section. After the existing trace loading and transcript building code (keep lines 8811-8866 as-is), replace the LLM call section (lines ~8888-9048) with:
   - Create `DiagnosticOrchestrator` instance with the db
   - Build `DiagnosticRequest` from the existing transcript, apiErrors, and stepStatuses. To obtain stepStatuses:
     a. First check if session_analysis cache has a cached result (query `session_analysis` table by traceId).
     b. If cached and it contains stepStatuses, use those directly.
     c. If cache miss or stepStatuses are absent: import `callerIntentClassifier` from `'../services/callerIntentClassifier'` and `mapToolSequence` from `'../services/toolSequenceMapper'`. Run `const intent = callerIntentClassifier(transcript)` then `const stepStatuses = mapToolSequence(observations, intent)`. This is the explicit fallback — do not leave stepStatuses undefined.
     d. If both fail (e.g., no observations available), pass an empty array `[]` for stepStatuses so the orchestrator falls back to system_prompt expert.
   - Call `orchestrator.diagnose(request)`
   - Store fixes from each agent's result into `generated_fixes` using the same INSERT pattern as current code
   - Return the combined diagnostic report in the response alongside the existing fix stats
   - **Backward compatibility (CRITICAL):** The existing response shape MUST be preserved. The response JSON must still include all current top-level fields (`fixesGenerated`, `summary`, `fixStats`, `analysis`, etc.) at the same paths. Only ADD the new `diagnosticReport` field alongside existing fields — do NOT remove, rename, or restructure any existing fields. After wiring, verify by reading the existing response shape (search for `res.json` in the current diagnoseProductionTrace function) and confirming every existing key is still present in the new code path.

3. **Add standalone expert endpoint handler:**
   Create `analyzeWithExpert` function:
   ```typescript
   export async function analyzeWithExpert(req: Request, res: Response, next: NextFunction): Promise<void> {
     const { agentType } = req.params;
     const { context } = req.body; // freeform text context
     // Validate agentType is one of the 4 valid types
     // Create ExpertAgentService, call analyzeStandalone
     // Return the ExpertAnalysisResult as JSON
   }
   ```

**In testMonitor.ts routes:**

Add the standalone expert endpoint:
```typescript
router.post('/expert/:agentType/analyze', testMonitorController.analyzeWithExpert);
```

Place it near the other diagnosis endpoints (around line 568).
  </action>
  <verify>
Run `npx tsc --noEmit --project backend/tsconfig.json 2>&1 | head -20` to verify compilation.
Verify the route exists: `grep "expert/:agentType" backend/src/routes/testMonitor.ts`
  </verify>
  <done>diagnoseProductionTrace uses orchestrator instead of generic prompt. Standalone endpoint POST /expert/:agentType/analyze is routed and functional. Response includes diagnosticReport field with combined markdown.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project backend/tsconfig.json` passes
- diagnosticOrchestrator.ts exports DiagnosticOrchestrator and DiagnosticReport
- diagnoseProductionTrace response includes diagnosticReport field
- Route for /expert/:agentType/analyze exists
</verification>

<success_criteria>
Orchestrator routes failures to relevant experts based on step statuses. diagnoseProductionTrace backward-compatible with new diagnosticReport field. Standalone expert endpoint available for manual troubleshooting.
</success_criteria>

<output>
After completion, create `.planning/phases/04-expert-agents-diagnostics/04-02-SUMMARY.md`
</output>
