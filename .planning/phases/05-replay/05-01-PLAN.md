---
phase: 05-replay
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/replayService.ts
  - backend/src/controllers/testMonitorController.ts
  - backend/src/routes/testMonitor.ts
autonomous: true

must_haves:
  truths:
    - "Given a trace ID, system generates a mock harness containing captured Cloud9 responses from observations"
    - "Mock harness replays tool logic against captured responses instead of live endpoints"
    - "Replay result shows whether tool logic produces same output with captured vs live data"
  artifacts:
    - path: "backend/src/services/replayService.ts"
      provides: "Mock mode for tool replay using captured observation responses"
      contains: "mockResponses"
    - path: "backend/src/controllers/testMonitorController.ts"
      provides: "generateMockHarness and executeMockReplay endpoints"
      contains: "generateMockHarness"
  key_links:
    - from: "replayService.ts"
      to: "langfuse_observations table"
      via: "observation query for mock data extraction"
      pattern: "langfuse_observations"
    - from: "testMonitorController.ts"
      to: "replayService.ts"
      via: "executeMockReplay function call"
      pattern: "executeMockReplay"
---

<objective>
Add mock harness generation to the existing replay service so tool logic can be tested against captured Cloud9 responses from a trace, isolating whether failures are in tool logic or the upstream API.

Purpose: REPLAY-01 - users need to verify tool logic fixes without depending on live Cloud9 API state
Output: Two new endpoints - one to generate a mock harness from a trace, one to execute mock replay
</objective>

<execution_context>
@C:\Users\mwoic\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mwoic\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-replay/05-RESEARCH.md
@backend/src/services/replayService.ts
@backend/src/services/langfuseTraceService.ts
@backend/src/controllers/testMonitorController.ts
@backend/src/routes/testMonitor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mock harness generation and mock replay mode to replayService.ts</name>
  <files>backend/src/services/replayService.ts</files>
  <action>
Extend replayService.ts with two new exported functions:

1. `generateMockHarness(traceId: string)` - Queries `langfuse_observations` table (via getDb from test-agent pattern or direct sqlite) for observations belonging to the trace. Filters for tool-call observations (type='SPAN' or type='GENERATION' with non-null output). Builds a `MockHarness` object containing:
   - `traceId`: source trace
   - `observations`: array of `{ observationId, name, input, output }` (the captured request/response pairs)
   - `mockMap`: a `Map<string, any>` keyed by observation name (e.g. "chord_ortho_patient_lookup") mapping to the captured output
   - `createdAt`: timestamp

   Use existing DB access pattern from backend (import getDb from database module). Query: `SELECT id, name, type, input, output FROM langfuse_observations WHERE trace_id = ? AND output IS NOT NULL`.

2. `executeMockReplay(request: ReplayRequest, mockMap: Map<string, any>)` - Same as existing `executeReplay` but replaces the `executeHttpRequest` calls with mock lookups. Refactor the existing `executeHttpRequest` to accept an optional `mockMap` parameter. When mockMap is provided and contains a matching key for the endpoint/action, return the captured response instead of making HTTP call. Log `[MOCK]` prefix in preCallLogs. If no mock match found, log warning and return error (don't fall through to live).

Add types:
```typescript
export interface MockHarness {
  traceId: string;
  observations: Array<{ observationId: string; name: string; input: any; output: any }>;
  mockMap: Record<string, any>;  // serializable version of Map
  createdAt: string;
}
```

Key: The mock map key should be derived from the endpoint path (last segment, e.g. "ortho-prd/GetAvailableAppts" -> "GetAvailableAppts") so it matches regardless of base URL changes.
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>replayService.ts exports generateMockHarness and executeMockReplay functions, MockHarness type is defined</done>
</task>

<task type="auto">
  <name>Task 2: Add mock harness API endpoints</name>
  <files>backend/src/controllers/testMonitorController.ts, backend/src/routes/testMonitor.ts</files>
  <action>
Add two new controller methods and routes:

1. `POST /api/test-monitor/replay/mock-harness` - Controller: `generateMockHarness`
   - Body: `{ traceId: string }`
   - Calls `replayService.generateMockHarness(traceId)`
   - Returns the MockHarness object as JSON
   - Error if no observations found for trace

2. `POST /api/test-monitor/replay/mock` - Controller: `executeMockReplay`
   - Body: `{ toolName, action, input, traceId }` where traceId is used to auto-generate the mock harness
   - First calls generateMockHarness to get mockMap, then calls executeMockReplay with it
   - Returns same shape as existing `/replay` endpoint plus `mockMode: true` flag

Add routes in testMonitor.ts right after the existing replay routes (lines ~398-402). Follow the exact same pattern as existing `router.post('/replay', ...)`.
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>Two new replay endpoints exist and compile. POST /replay/mock-harness returns harness data. POST /replay/mock executes mock replay.</done>
</task>

</tasks>

<verification>
1. `cd backend && npx tsc --noEmit` passes
2. MockHarness type exported from replayService.ts
3. Routes registered at /replay/mock-harness and /replay/mock
</verification>

<success_criteria>
- replayService.ts has mock mode that returns captured responses instead of hitting live endpoints
- Two new API endpoints exist for mock harness generation and mock replay execution
- No changes to existing live replay behavior (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/05-replay/05-01-SUMMARY.md`
</output>
