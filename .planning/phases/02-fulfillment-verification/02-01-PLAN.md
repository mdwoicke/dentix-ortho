---
phase: 02-fulfillment-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/fulfillmentVerifier.ts
  - backend/src/controllers/traceAnalysisController.ts
autonomous: true

must_haves:
  truths:
    - "System extracts claimed patient GUIDs and appointment GUIDs from Langfuse observation outputs"
    - "System queries Cloud9 production API to verify each claimed record exists"
    - "System compares claimed data (names, dates) against actual Cloud9 records and reports mismatches"
    - "Verification results are cached in session_analysis table to avoid repeated Cloud9 queries"
  artifacts:
    - path: "backend/src/services/fulfillmentVerifier.ts"
      provides: "Claim extraction + Cloud9 verification logic"
      exports: ["verifyFulfillment", "extractClaimedRecords", "ClaimedRecord", "FulfillmentVerdict", "RecordVerification"]
    - path: "backend/src/controllers/traceAnalysisController.ts"
      provides: "Extended endpoint with verification field"
  key_links:
    - from: "backend/src/services/fulfillmentVerifier.ts"
      to: "backend/src/services/cloud9/client.ts"
      via: "Cloud9Client instantiation with 'production' env"
      pattern: "new Cloud9Client.*production"
    - from: "backend/src/services/fulfillmentVerifier.ts"
      to: "backend/src/controllers/traceAnalysisController.ts"
      via: "verifyFulfillment called from controller"
      pattern: "verifyFulfillment"
---

<objective>
Build the fulfillment verification service that extracts claimed records from Langfuse trace observations and verifies them against the live Cloud9 production API.

Purpose: This is the core engine that closes the loop between "what the IVA claimed to do" and "what actually happened in Cloud9." Without this, trace analysis only shows intent -- not outcome.

Output: `fulfillmentVerifier.ts` service + extended trace analysis endpoint with `?verify=true` support.
</objective>

<execution_context>
@C:\Users\mwoic\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mwoic\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-fulfillment-verification/02-RESEARCH.md
@.planning/phases/01-trace-foundation/01-03-SUMMARY.md

@backend/src/services/cloud9/client.ts
@backend/src/services/toolSequenceMapper.ts
@backend/src/controllers/traceAnalysisController.ts
@backend/src/services/callerIntentClassifier.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fulfillmentVerifier.ts service</name>
  <files>backend/src/services/fulfillmentVerifier.ts</files>
  <action>
Create `backend/src/services/fulfillmentVerifier.ts` with:

**Types (export all):**
- `ClaimedRecord` - type: 'patient'|'appointment', guid, sourceTool, sourceAction, observationId, claimedData (firstName?, lastName?, appointmentDate?, appointmentType?, childName?)
- `FieldMismatch` - field, expected, actual
- `RecordVerification` - claimed, status: 'pass'|'fail'|'partial', cloud9Record, mismatches: FieldMismatch[], error?
- `ChildVerification` - childName, patientRecordStatus, appointmentRecordStatus, details: RecordVerification[]
- `FulfillmentVerdict` - sessionId, overallStatus, summary, records: RecordVerification[], childVerifications: ChildVerification[], verifiedAt

**Functions:**

1. `extractClaimedRecords(observations: any[], intent: any): ClaimedRecord[]`
   - Parse each observation's input/output (both are JSON strings -- parse defensively)
   - For observations named 'chord_ortho_patient' with input.action === 'create_patient': extract patientGuid from output (check output.patientGuid, output.PatientGUID, output.guid)
   - For observations named 'chord_ortho_patient' with input.action === 'lookup': extract patient GUID for responsible party
   - For observations named 'schedule_appointment_ortho' with input.action === 'book_child': extract appointment GUID from output (check output.appointmentGuid, output.AppointmentGUID, output.Appointment_GUID)
   - Extract claimed names/dates from input fields (firstName, patientFirstName, lastName, patientLastName, childName, startTime, appointmentDate)
   - Skip observations where output parsing fails or GUID is missing -- do NOT throw

2. `verifyPatientRecord(client: Cloud9Client, claimed: ClaimedRecord): Promise<RecordVerification>`
   - Call client.getPatientInformation(claimed.guid)
   - If no record found: status 'fail', error 'Patient not found in Cloud9'
   - Compare firstName and lastName (case-insensitive trim) against claimed data
   - Return 'pass' if no mismatches, 'partial' if mismatches exist

3. `verifyAppointmentRecord(client: Cloud9Client, claimed: ClaimedRecord, patientGuid: string): Promise<RecordVerification>`
   - Call client.getPatientAppointments(patientGuid)
   - Find appointment matching claimed.guid in the results
   - If not found: status 'fail'
   - Compare date if claimed -- return pass/partial/fail

4. `verifyFulfillment(sessionId: string, observations: any[], intent: any): Promise<FulfillmentVerdict>`
   - Instantiate Cloud9Client with 'production' environment (CRITICAL -- see CLAUDE.md)
   - Call extractClaimedRecords
   - If no claimed records: return status 'skipped' with summary "No verifiable records found in trace"
   - For each claimed patient record: call verifyPatientRecord (serial, not parallel -- respect rate limits)
   - For each claimed appointment record: call verifyAppointmentRecord
   - Add 200ms delay between Cloud9 API calls to avoid rate limiting
   - Compute overallStatus: 'pass' if all pass, 'fail' if any fail, 'partial' if mixed
   - Build summary string: "N/M records verified" style
   - Return FulfillmentVerdict with verifiedAt = new Date().toISOString()

Helper: `nameMatch(a, b)` -- case-insensitive trim comparison, return true if either is undefined/empty (don't fail on missing data).
Helper: `parseJson(str)` -- try/catch JSON.parse, return null on failure.

**Do NOT** import anything from test-agent. Use only backend services.
**Do NOT** make Cloud9 calls in parallel. Serial with delay.
  </action>
  <verify>npx tsc --noEmit from backend directory passes with no errors on the new file</verify>
  <done>fulfillmentVerifier.ts exports verifyFulfillment, extractClaimedRecords, and all types. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Extend trace analysis endpoint with verification</name>
  <files>backend/src/controllers/traceAnalysisController.ts</files>
  <action>
Extend the existing `GET /api/trace-analysis/:sessionId` endpoint in traceAnalysisController.ts:

1. Import `verifyFulfillment` and `FulfillmentVerdict` from `../services/fulfillmentVerifier`

2. Add `?verify=true` query parameter support:
   - When `verify=true` is passed, run fulfillment verification after the existing analysis
   - When not passed, skip verification (backward compatible)

3. Check for cached verification in session_analysis table:
   - Add columns if not present: `verification_json TEXT`, `verification_status TEXT`, `verified_at TEXT`
   - Auto-alter table in getDb() alongside existing auto-create logic (use try/catch around ALTER TABLE -- ignore "duplicate column" errors)
   - If cached verification exists and force=false, return cached
   - If force=true or no cached verification, run fresh verification

4. After running verifyFulfillment, store results:
   - UPDATE session_analysis SET verification_json = JSON.stringify(verdict), verification_status = verdict.overallStatus, verified_at = verdict.verifiedAt WHERE session_id = ?

5. Include verification in the response:
   - Add `verification: FulfillmentVerdict | null` field to the response object
   - null when verify=false or verification not yet run

6. Add a dedicated verification-only endpoint: `GET /api/trace-analysis/:sessionId/verify`
   - Always runs verification (equivalent to verify=true)
   - Returns just the FulfillmentVerdict object
   - Still uses caching (force=true to bypass)

Register the new route in the existing router.
  </action>
  <verify>
1. npx tsc --noEmit passes
2. Start backend, call GET /api/trace-analysis/{sessionId}?verify=true -- should return response with verification field
3. Call GET /api/trace-analysis/{sessionId}/verify -- should return verification verdict
  </verify>
  <done>Existing endpoint supports ?verify=true and returns verification results. Dedicated /verify sub-endpoint exists. Results are cached in session_analysis table. Backward compatible -- omitting verify param returns null verification.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in backend directory passes
2. GET /api/trace-analysis/:sessionId returns analysis WITHOUT verification field when verify not passed
3. GET /api/trace-analysis/:sessionId?verify=true returns analysis WITH verification field containing overallStatus, records, childVerifications
4. GET /api/trace-analysis/:sessionId/verify returns standalone verification verdict
5. Second call with same sessionId returns cached verification (verified_at unchanged)
6. ?force=true bypasses cache and re-verifies against Cloud9
</verification>

<success_criteria>
- fulfillmentVerifier.ts exists and exports core types + functions
- Cloud9Client is instantiated with 'production' environment
- Claimed records extracted from observation outputs with defensive parsing
- Verification results cached in session_analysis table
- Existing endpoint backward compatible (no breaking changes)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-fulfillment-verification/02-01-SUMMARY.md`
</output>
