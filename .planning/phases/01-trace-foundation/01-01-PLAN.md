---
phase: 01-trace-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/callerIntentClassifier.ts
  - backend/src/services/toolSequenceMapper.ts
autonomous: true

must_haves:
  truths:
    - "System classifies caller intent from full conversation transcript into booking, rescheduling, cancellation, or info_lookup"
    - "For booking intents, system extracts child count, child names, parent name, phone number, and requested dates"
    - "Classification works for all four call types"
  artifacts:
    - path: "backend/src/services/callerIntentClassifier.ts"
      provides: "CallerIntentClassifier with classifyCallerIntent() method"
      exports: ["classifyCallerIntent", "CallerIntent", "BookingDetails"]
    - path: "backend/src/services/toolSequenceMapper.ts"
      provides: "Tool sequence mapper with getExpectedSequence() and mapToolSequence()"
      exports: ["getExpectedSequence", "mapToolSequence", "ToolSequenceResult", "StepStatus"]
  key_links:
    - from: "backend/src/services/callerIntentClassifier.ts"
      to: "Anthropic haiku API"
      via: "HTTP fetch with structured JSON output"
      pattern: "claude-3.*haiku"
---

<objective>
Build the caller intent classifier service that analyzes full conversation transcripts to determine what the caller wanted and extract structured booking data.

Purpose: This is the primary new work in Phase 1. The existing CategoryClassifier classifies agent responses (what the bot said). This new service classifies caller intent (what the caller wanted) from the full conversation, which is fundamentally different.

Output: `callerIntentClassifier.ts` service with LLM-based classification and structured data extraction.
</objective>

<execution_context>
@C:\Users\mwoic\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mwoic\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-trace-foundation/01-RESEARCH.md

Key existing code to reference (do NOT rewrite):
@backend/src/services/langfuseTraceService.ts (for ConversationTurn type and transformToConversationTurns pattern)
@test-agent/src/services/category-classifier.ts (for pattern reference -- this classifies AGENT responses, the new service classifies CALLER intent)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CallerIntentClassifier service</name>
  <files>backend/src/services/callerIntentClassifier.ts</files>
  <action>
Create `backend/src/services/callerIntentClassifier.ts` with:

1. **Types/Interfaces:**
   ```typescript
   interface BookingDetails {
     childCount: number;
     childNames: string[];
     parentName: string;
     parentPhone: string;
     requestedDates: string[];
   }

   interface CallerIntent {
     type: 'booking' | 'rescheduling' | 'cancellation' | 'info_lookup';
     confidence: number; // 0-1
     bookingDetails?: BookingDetails; // populated for booking and rescheduling
     summary: string; // one-line human-readable summary of what caller wanted
   }
   ```

2. **classifyCallerIntent(transcript: ConversationTurn[]): Promise<CallerIntent>**
   - Takes transcript array (from existing `transformToConversationTurns`)
   - Builds full transcript text: `[role]: content` per turn
   - Sends to Anthropic claude-3-5-haiku via direct HTTP fetch (the project already uses this pattern in category-classifier.ts -- check how it calls LLM there)
   - System prompt instructs LLM to:
     - Classify the caller's PRIMARY intent from the conversation
     - Extract booking details if booking or rescheduling
     - Return structured JSON matching CallerIntent schema
   - Parse LLM response, validate with basic checks
   - If transcript is empty or too short, return `{ type: 'info_lookup', confidence: 0.5, summary: 'Insufficient transcript data' }`

3. **LLM prompt design:**
   - System: "You analyze orthodontic appointment scheduling call transcripts. Classify the caller's primary intent and extract relevant details. Return JSON only."
   - Include the CallerIntent JSON schema in the prompt
   - User message: the full transcript text
   - Use temperature 0 for deterministic results

4. **Environment:** Use `ANTHROPIC_API_KEY` env var (check .env file for what's already configured). If the project uses a different env var name for Anthropic, match it.

5. **Error handling:** If LLM call fails, return a fallback with type='info_lookup', confidence=0, summary describing the error.

6. **Export:** Export the function and all types.

IMPORTANT: Check how `category-classifier.ts` in test-agent makes LLM calls. If it uses the Anthropic SDK, use the same approach. If it uses raw fetch, use raw fetch. Match the existing pattern.
  </action>
  <verify>
    - `npx tsc --noEmit` passes (or the project's existing typecheck command)
    - File exports classifyCallerIntent, CallerIntent, BookingDetails
    - Grep for ANTHROPIC_API_KEY or equivalent env var usage
  </verify>
  <done>
    - CallerIntentClassifier service exists with classifyCallerIntent() that accepts ConversationTurn[] and returns CallerIntent
    - Handles all 4 intent types (booking, rescheduling, cancellation, info_lookup)
    - Extracts BookingDetails for booking/rescheduling intents
    - Uses LLM (haiku) matching existing project patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tool sequence mapper service</name>
  <files>backend/src/services/toolSequenceMapper.ts</files>
  <action>
Create `backend/src/services/toolSequenceMapper.ts` with:

1. **Types:**
   ```typescript
   interface ExpectedStep {
     toolName: string;
     action?: string;
     description: string;
     occurrences: 'once' | 'per_child';
   }

   interface StepStatus {
     step: ExpectedStep;
     status: 'completed' | 'failed' | 'missing';
     actualCount: number;
     expectedCount: number;
     observationIds: string[];
     errors: string[];
   }

   interface ToolSequenceResult {
     expectedSteps: ExpectedStep[];
     stepStatuses: StepStatus[];
     completionRate: number; // 0-1, how many expected steps were completed
   }
   ```

2. **getExpectedSequence(intent: CallerIntent): ExpectedStep[]**
   Define expected tool sequences for each intent type:

   - **booking** (N children from bookingDetails.childCount, default 1):
     - current_date_time (once)
     - chord_ortho_patient action=lookup (once)
     - schedule_appointment_ortho action=slots (per_child)
     - chord_ortho_patient action=create_patient (per_child, optional -- only if child is new)
     - schedule_appointment_ortho action=book_child (per_child)

   - **rescheduling**:
     - current_date_time (once)
     - chord_ortho_patient action=lookup (once)
     - schedule_appointment_ortho action=slots (once)
     - schedule_appointment_ortho action=cancel (once)
     - schedule_appointment_ortho action=book_child (once)

   - **cancellation**:
     - chord_ortho_patient action=lookup (once)
     - schedule_appointment_ortho action=cancel (once)

   - **info_lookup**:
     - chord_ortho_patient action=lookup (once)

3. **mapToolSequence(intent: CallerIntent, observations: any[]): ToolSequenceResult**
   - Get expected sequence from intent
   - For each expected step, search observations for matching tool calls:
     - Match by `name` field (observation name matches toolName)
     - Match by `action` in parsed `input` JSON (if action specified)
     - Detect errors: check `level === 'ERROR'` OR output contains `"success":false` OR `"_debug_error"`
   - Compute status per step: completed (found, no error), failed (found, has error), missing (not found)
   - For 'per_child' steps, expectedCount = intent.bookingDetails?.childCount || 1
   - Compute completionRate = completed / total expected

4. **Export all types and functions.**

IMPORTANT: Use the error detection pattern from research -- Pitfall 5. Check obs.level, obs.output for "success":false and "_debug_error".
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports getExpectedSequence, mapToolSequence, ToolSequenceResult, StepStatus
  </verify>
  <done>
    - Tool sequence mapper exists covering all 4 intent types
    - Maps expected vs actual tool calls from observations
    - Reports completed/failed/missing status per step
    - Handles per-child multiplied expectations for booking intents
  </done>
</task>

</tasks>

<verification>
- Both new service files compile without errors
- Both export their public interfaces
- callerIntentClassifier uses LLM matching existing project conventions
- toolSequenceMapper covers all 4 intent types with correct expected sequences
</verification>

<success_criteria>
- classifyCallerIntent() accepts conversation transcript and returns structured CallerIntent with type, confidence, and bookingDetails
- mapToolSequence() accepts CallerIntent + observations and returns step-by-step completion status
- All types are exported for use by the orchestration endpoint (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/01-trace-foundation/01-01-SUMMARY.md`
</output>
