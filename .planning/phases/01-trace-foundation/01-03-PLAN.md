---
phase: 01-trace-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - backend/src/controllers/traceAnalysisController.ts
  - backend/src/routes/traceAnalysis.ts
  - backend/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Given a session ID, the API returns complete trace with observations, transcript, intent classification, and tool sequence status"
    - "Analysis results are cached in session_analysis table so repeat requests are fast"
    - "Multi-trace sessions are grouped into single conversation view"
    - "Endpoint handles sessions that haven't been imported yet (imports on demand)"
  artifacts:
    - path: "backend/src/controllers/traceAnalysisController.ts"
      provides: "Trace analysis orchestration controller"
      exports: ["analyzeSession"]
    - path: "backend/src/routes/traceAnalysis.ts"
      provides: "Express route for /api/trace-analysis"
      exports: ["default"]
  key_links:
    - from: "backend/src/routes/traceAnalysis.ts"
      to: "backend/src/controllers/traceAnalysisController.ts"
      via: "Express route handler"
      pattern: "router\\.get.*analyzeSession"
    - from: "backend/src/controllers/traceAnalysisController.ts"
      to: "backend/src/services/callerIntentClassifier.ts"
      via: "import classifyCallerIntent"
      pattern: "classifyCallerIntent"
    - from: "backend/src/controllers/traceAnalysisController.ts"
      to: "backend/src/services/toolSequenceMapper.ts"
      via: "import mapToolSequence"
      pattern: "mapToolSequence"
    - from: "backend/src/controllers/traceAnalysisController.ts"
      to: "backend/src/services/langfuseTraceService.ts"
      via: "import LangfuseTraceService"
      pattern: "LangfuseTraceService"
    - from: "backend/src/index.ts"
      to: "backend/src/routes/traceAnalysis.ts"
      via: "app.use mount"
      pattern: "trace-analysis"
---

<objective>
Create the trace analysis API endpoint that orchestrates all Phase 1 services: trace retrieval, transcript extraction, intent classification, and tool sequence mapping into a single response.

Purpose: This is the integration layer that ties together the services from Plan 01 (intent classifier, tool mapper) and Plan 02 (database schema, verified trace infrastructure). It provides the API that Phase 3 UI will consume.

Output: `GET /api/trace-analysis/:sessionId` endpoint returning complete analysis.
</objective>

<execution_context>
@C:\Users\mwoic\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mwoic\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-trace-foundation/01-RESEARCH.md
@.planning/phases/01-trace-foundation/01-01-SUMMARY.md
@.planning/phases/01-trace-foundation/01-02-SUMMARY.md

Key files to import from:
@backend/src/services/callerIntentClassifier.ts
@backend/src/services/toolSequenceMapper.ts
@backend/src/services/langfuseTraceService.ts
@backend/src/controllers/testMonitorController.ts (for transformToConversationTurns, filterInternalTraces)
@backend/src/routes/testMonitor.ts (for route pattern reference)
@backend/src/index.ts (for route mounting pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trace analysis controller and route</name>
  <files>
    backend/src/controllers/traceAnalysisController.ts
    backend/src/routes/traceAnalysis.ts
  </files>
  <action>
**Create `backend/src/controllers/traceAnalysisController.ts`:**

Implement `analyzeSession(req, res)` handler for `GET /api/trace-analysis/:sessionId`:

1. **Get DB connection:** Import the database instance used by the rest of the backend. Check how other controllers (e.g., testMonitorController.ts) obtain the DB reference -- likely via `import db from '../database'` or similar. Use the same import pattern. This is needed for querying and writing to the session_analysis table.

2. **Check cache first:** Query `session_analysis` table for this session_id. If found and analyzed_at is within 1 hour, return cached result.

3. **Import session if needed:** Use LangfuseTraceService to check if session exists locally. If not, call `importSessionTraces(sessionId, configId)`. Use configId=1 (Production) as default, accept `?configId=N` query param override.

4. **Get session data:** Call `getSession(sessionId)` to get all traces and observations.

5. **Build transcript:** For each trace in session, call `transformToConversationTurns(trace, filterInternalTraces(observations))`. Concatenate transcripts across traces in chronological order.

6. **Classify intent:** Call `classifyCallerIntent(transcript)` from Plan 01's service.

7. **Map tool sequence:** Collect all observations across all session traces. Call `mapToolSequence(intent, allObservations)` from Plan 01's service.

8. **Cache results:** INSERT OR REPLACE into session_analysis table using the DB connection from step 1.

9. **Return response:**
   ```json
   {
     "sessionId": "...",
     "traces": [{ "traceId": "...", "timestamp": "...", "name": "..." }],
     "transcript": [{ "role": "user|assistant", "content": "...", "timestamp": "..." }],
     "intent": { "type": "booking", "confidence": 0.95, "summary": "...", "bookingDetails": {...} },
     "toolSequence": { "expectedSteps": [...], "stepStatuses": [...], "completionRate": 0.85 },
     "analyzedAt": "..."
   }
   ```

10. **Error handling:**
   - 404 if session not found in Langfuse
   - 500 with error message if LLM classification fails (but still return trace/transcript data)
   - Accept `?force=true` query param to bypass cache

Also add: `GET /api/trace-analysis/:sessionId/intent` -- returns just the intent (lighter endpoint).

**Create `backend/src/routes/traceAnalysis.ts`:**

Follow the pattern from `backend/src/routes/testMonitor.ts`:
- Import express Router
- Import controller functions
- Define routes
- Export default router

Routes:
- `GET /:sessionId` -> analyzeSession
- `GET /:sessionId/intent` -> getIntent (lighter version)

**Mount route in `backend/src/index.ts`:**
- Add `import traceAnalysisRoutes from './routes/traceAnalysis'`
- Add `app.use('/api/trace-analysis', traceAnalysisRoutes)`
- Place near existing route mounts (look at how testMonitor routes are mounted)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Start the backend server and confirm route is registered (check startup logs or hit `GET /api/trace-analysis/test-session-id` -- should return 404 not 500)
    - Grep for '/api/trace-analysis' in index.ts to confirm mounting
  </verify>
  <done>
    - GET /api/trace-analysis/:sessionId endpoint exists and returns complete analysis
    - Response includes traces, transcript, intent, toolSequence, analyzedAt
    - Results cached in session_analysis table
    - Cache bypass via ?force=true
    - Route mounted in Express app
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end smoke test with real session</name>
  <files>backend/src/controllers/traceAnalysisController.ts</files>
  <action>
Run an end-to-end test using a real session ID from the database:

1. Query the local database for a recent session:
   ```sql
   SELECT session_id FROM production_sessions ORDER BY created_at DESC LIMIT 5;
   ```

2. Pick a session that has traces and observations.

3. Hit the endpoint: `curl http://localhost:3002/api/trace-analysis/{sessionId}`

4. Verify the response contains all required fields by checking the JSON programmatically:
   ```bash
   curl -s http://localhost:3002/api/trace-analysis/{sessionId} | node -e "
     const data = JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));
     const required = ['sessionId','traces','transcript','intent','toolSequence','analyzedAt'];
     const missing = required.filter(k => !(k in data));
     if (missing.length) { console.error('MISSING fields:', missing); process.exit(1); }
     if (!Array.isArray(data.traces) || data.traces.length === 0) { console.error('traces should be non-empty array'); process.exit(1); }
     if (!Array.isArray(data.transcript)) { console.error('transcript should be array'); process.exit(1); }
     if (!data.intent || !data.intent.type) { console.error('intent.type missing'); process.exit(1); }
     if (!data.toolSequence || typeof data.toolSequence.completionRate !== 'number') { console.error('toolSequence.completionRate missing'); process.exit(1); }
     console.log('All fields validated OK');
     console.log('Intent:', data.intent.type, '| Confidence:', data.intent.confidence, '| Completion:', data.toolSequence.completionRate);
   "
   ```

5. Hit the same endpoint again and verify it returns cached result (check `analyzedAt` timestamp is the same, response is faster).

6. Hit with `?force=true` and verify fresh analysis runs.

7. If any errors, fix them. Common issues:
   - Import paths wrong (check relative vs absolute)
   - transformToConversationTurns not exported (should be fixed by Plan 02)
   - Database connection not passed correctly to LangfuseTraceService
   - ANTHROPIC_API_KEY not set (check .env)

Do NOT write a test file -- this is a manual smoke test via curl. Fix any issues found.
  </action>
  <verify>
    - curl to /api/trace-analysis/:sessionId returns 200 with complete analysis JSON
    - Programmatic JSON validation confirms all required fields: sessionId, traces (non-empty array), transcript (array), intent.type, toolSequence.completionRate
    - Second request returns cached result (same analyzedAt)
    - ?force=true triggers fresh analysis (different analyzedAt)
  </verify>
  <done>
    - End-to-end flow works: session ID in -> complete analysis out
    - All response fields validated programmatically
    - Caching works correctly
    - No runtime errors in happy path
  </done>
</task>

</tasks>

<verification>
- `GET /api/trace-analysis/:sessionId` returns complete analysis for a real session
- Response includes all required fields: traces, transcript, intent, toolSequence
- Caching works (repeat request returns cached)
- Force refresh works (?force=true)
- Backend compiles and starts without errors
</verification>

<success_criteria>
- Single API endpoint delivers complete trace analysis for any session ID
- Intent classification and tool sequence mapping integrated end-to-end
- Results cached in database for fast repeat access
- All Phase 1 requirements (TRACE-01 through INTENT-04) satisfied at the API level
</success_criteria>

<output>
After completion, create `.planning/phases/01-trace-foundation/01-03-SUMMARY.md`
</output>
